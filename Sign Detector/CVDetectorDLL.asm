; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\OJ\Documents\Visual Studio 2010\Projects\CVDetectorDLL\CVDetectorDLL.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4CascadeClassifier@cv@@6B@			; cv::CascadeClassifier::`RTTI Complete Object Locator'
PUBLIC	??_R3CascadeClassifier@cv@@8			; cv::CascadeClassifier::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CascadeClassifier@cv@@8			; cv::CascadeClassifier::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CascadeClassifier@cv@@8		; cv::CascadeClassifier::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCascadeClassifier@cv@@@8		; cv::CascadeClassifier `RTTI Type Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?type@Mat@cv@@QBEHXZ				; cv::Mat::type
PUBLIC	?create@Mat@cv@@QAEXHHH@Z			; cv::Mat::create
PUBLIC	??0?$Size_@H@cv@@QAE@XZ				; cv::Size_<int>::Size_<int>
PUBLIC	??0?$Size_@H@cv@@QAE@HH@Z			; cv::Size_<int>::Size_<int>
PUBLIC	?initEmpty@Mat@cv@@IAEXXZ			; cv::Mat::initEmpty
PUBLIC	??0Mat@cv@@QAE@XZ				; cv::Mat::Mat
PUBLIC	??0?$Matx@N$03$00@cv@@QAE@XZ			; cv::Matx<double,4,1>::Matx<double,4,1>
PUBLIC	??0?$Vec@N$03@cv@@QAE@XZ			; cv::Vec<double,4>::Vec<double,4>
PUBLIC	??0?$Scalar_@N@cv@@QAE@NNNN@Z			; cv::Scalar_<double>::Scalar_<double>
PUBLIC	??0?$Point_@H@cv@@QAE@HH@Z			; cv::Point_<int>::Point_<int>
PUBLIC	??0?$Point_@H@cv@@QAE@ABV01@@Z			; cv::Point_<int>::Point_<int>
PUBLIC	??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@XZ	; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >
PUBLIC	??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@ABV01@@Z ; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >
PUBLIC	??0?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@V?$allocator@V?$Rect_@H@cv@@@1@@Z ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
PUBLIC	??0?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
PUBLIC	??1?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
PUBLIC	?deallocate@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@I@Z ; std::allocator<cv::Rect_<int> >::deallocate
PUBLIC	??$_Ptr_cat@V?$Rect_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Rect_@H@cv@@0@Z ; std::_Ptr_cat<cv::Rect_<int>,cv::Rect_<int> >
PUBLIC	??$_Destroy@V?$Rect_@H@cv@@@std@@YAXPAV?$Rect_@H@cv@@@Z ; std::_Destroy<cv::Rect_<int> >
PUBLIC	?destroy@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@@Z ; std::allocator<cv::Rect_<int> >::destroy
PUBLIC	??$_Dest_val@V?$allocator@V?$Rect_@H@cv@@@std@@V?$Rect_@H@cv@@@std@@YAXAAV?$allocator@V?$Rect_@H@cv@@@0@PAV?$Rect_@H@cv@@@Z ; std::_Dest_val<std::allocator<cv::Rect_<int> >,cv::Rect_<int> >
PUBLIC	??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >
PUBLIC	?_Destroy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXPAV?$Rect_@H@cv@@0@Z ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Tidy
PUBLIC	??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
PUBLIC	?size@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::size
PUBLIC	??A?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAEAAV?$Rect_@H@cv@@I@Z ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::operator[]
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??0MSize@Mat@cv@@QAE@PAH@Z			; cv::Mat::MSize::MSize
PUBLIC	??0MStep@Mat@cv@@QAE@XZ				; cv::Mat::MStep::MStep
PUBLIC	??AMStep@Mat@cv@@QBEABIH@Z			; cv::Mat::MStep::operator[]
PUBLIC	??AMStep@Mat@cv@@QAEAAIH@Z			; cv::Mat::MStep::operator[]
PUBLIC	??0Mat@cv@@QAE@ABV01@@Z				; cv::Mat::Mat
PUBLIC	?release@Mat@cv@@QAEXXZ				; cv::Mat::release
PUBLIC	??1Mat@cv@@QAE@XZ				; cv::Mat::~Mat
PUBLIC	?release@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ ; cv::Ptr<CvHaarClassifierCascade>::release
PUBLIC	??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ	; cv::Ptr<CvHaarClassifierCascade>::~Ptr<CvHaarClassifierCascade>
PUBLIC	?addref@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ ; cv::Ptr<CvHaarClassifierCascade>::addref
PUBLIC	??0?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@ABV01@@Z ; cv::Ptr<CvHaarClassifierCascade>::Ptr<CvHaarClassifierCascade>
PUBLIC	??1Data@CascadeClassifier@cv@@QAE@XZ		; cv::CascadeClassifier::Data::~Data
PUBLIC	??0?$Size_@H@cv@@QAE@ABV01@@Z			; cv::Size_<int>::Size_<int>
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@AAPAH@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=
PUBLIC	??$_Construct@HABH@std@@YAXPAHABH@Z		; std::_Construct<int,int const &>
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
PUBLIC	??$_Destroy@H@std@@YAXPAH@Z			; std::_Destroy<int>
PUBLIC	?destroy@?$allocator@H@std@@QAEXPAH@Z		; std::allocator<int>::destroy
PUBLIC	??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z ; std::_Dest_val<std::allocator<int>,int>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@1@0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > > >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??0?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocator<cv::CascadeClassifier::Data::Stage>
PUBLIC	??0?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UStage@Data@CascadeClassifier@cv@@@1@@Z ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	?begin@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::begin
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUStage@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >
PUBLIC	?end@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::end
PUBLIC	?size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::size
PUBLIC	??$_Allocate@UStage@Data@CascadeClassifier@cv@@@std@@YAPAUStage@Data@CascadeClassifier@cv@@IPAU1234@@Z ; std::_Allocate<cv::CascadeClassifier::Data::Stage>
PUBLIC	?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate
PUBLIC	?max_size@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QBEIXZ ; std::allocator<cv::CascadeClassifier::Data::Stage>::max_size
PUBLIC	?max_size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::max_size
PUBLIC	?_Xlen@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Xlen
PUBLIC	?_Buy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUStage@Data@CascadeClassifier@cv@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUStage@Data@CascadeClassifier@cv@@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator!=
PUBLIC	??$_Construct@UStage@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::_Construct<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>
PUBLIC	?construct@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@ABU3456@@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::construct
PUBLIC	??$forward@ABUStage@Data@CascadeClassifier@cv@@@std@@YAABUStage@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::forward<cv::CascadeClassifier::Data::Stage const &>
PUBLIC	??$_Cons_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@ABU2345@@Z ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > > >
PUBLIC	??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??1?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	?deallocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::deallocate
PUBLIC	??$_Ptr_cat@UStage@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUStage@Data@CascadeClassifier@cv@@0@Z ; std::_Ptr_cat<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage>
PUBLIC	??$_Destroy@UStage@Data@CascadeClassifier@cv@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@@Z ; std::_Destroy<cv::CascadeClassifier::Data::Stage>
PUBLIC	?destroy@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::destroy
PUBLIC	??$_Dest_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@@Z ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage>
PUBLIC	??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	?_Destroy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUStage@Data@CascadeClassifier@cv@@0@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Destroy
PUBLIC	?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Tidy
PUBLIC	??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??0?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocator<cv::CascadeClassifier::Data::DTree>
PUBLIC	??0?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@1@@Z ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	?begin@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::begin
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTree@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >
PUBLIC	?end@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::end
PUBLIC	?size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::size
PUBLIC	??$_Allocate@UDTree@Data@CascadeClassifier@cv@@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@IPAU1234@@Z ; std::_Allocate<cv::CascadeClassifier::Data::DTree>
PUBLIC	?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate
PUBLIC	?max_size@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QBEIXZ ; std::allocator<cv::CascadeClassifier::Data::DTree>::max_size
PUBLIC	?max_size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::max_size
PUBLIC	?_Xlen@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Xlen
PUBLIC	?_Buy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTree@Data@CascadeClassifier@cv@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTree@Data@CascadeClassifier@cv@@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator!=
PUBLIC	??$_Construct@UDTree@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::_Construct<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>
PUBLIC	?construct@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@ABU3456@@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::construct
PUBLIC	??$forward@ABUDTree@Data@CascadeClassifier@cv@@@std@@YAABUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::forward<cv::CascadeClassifier::Data::DTree const &>
PUBLIC	??$_Cons_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@ABU2345@@Z ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > > >
PUBLIC	??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??1?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	?deallocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::deallocate
PUBLIC	??$_Ptr_cat@UDTree@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTree@Data@CascadeClassifier@cv@@0@Z ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree>
PUBLIC	??$_Destroy@UDTree@Data@CascadeClassifier@cv@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@@Z ; std::_Destroy<cv::CascadeClassifier::Data::DTree>
PUBLIC	?destroy@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::destroy
PUBLIC	??$_Dest_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@@Z ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree>
PUBLIC	??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	?_Destroy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTree@Data@CascadeClassifier@cv@@0@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Destroy
PUBLIC	?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Tidy
PUBLIC	??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??0?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocator<cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	??0?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@1@@Z ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	?begin@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::begin
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTreeNode@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >
PUBLIC	?end@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::end
PUBLIC	?size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::size
PUBLIC	??$_Allocate@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@IPAU1234@@Z ; std::_Allocate<cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate
PUBLIC	?max_size@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QBEIXZ ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::max_size
PUBLIC	?max_size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::max_size
PUBLIC	?_Xlen@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Xlen
PUBLIC	?_Buy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTreeNode@Data@CascadeClassifier@cv@@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator!=
PUBLIC	??$_Construct@UDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::_Construct<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>
PUBLIC	?construct@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::construct
PUBLIC	??$forward@ABUDTreeNode@Data@CascadeClassifier@cv@@@std@@YAABUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::forward<cv::CascadeClassifier::Data::DTreeNode const &>
PUBLIC	??$_Cons_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@ABU2345@@Z ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > > >
PUBLIC	??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??1?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	?deallocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::deallocate
PUBLIC	??$_Ptr_cat@UDTreeNode@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTreeNode@Data@CascadeClassifier@cv@@0@Z ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	??$_Destroy@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ; std::_Destroy<cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	?destroy@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::destroy
PUBLIC	??$_Dest_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@@Z ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	?_Destroy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTreeNode@Data@CascadeClassifier@cv@@0@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Destroy
PUBLIC	?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Tidy
PUBLIC	??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??0?$allocator@M@std@@QAE@ABV01@@Z		; std::allocator<float>::allocator<float>
PUBLIC	??0?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@V?$allocator@M@1@@Z ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
PUBLIC	?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ ; std::vector<float,std::allocator<float> >::begin
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAE@PAMPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >
PUBLIC	?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ ; std::vector<float,std::allocator<float> >::end
PUBLIC	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::size
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@M@std@@YAPAMIPAM@Z			; std::_Allocate<float>
PUBLIC	?allocate@?$allocator@M@std@@QAEPAMI@Z		; std::allocator<float>::allocate
PUBLIC	?max_size@?$allocator@M@std@@QBEIXZ		; std::allocator<float>::max_size
PUBLIC	?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::max_size
PUBLIC	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ ; std::vector<float,std::allocator<float> >::_Xlen
PUBLIC	?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ; std::vector<float,std::allocator<float> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAM@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@AAPAM@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEABMXZ ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator!=
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$_Construct@MABM@std@@YAXPAMABM@Z		; std::_Construct<float,float const &>
PUBLIC	?construct@?$allocator@M@std@@QAEXPAMABM@Z	; std::allocator<float>::construct
PUBLIC	??$forward@ABM@std@@YAABMABM@Z			; std::forward<float const &>
PUBLIC	??$_Cons_val@V?$allocator@M@std@@MABM@std@@YAXAAV?$allocator@M@0@PAMABM@Z ; std::_Cons_val<std::allocator<float>,float,float const &>
PUBLIC	??$_Destroy@M@std@@YAXPAM@Z			; std::_Destroy<float>
PUBLIC	?destroy@?$allocator@M@std@@QAEXPAM@Z		; std::allocator<float>::destroy
PUBLIC	??$_Dest_val@V?$allocator@M@std@@M@std@@YAXAAV?$allocator@M@0@PAM@Z ; std::_Dest_val<std::allocator<float>,float>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IAEPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@1@0PAM@Z ; std::vector<float,std::allocator<float> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > > >
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
PUBLIC	?deallocate@?$allocator@M@std@@QAEXPAMI@Z	; std::allocator<float>::deallocate
PUBLIC	??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z ; std::_Ptr_cat<float,float>
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ; std::vector<float,std::allocator<float> >::_Destroy
PUBLIC	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float> >::_Tidy
PUBLIC	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
PUBLIC	??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z	; cv::CascadeClassifier::Data::Data
PUBLIC	?delete_obj@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::FeatureEvaluator>::delete_obj
PUBLIC	?release@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::FeatureEvaluator>::release
PUBLIC	??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ	; cv::Ptr<cv::FeatureEvaluator>::~Ptr<cv::FeatureEvaluator>
PUBLIC	?addref@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ	; cv::Ptr<cv::FeatureEvaluator>::addref
PUBLIC	??0?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@ABV01@@Z ; cv::Ptr<cv::FeatureEvaluator>::Ptr<cv::FeatureEvaluator>
PUBLIC	?delete_obj@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::delete_obj
PUBLIC	?release@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::release
PUBLIC	??1?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@XZ ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::~Ptr<cv::CascadeClassifier::MaskGenerator>
PUBLIC	?addref@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::addref
PUBLIC	??0?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@ABV01@@Z ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::Ptr<cv::CascadeClassifier::MaskGenerator>
PUBLIC	??_GCascadeClassifier@cv@@UAEPAXI@Z		; cv::CascadeClassifier::`scalar deleting destructor'
PUBLIC	??0CascadeClassifier@cv@@QAE@ABV01@@Z		; cv::CascadeClassifier::CascadeClassifier
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	_signID
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0O@ENPJBMMB@Detecting?5?4?4?4?$AA@	; `string'
PUBLIC	??_C@_0BG@GANHPLLF@classifier_enable?4xml?$AA@	; `string'
PUBLIC	??_C@_0BH@OOLANKBA@classifier_disable?4xml?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7CascadeClassifier@cv@@6B@			; cv::CascadeClassifier::`vftable'
EXTRN	?runAt@CascadeClassifier@cv@@MAEHAAV?$Ptr@VFeatureEvaluator@cv@@@2@V?$Point_@H@2@AAN@Z:PROC ; cv::CascadeClassifier::runAt
EXTRN	?detectSingleScale@CascadeClassifier@cv@@MAE_NABVMat@2@HV?$Size_@H@2@HHNAAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@6@AAV?$vector@NV?$allocator@N@std@@@6@_N@Z:PROC ; cv::CascadeClassifier::detectSingleScale
EXTRN	?getOriginalWindowSize@CascadeClassifier@cv@@UBE?AV?$Size_@H@2@XZ:PROC ; cv::CascadeClassifier::getOriginalWindowSize
EXTRN	?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@NHHV?$Size_@H@2@2@Z:PROC ; cv::CascadeClassifier::detectMultiScale
EXTRN	?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@5@AAV?$vector@NV?$allocator@N@std@@@5@NHHV?$Size_@H@2@4_N@Z:PROC ; cv::CascadeClassifier::detectMultiScale
EXTRN	?read@CascadeClassifier@cv@@UAE_NABVFileNode@2@@Z:PROC ; cv::CascadeClassifier::read
EXTRN	?empty@CascadeClassifier@cv@@UBE_NXZ:PROC	; cv::CascadeClassifier::empty
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp_?create@Mat@cv@@QAEXHPBHH@Z:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__GetDIBits@28:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__StretchBlt@44:PROC
EXTRN	__imp__SetStretchBltMode@8:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp_??0_InputArray@cv@@QAE@ABVMat@1@@Z:PROC
EXTRN	__imp_??0_OutputArray@cv@@QAE@AAVMat@1@@Z:PROC
EXTRN	__imp_?ellipse@cv@@YAXAAVMat@1@V?$Point_@H@1@V?$Size_@H@1@NNNABV?$Scalar_@N@1@HHH@Z:PROC
EXTRN	__imp_?equalizeHist@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@@Z:PROC
EXTRN	__imp_?cvtColor@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@HH@Z:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_??0CascadeClassifier@cv@@QAE@XZ:PROC
EXTRN	__imp_?load@CascadeClassifier@cv@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC
EXTRN	__imp__CreateCompatibleBitmap@12:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp_?copySize@Mat@cv@@QAEXABV12@@Z:PROC
EXTRN	__imp_?deallocate@Mat@cv@@QAEXXZ:PROC
EXTRN	__imp_?delete_obj@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ:PROC
EXTRN	__imp_??2@YAPAXI@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?what@exception@std@@UBEPBDXZ:PROC
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
EXTRN	__imp_?fastFree@cv@@YAXPAX@Z:PROC
EXTRN	__imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z:PROC
EXTRN	__imp_?empty@CascadeClassifier@cv@@UBE_NXZ:PROC
EXTRN	__imp_?read@CascadeClassifier@cv@@UAE_NABVFileNode@2@@Z:PROC
EXTRN	__imp_?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@NHHV?$Size_@H@2@2@Z:PROC
EXTRN	__imp_?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@5@AAV?$vector@NV?$allocator@N@std@@@5@NHHV?$Size_@H@2@4_N@Z:PROC
EXTRN	__imp_?getOriginalWindowSize@CascadeClassifier@cv@@UBE?AV?$Size_@H@2@XZ:PROC
EXTRN	__imp_?detectSingleScale@CascadeClassifier@cv@@MAE_NABVMat@2@HV?$Size_@H@2@HHNAAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@6@AAV?$vector@NV?$allocator@N@std@@@6@_N@Z:PROC
EXTRN	__imp_?runAt@CascadeClassifier@cv@@MAEHAAV?$Ptr@VFeatureEvaluator@cv@@@2@V?$Point_@H@2@AAN@Z:PROC
EXTRN	__imp_??1CascadeClassifier@cv@@UAE@XZ:PROC
EXTRN	??_ECascadeClassifier@cv@@UAEPAXI@Z:PROC	; cv::CascadeClassifier::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_atexit:PROC
EXTRN	__imp_??3@YAXPAX@Z:PROC
_signID	DQ	01H DUP (?)
;	COMDAT ??_7CascadeClassifier@cv@@6B@
CONST	SEGMENT
??_7CascadeClassifier@cv@@6B@ DD FLAT:??_R4CascadeClassifier@cv@@6B@ ; cv::CascadeClassifier::`vftable'
	DD	FLAT:??_ECascadeClassifier@cv@@UAEPAXI@Z
	DD	FLAT:?empty@CascadeClassifier@cv@@UBE_NXZ
	DD	FLAT:?read@CascadeClassifier@cv@@UAE_NABVFileNode@2@@Z
	DD	FLAT:?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@5@AAV?$vector@NV?$allocator@N@std@@@5@NHHV?$Size_@H@2@4_N@Z
	DD	FLAT:?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@NHHV?$Size_@H@2@2@Z
	DD	FLAT:?getOriginalWindowSize@CascadeClassifier@cv@@UBE?AV?$Size_@H@2@XZ
	DD	FLAT:?detectSingleScale@CascadeClassifier@cv@@MAE_NABVMat@2@HV?$Size_@H@2@HHNAAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@6@AAV?$vector@NV?$allocator@N@std@@@6@_N@Z
	DD	FLAT:?runAt@CascadeClassifier@cv@@MAEHAAV?$Ptr@VFeatureEvaluator@cv@@@2@V?$Point_@H@2@AAN@Z
CONST	ENDS
;	COMDAT ??_R4CascadeClassifier@cv@@6B@
rdata$r	SEGMENT
??_R4CascadeClassifier@cv@@6B@ DD 00H			; cv::CascadeClassifier::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCascadeClassifier@cv@@@8
	DD	FLAT:??_R3CascadeClassifier@cv@@8
rdata$r	ENDS
;	COMDAT ??_R3CascadeClassifier@cv@@8
rdata$r	SEGMENT
??_R3CascadeClassifier@cv@@8 DD 00H			; cv::CascadeClassifier::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CascadeClassifier@cv@@8
rdata$r	ENDS
;	COMDAT ??_R2CascadeClassifier@cv@@8
rdata$r	SEGMENT
??_R2CascadeClassifier@cv@@8 DD FLAT:??_R1A@?0A@EA@CascadeClassifier@cv@@8 ; cv::CascadeClassifier::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CascadeClassifier@cv@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CascadeClassifier@cv@@8 DD FLAT:??_R0?AVCascadeClassifier@cv@@@8 ; cv::CascadeClassifier::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CascadeClassifier@cv@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCascadeClassifier@cv@@@8
_DATA	SEGMENT
??_R0?AVCascadeClassifier@cv@@@8 DD FLAT:??_7type_info@@6B@ ; cv::CascadeClassifier `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCascadeClassifier@cv@@', 00H
_DATA	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OOLANKBA@classifier_disable?4xml?$AA@
CONST	SEGMENT
??_C@_0BH@OOLANKBA@classifier_disable?4xml?$AA@ DB 'classifier_disable.xm'
	DB	'l', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GANHPLLF@classifier_enable?4xml?$AA@
CONST	SEGMENT
??_C@_0BG@GANHPLLF@classifier_enable?4xml?$AA@ DB 'classifier_enable.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ENPJBMMB@Detecting?5?4?4?4?$AA@
CONST	SEGMENT
??_C@_0O@ENPJBMMB@Detecting?5?4?4?4?$AA@ DB 'Detecting ...', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_DATA	ENDS
;	COMDAT ??$_Destroy@M@std@@YAXPAM@Z
_TEXT	SEGMENT
??$_Destroy@M@std@@YAXPAM@Z PROC			; std::_Destroy<float>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@M@std@@YAXPAM@Z ENDP			; std::_Destroy<float>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@H@std@@YAXPAH@Z
_TEXT	SEGMENT
??$_Destroy@H@std@@YAXPAH@Z PROC			; std::_Destroy<int>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@H@std@@YAXPAH@Z ENDP			; std::_Destroy<int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABM@std@@YAABMABM@Z
_TEXT	SEGMENT
??$forward@ABM@std@@YAABMABM@Z PROC			; std::forward<float const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABM@std@@YAABMABM@Z ENDP			; std::forward<float const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABUDTreeNode@Data@CascadeClassifier@cv@@@std@@YAABUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$forward@ABUDTreeNode@Data@CascadeClassifier@cv@@@std@@YAABUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::forward<cv::CascadeClassifier::Data::DTreeNode const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABUDTreeNode@Data@CascadeClassifier@cv@@@std@@YAABUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::forward<cv::CascadeClassifier::Data::DTreeNode const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABUDTree@Data@CascadeClassifier@cv@@@std@@YAABUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$forward@ABUDTree@Data@CascadeClassifier@cv@@@std@@YAABUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::forward<cv::CascadeClassifier::Data::DTree const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABUDTree@Data@CascadeClassifier@cv@@@std@@YAABUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::forward<cv::CascadeClassifier::Data::DTree const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABUStage@Data@CascadeClassifier@cv@@@std@@YAABUStage@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$forward@ABUStage@Data@CascadeClassifier@cv@@@std@@YAABUStage@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::forward<cv::CascadeClassifier::Data::Stage const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABUStage@Data@CascadeClassifier@cv@@@std@@YAABUStage@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::forward<cv::CascadeClassifier::Data::Stage const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@M@std@@QAEXPAM@Z
_TEXT	SEGMENT
?destroy@?$allocator@M@std@@QAEXPAM@Z PROC		; std::allocator<float>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@M@std@@QAEXPAM@Z ENDP		; std::allocator<float>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@H@std@@QAEXPAH@Z
_TEXT	SEGMENT
?destroy@?$allocator@H@std@@QAEXPAH@Z PROC		; std::allocator<int>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@H@std@@QAEXPAH@Z ENDP		; std::allocator<int>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$Rect_@H@cv@@@std@@YAXPAV?$Rect_@H@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@V?$Rect_@H@cv@@@std@@YAXPAV?$Rect_@H@cv@@@Z PROC ; std::_Destroy<cv::Rect_<int> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@V?$Rect_@H@cv@@@std@@YAXPAV?$Rect_@H@cv@@@Z ENDP ; std::_Destroy<cv::Rect_<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z PROC ; std::_Destroy<cv::CascadeClassifier::Data::DTreeNode>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Destroy<cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UDTree@Data@CascadeClassifier@cv@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@UDTree@Data@CascadeClassifier@cv@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@@Z PROC ; std::_Destroy<cv::CascadeClassifier::Data::DTree>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@UDTree@Data@CascadeClassifier@cv@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Destroy<cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UStage@Data@CascadeClassifier@cv@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@UStage@Data@CascadeClassifier@cv@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@@Z PROC ; std::_Destroy<cv::CascadeClassifier::Data::Stage>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@UStage@Data@CascadeClassifier@cv@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Destroy<cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@M@std@@M@std@@YAXAAV?$allocator@M@0@PAM@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@M@std@@M@std@@YAXAAV?$allocator@M@0@PAM@Z PROC ; std::_Dest_val<std::allocator<float>,float>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@M@std@@M@std@@YAXAAV?$allocator@M@0@PAM@Z ENDP ; std::_Dest_val<std::allocator<float>,float>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z PROC ; std::_Dest_val<std::allocator<int>,int>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z ENDP ; std::_Dest_val<std::allocator<int>,int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEABMXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEABMXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEABMXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 16			; 00000010H

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTreeNode@Data@CascadeClassifier@cv@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTreeNode@Data@CascadeClassifier@cv@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTreeNode@Data@CascadeClassifier@cv@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTree@Data@CascadeClassifier@cv@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTree@Data@CascadeClassifier@cv@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTree@Data@CascadeClassifier@cv@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUStage@Data@CascadeClassifier@cv@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUStage@Data@CascadeClassifier@cv@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUStage@Data@CascadeClassifier@cv@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator*
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@@Z PROC ; std::allocator<cv::Rect_<int> >::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@@Z ENDP ; std::allocator<cv::Rect_<int> >::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@V?$Rect_@H@cv@@@std@@V?$Rect_@H@cv@@@std@@YAXAAV?$allocator@V?$Rect_@H@cv@@@0@PAV?$Rect_@H@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@V?$Rect_@H@cv@@@std@@V?$Rect_@H@cv@@@std@@YAXAAV?$allocator@V?$Rect_@H@cv@@@0@PAV?$Rect_@H@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::Rect_<int> >,cv::Rect_<int> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@V?$Rect_@H@cv@@@std@@V?$Rect_@H@cv@@@std@@YAXAAV?$allocator@V?$Rect_@H@cv@@@0@PAV?$Rect_@H@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::Rect_<int> >,cv::Rect_<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAM@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@AAPAM@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAM@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@AAPAM@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAM@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@AAPAM@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTreeNode@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTreeNode@Data@CascadeClassifier@cv@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTree@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTree@Data@CascadeClassifier@cv@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTree@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUStage@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUStage@Data@CascadeClassifier@cv@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUStage@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@AAPAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@AAPAH@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@AAPAH@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *>
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
_TEXT	ENDS
;	COMDAT ?delete_obj@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?delete_obj@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::delete_obj, COMDAT
; _this$ = eax

; 2614 :     if( obj ) delete obj;

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@delete_obj
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN4@delete_obj:

; 2615 : }

	ret	0
?delete_obj@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::delete_obj
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?delete_obj@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?delete_obj@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ PROC ; cv::Ptr<cv::FeatureEvaluator>::delete_obj, COMDAT
; _this$ = eax

; 2614 :     if( obj ) delete obj;

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@delete_obj@2
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN4@delete_obj@2:

; 2615 : }

	ret	0
?delete_obj@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ENDP ; cv::Ptr<cv::FeatureEvaluator>::delete_obj
_TEXT	ENDS
PUBLIC	__real@0000000000000000
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0?$Matx@N$03$00@cv@@QAE@XZ
_TEXT	SEGMENT
??0?$Matx@N$03$00@cv@@QAE@XZ PROC			; cv::Matx<double,4,1>::Matx<double,4,1>, COMDAT
; _this$ = eax

; 208  :     for(int i = 0; i < channels; i++) val[i] = _Tp(0);

	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]

; 209  : }

	ret	0
??0?$Matx@N$03$00@cv@@QAE@XZ ENDP			; cv::Matx<double,4,1>::Matx<double,4,1>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$Rect_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Rect_@H@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$Rect_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Rect_@H@cv@@0@Z PROC ; std::_Ptr_cat<cv::Rect_<int>,cv::Rect_<int> >, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$Rect_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Rect_@H@cv@@0@Z ENDP ; std::_Ptr_cat<cv::Rect_<int>,cv::Rect_<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 105  : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z PROC ; std::_Ptr_cat<float,float>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z ENDP ; std::_Ptr_cat<float,float>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UDTreeNode@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTreeNode@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@UDTreeNode@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTreeNode@Data@CascadeClassifier@cv@@0@Z PROC ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@UDTreeNode@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTreeNode@Data@CascadeClassifier@cv@@0@Z ENDP ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UDTree@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTree@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@UDTree@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTree@Data@CascadeClassifier@cv@@0@Z PROC ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@UDTree@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTree@Data@CascadeClassifier@cv@@0@Z ENDP ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UStage@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUStage@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@UStage@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUStage@Data@CascadeClassifier@cv@@0@Z PROC ; std::_Ptr_cat<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@UStage@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUStage@Data@CascadeClassifier@cv@@0@Z ENDP ; std::_Ptr_cat<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 105  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z PROC ; std::_Ptr_cat<int,int>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ENDP ; std::_Ptr_cat<int,int>
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
_TEXT	ENDS
;	COMDAT ?release@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?release@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::release, COMDAT
; _this$ = esi

; 2603 :     if( refcount && CV_XADD(refcount, -1) == 1 )

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN10@release
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN10@release

; 2604 :     {
; 2605 :         delete_obj();

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@release
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN7@release:

; 2606 :         fastFree(refcount);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN10@release:

; 2607 :     }
; 2608 :     refcount = 0;

	mov	DWORD PTR [esi+4], 0

; 2609 :     obj = 0;

	mov	DWORD PTR [esi], 0

; 2610 : }

	ret	0
?release@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?addref@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?addref@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::addref, COMDAT
; _this$ = eax

; 2599 : { if( refcount ) CV_XADD(refcount, 1); }

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN1@addref
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN1@addref:
	ret	0
?addref@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::addref
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?release@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?release@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ PROC	; cv::Ptr<cv::FeatureEvaluator>::release, COMDAT
; _this$ = esi

; 2603 :     if( refcount && CV_XADD(refcount, -1) == 1 )

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN10@release@2
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN10@release@2

; 2604 :     {
; 2605 :         delete_obj();

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@release@2
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN7@release@2:

; 2606 :         fastFree(refcount);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN10@release@2:

; 2607 :     }
; 2608 :     refcount = 0;

	mov	DWORD PTR [esi+4], 0

; 2609 :     obj = 0;

	mov	DWORD PTR [esi], 0

; 2610 : }

	ret	0
?release@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ENDP	; cv::Ptr<cv::FeatureEvaluator>::release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?addref@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?addref@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ PROC	; cv::Ptr<cv::FeatureEvaluator>::addref, COMDAT
; _this$ = eax

; 2599 : { if( refcount ) CV_XADD(refcount, 1); }

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN1@addref@2
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN1@addref@2:
	ret	0
?addref@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ENDP	; cv::Ptr<cv::FeatureEvaluator>::addref
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?release@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ
_TEXT	SEGMENT
?release@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ PROC ; cv::Ptr<CvHaarClassifierCascade>::release, COMDAT
; _this$ = esi

; 2603 :     if( refcount && CV_XADD(refcount, -1) == 1 )

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN5@release@3
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN5@release@3

; 2604 :     {
; 2605 :         delete_obj();

	mov	ecx, esi
	call	DWORD PTR __imp_?delete_obj@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ

; 2606 :         fastFree(refcount);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN5@release@3:

; 2607 :     }
; 2608 :     refcount = 0;

	mov	DWORD PTR [esi+4], 0

; 2609 :     obj = 0;

	mov	DWORD PTR [esi], 0

; 2610 : }

	ret	0
?release@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ ENDP ; cv::Ptr<CvHaarClassifierCascade>::release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?addref@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ
_TEXT	SEGMENT
?addref@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ PROC ; cv::Ptr<CvHaarClassifierCascade>::addref, COMDAT
; _this$ = eax

; 2599 : { if( refcount ) CV_XADD(refcount, 1); }

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN1@addref@3
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN1@addref@3:
	ret	0
?addref@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ ENDP ; cv::Ptr<CvHaarClassifierCascade>::addref
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Vec@N$03@cv@@QAE@XZ
_TEXT	SEGMENT
??0?$Vec@N$03@cv@@QAE@XZ PROC				; cv::Vec<double,4>::Vec<double,4>, COMDAT
; _this$ = eax

; 1138 : {}

	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	ret	0
??0?$Vec@N$03@cv@@QAE@XZ ENDP				; cv::Vec<double,4>::Vec<double,4>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
_TEXT	ENDS
;	COMDAT ??1?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@XZ
_TEXT	SEGMENT
??1?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@XZ PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::~Ptr<cv::CascadeClassifier::MaskGenerator>, COMDAT
; _this$ = esi

; 2617 : template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@Ptr
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN12@Ptr
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN9@Ptr
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN9@Ptr:
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN12@Ptr:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	ret	0
??1?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@XZ ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::~Ptr<cv::CascadeClassifier::MaskGenerator>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@ABV01@@Z PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::Ptr<cv::CascadeClassifier::MaskGenerator>, COMDAT
; _this$ = esi
; __ptr$ = eax

; 2621 :     obj = _ptr.obj;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx

; 2622 :     refcount = _ptr.refcount;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax

; 2623 :     addref();

	test	eax, eax
	je	SHORT $LN6@Ptr@2
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN6@Ptr@2:

; 2624 : }

	mov	eax, esi
	ret	0
??0?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@ABV01@@Z ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::Ptr<cv::CascadeClassifier::MaskGenerator>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ
_TEXT	SEGMENT
??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ PROC		; cv::Ptr<cv::FeatureEvaluator>::~Ptr<cv::FeatureEvaluator>, COMDAT
; _this$ = esi

; 2617 : template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@Ptr@3
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN12@Ptr@3
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN9@Ptr@3
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN9@Ptr@3:
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN12@Ptr@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	ret	0
??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ ENDP		; cv::Ptr<cv::FeatureEvaluator>::~Ptr<cv::FeatureEvaluator>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@ABV01@@Z PROC	; cv::Ptr<cv::FeatureEvaluator>::Ptr<cv::FeatureEvaluator>, COMDAT
; _this$ = esi
; __ptr$ = eax

; 2621 :     obj = _ptr.obj;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx

; 2622 :     refcount = _ptr.refcount;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax

; 2623 :     addref();

	test	eax, eax
	je	SHORT $LN6@Ptr@4
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN6@Ptr@4:

; 2624 : }

	mov	eax, esi
	ret	0
??0?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@ABV01@@Z ENDP	; cv::Ptr<cv::FeatureEvaluator>::Ptr<cv::FeatureEvaluator>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ
_TEXT	SEGMENT
??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ PROC	; cv::Ptr<CvHaarClassifierCascade>::~Ptr<CvHaarClassifierCascade>, COMDAT
; _this$ = esi

; 2617 : template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN7@Ptr@5
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN7@Ptr@5
	mov	ecx, esi
	call	DWORD PTR __imp_?delete_obj@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN7@Ptr@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	ret	0
??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ ENDP	; cv::Ptr<CvHaarClassifierCascade>::~Ptr<CvHaarClassifierCascade>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@ABV01@@Z PROC ; cv::Ptr<CvHaarClassifierCascade>::Ptr<CvHaarClassifierCascade>, COMDAT
; _this$ = esi
; __ptr$ = eax

; 2621 :     obj = _ptr.obj;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx

; 2622 :     refcount = _ptr.refcount;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax

; 2623 :     addref();

	test	eax, eax
	je	SHORT $LN6@Ptr@6
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN6@Ptr@6:

; 2624 : }

	mov	eax, esi
	ret	0
??0?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@ABV01@@Z ENDP ; cv::Ptr<CvHaarClassifierCascade>::Ptr<CvHaarClassifierCascade>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Point_@H@cv@@QAE@HH@Z
_TEXT	SEGMENT
??0?$Point_@H@cv@@QAE@HH@Z PROC				; cv::Point_<int>::Point_<int>, COMDAT
; _this$ = eax
; __x$ = ecx
; __y$ = edx

; 1621 : template<typename _Tp> inline Point_<_Tp>::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) {}

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	0
??0?$Point_@H@cv@@QAE@HH@Z ENDP				; cv::Point_<int>::Point_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Point_@H@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Point_@H@cv@@QAE@ABV01@@Z PROC			; cv::Point_<int>::Point_<int>, COMDAT
; _this$ = eax
; _pt$ = ecx

; 1622 : template<typename _Tp> inline Point_<_Tp>::Point_(const Point_& pt) : x(pt.x), y(pt.y) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	ret	0
??0?$Point_@H@cv@@QAE@ABV01@@Z ENDP			; cv::Point_<int>::Point_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Scalar_@N@cv@@QAE@NNNN@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 8
_v1$ = 16						; size = 8
_v2$ = 24						; size = 8
_v3$ = 32						; size = 8
??0?$Scalar_@N@cv@@QAE@NNNN@Z PROC			; cv::Scalar_<double>::Scalar_<double>, COMDAT
; _this$ = eax

; 2019 : { this->val[0] = v0; this->val[1] = v1; this->val[2] = v2; this->val[3] = v3; }

	push	ebp
	mov	ebp, esp
	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR _v0$[ebp]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _v1$[ebp]
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR _v2$[ebp]
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR _v3$[ebp]
	fstp	QWORD PTR [eax+24]
	pop	ebp
	ret	32					; 00000020H
??0?$Scalar_@N@cv@@QAE@NNNN@Z ENDP			; cv::Scalar_<double>::Scalar_<double>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Size_@H@cv@@QAE@XZ
_TEXT	SEGMENT
??0?$Size_@H@cv@@QAE@XZ PROC				; cv::Size_<int>::Size_<int>, COMDAT
; _this$ = eax

; 1858 :     : width(0), height(0) {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$Size_@H@cv@@QAE@XZ ENDP				; cv::Size_<int>::Size_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Size_@H@cv@@QAE@HH@Z
_TEXT	SEGMENT
??0?$Size_@H@cv@@QAE@HH@Z PROC				; cv::Size_<int>::Size_<int>, COMDAT
; _this$ = eax
; __width$ = ecx
; __height$ = edx

; 1860 :     : width(_width), height(_height) {}

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	0
??0?$Size_@H@cv@@QAE@HH@Z ENDP				; cv::Size_<int>::Size_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Size_@H@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Size_@H@cv@@QAE@ABV01@@Z PROC			; cv::Size_<int>::Size_<int>, COMDAT
; _this$ = eax
; _sz$ = ecx

; 1862 :     : width(sz.width), height(sz.height) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	ret	0
??0?$Size_@H@cv@@QAE@ABV01@@Z ENDP			; cv::Size_<int>::Size_<int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 220  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@M@std@@QBEIXZ PROC		; std::allocator<float>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 220  : 		}

	ret	0
?max_size@?$allocator@M@std@@QBEIXZ ENDP		; std::allocator<float>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QBEIXZ PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 220  : 		}

	ret	0
?max_size@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QBEIXZ ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QBEIXZ PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 220  : 		}

	ret	0
?max_size@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QBEIXZ ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QBEIXZ PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 220  : 		}

	ret	0
?max_size@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QBEIXZ ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 220  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 2015 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 1516 : 		size_type _Num = this->_Alval.max_size();
; 1517 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1518 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@I@Z PROC ; std::allocator<cv::Rect_<int> >::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@I@Z ENDP ; std::allocator<cv::Rect_<int> >::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@ABV01@@Z PROC	; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXPAV?$Rect_@H@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXPAV?$Rect_@H@cv@@0@Z PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXPAV?$Rect_@H@cv@@0@Z ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Destroy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@M@std@@QAEXPAMI@Z PROC		; std::allocator<float>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@M@std@@QAEXPAMI@Z ENDP		; std::allocator<float>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ PROC	; std::vector<float,std::allocator<float> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@2:
$LN3@Xlen@2:
	int	3
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ ENDP	; std::vector<float,std::allocator<float> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 885  : 		}

	ret	0
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@3:
$LN3@Xlen@3:
	int	3
?_Xlen@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTreeNode@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTreeNode@Data@CascadeClassifier@cv@@0@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTreeNode@Data@CascadeClassifier@cv@@0@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 885  : 		}

	ret	0
?max_size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@4:
$LN3@Xlen@4:
	int	3
?_Xlen@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTree@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTree@Data@CascadeClassifier@cv@@0@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTree@Data@CascadeClassifier@cv@@0@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 885  : 		}

	ret	0
?max_size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@5:
$LN3@Xlen@5:
	int	3
?_Xlen@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUStage@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUStage@Data@CascadeClassifier@cv@@0@Z PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUStage@Data@CascadeClassifier@cv@@0@Z ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 885  : 		}

	ret	0
?max_size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@6:
$LN3@Xlen@6:
	int	3
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 885  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT

; 2020 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = eax

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN4@Myptr
	mov	eax, DWORD PTR [eax]
$LN4@Myptr:

; 2005 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@XZ PROC		; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

	ret	0
??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@XZ ENDP		; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@V?$allocator@V?$Rect_@H@cv@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@V?$allocator@V?$Rect_@H@cv@@@1@@Z PROC ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@V?$allocator@V?$Rect_@H@cv@@@1@@Z ENDP ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Tidy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@ABV01@@Z PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@M@std@@QAE@ABV01@@Z ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@V?$allocator@M@1@@Z PROC ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@V?$allocator@M@1@@Z ENDP ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ PROC	; std::vector<float,std::allocator<float> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ENDP	; std::vector<float,std::allocator<float> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 880  : 		}

	ret	0
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP	; std::vector<float,std::allocator<float> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocator<cv::CascadeClassifier::Data::DTreeNode>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocator<cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@1@@Z PROC ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@1@@Z ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@3

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@3:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4

; 880  : 		}

	ret	0
?size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocator<cv::CascadeClassifier::Data::DTree>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocator<cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@1@@Z PROC ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@1@@Z ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@4

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@4:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 880  : 		}

	ret	0
?size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocator<cv::CascadeClassifier::Data::Stage>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocator<cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UStage@Data@CascadeClassifier@cv@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UStage@Data@CascadeClassifier@cv@@@1@@Z PROC ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UStage@Data@CascadeClassifier@cv@@@1@@Z ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@5

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@5:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::size, COMDAT
; _this$ = eax

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 880  : 		}

	ret	0
?size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@6

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@6:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 880  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT

; 459  : 		}

	ret	0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = eax

; 455  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = eax

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN4@Myptr@2
	mov	eax, DWORD PTR [eax]
$LN4@Myptr@2:

; 2011 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAEAAV?$Rect_@H@cv@@I@Z
_TEXT	SEGMENT
??A?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAEAAV?$Rect_@H@cv@@I@Z PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::operator[], COMDAT
; _this$ = ecx
; __Pos$ = eax

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 941  : 		}

	ret	0
??A?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAEAAV?$Rect_@H@cv@@I@Z ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4

; 880  : 		}

	ret	0
?size@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >, COMDAT
; _this$ = eax

; 507  : 		{	// construct empty vector

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 508  : 		}

	ret	0
??0?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@2
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@2:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@3
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@3:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@4
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@4:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@5
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@5:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@6
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@6:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = eax

; 1511 : 		return (this->_Mysize);

	mov	eax, DWORD PTR [eax+16]

; 1512 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?getFoundSign@SignDetector@CVDetector@@SAHXZ	; CVDetector::SignDetector::getFoundSign
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
;	COMDAT ?getFoundSign@SignDetector@CVDetector@@SAHXZ
_TEXT	SEGMENT
?getFoundSign@SignDetector@CVDetector@@SAHXZ PROC	; CVDetector::SignDetector::getFoundSign, COMDAT

; 139  : 			return signID;

	fld	QWORD PTR _signID
	jmp	__ftol2_sse
?getFoundSign@SignDetector@CVDetector@@SAHXZ ENDP	; CVDetector::SignDetector::getFoundSign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1Data@CascadeClassifier@cv@@QAE@XZ
_TEXT	SEGMENT
??1Data@CascadeClassifier@cv@@QAE@XZ PROC		; cv::CascadeClassifier::Data::~Data, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+88]
	push	ebx
	mov	ebx, DWORD PTR __imp_??3@YAXPAX@Z
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN15@Data
	push	eax
	call	ebx
	add	esp, 4
$LN15@Data:
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	mov	DWORD PTR [esi+96], edi
	mov	eax, DWORD PTR [esi+72]
	cmp	eax, edi
	je	SHORT $LN26@Data
	push	eax
	call	ebx
	add	esp, 4
$LN26@Data:
	mov	DWORD PTR [esi+72], edi
	mov	DWORD PTR [esi+76], edi
	mov	DWORD PTR [esi+80], edi
	mov	eax, DWORD PTR [esi+56]
	cmp	eax, edi
	je	SHORT $LN37@Data
	push	eax
	call	ebx
	add	esp, 4
$LN37@Data:
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	eax, DWORD PTR [esi+40]
	cmp	eax, edi
	je	SHORT $LN48@Data
	push	eax
	call	ebx
	add	esp, 4
$LN48@Data:
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	je	SHORT $LN59@Data
	push	eax
	call	ebx
	add	esp, 4
$LN59@Data:
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+32], edi
	pop	edi
	pop	ebx
	ret	0
??1Data@CascadeClassifier@cv@@QAE@XZ ENDP		; cv::CascadeClassifier::Data::~Data
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCascadeClassifier@cv@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCascadeClassifier@cv@@UAEPAXI@Z PROC		; cv::CascadeClassifier::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	esi
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GCascadeClassifier@cv@@UAEPAXI@Z ENDP		; cv::CascadeClassifier::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
_TEXT	ENDS
;	COMDAT ??AMStep@Mat@cv@@QAEAAIH@Z
_TEXT	SEGMENT
??AMStep@Mat@cv@@QAEAAIH@Z PROC				; cv::Mat::MStep::operator[], COMDAT
; _this$ = eax
; _i$ = edx

; 741  : inline size_t& Mat::MStep::operator[](int i) { return p[i]; }

	mov	ecx, DWORD PTR [eax]
	lea	eax, DWORD PTR [ecx+edx*4]
	ret	0
??AMStep@Mat@cv@@QAEAAIH@Z ENDP				; cv::Mat::MStep::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??AMStep@Mat@cv@@QBEABIH@Z
_TEXT	SEGMENT
??AMStep@Mat@cv@@QBEABIH@Z PROC				; cv::Mat::MStep::operator[], COMDAT
; _this$ = eax
; _i$ = edx

; 740  : inline const size_t& Mat::MStep::operator[](int i) const { return p[i]; }

	mov	ecx, DWORD PTR [eax]
	lea	eax, DWORD PTR [ecx+edx*4]
	ret	0
??AMStep@Mat@cv@@QBEABIH@Z ENDP				; cv::Mat::MStep::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0MStep@Mat@cv@@QAE@XZ
_TEXT	SEGMENT
??0MStep@Mat@cv@@QAE@XZ PROC				; cv::Mat::MStep::MStep, COMDAT
; _this$ = eax

; 738  : inline Mat::MStep::MStep() { p = buf; p[0] = p[1] = 0; }

	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [ecx+4], 0
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0
	ret	0
??0MStep@Mat@cv@@QAE@XZ ENDP				; cv::Mat::MStep::MStep
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0MSize@Mat@cv@@QAE@PAH@Z
_TEXT	SEGMENT
??0MSize@Mat@cv@@QAE@PAH@Z PROC				; cv::Mat::MSize::MSize, COMDAT
; _this$ = eax
; __p$ = ecx

; 709  : inline Mat::MSize::MSize(int* _p) : p(_p) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0MSize@Mat@cv@@QAE@PAH@Z ENDP				; cv::Mat::MSize::MSize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?type@Mat@cv@@QBEHXZ
_TEXT	SEGMENT
?type@Mat@cv@@QBEHXZ PROC				; cv::Mat::type, COMDAT
; _this$ = eax

; 400  : inline int Mat::type() const { return CV_MAT_TYPE(flags); }

	mov	eax, DWORD PTR [eax]
	and	eax, 4095				; 00000fffH
	ret	0
?type@Mat@cv@@QBEHXZ ENDP				; cv::Mat::type
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?release@Mat@cv@@QAEXXZ
_TEXT	SEGMENT
?release@Mat@cv@@QAEXXZ PROC				; cv::Mat::release, COMDAT
; _this$ = esi

; 366  :     if( refcount && CV_XADD(refcount, -1) == 1 )

	mov	eax, DWORD PTR [esi+20]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN4@release@4
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN4@release@4

; 367  :         deallocate();

	mov	ecx, esi
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN4@release@4:

; 368  :     data = datastart = dataend = datalimit = 0;
; 369  :     for(int i = 0; i < dims; i++)

	xor	eax, eax
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+16], edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN9@release@4
$LL3@release@4:

; 370  :         size.p[i] = 0;

	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [ecx+eax*4], edi
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL3@release@4
$LN9@release@4:

; 371  :     refcount = 0;

	mov	DWORD PTR [esi+20], edi
	pop	edi

; 372  : }

	ret	0
?release@Mat@cv@@QAEXXZ ENDP				; cv::Mat::release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?create@Mat@cv@@QAEXHHH@Z
_TEXT	SEGMENT
_sz$ = -8						; size = 8
?create@Mat@cv@@QAEXHHH@Z PROC				; cv::Mat::create, COMDAT
; _this$ = ecx
; __rows$ = edx
; __cols$ = eax

; 348  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 349  :     _type &= TYPE_MASK;
; 350  :     if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && data )

	cmp	DWORD PTR [ecx+4], 2
	jg	SHORT $LN1@create
	cmp	DWORD PTR [ecx+8], edx
	jne	SHORT $LN1@create
	cmp	DWORD PTR [ecx+12], eax
	jne	SHORT $LN1@create
	push	esi
	mov	esi, DWORD PTR [ecx]
	and	esi, 4095				; 00000fffH
	cmp	esi, 24					; 00000018H
	pop	esi
	jne	SHORT $LN1@create
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN2@create
$LN1@create:

; 351  :         return;
; 352  :     int sz[] = {_rows, _cols};

	mov	DWORD PTR _sz$[ebp+4], eax

; 353  :     create(2, sz, _type);

	push	24					; 00000018H
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	2
	mov	DWORD PTR _sz$[ebp], edx
	call	DWORD PTR __imp_?create@Mat@cv@@QAEXHPBHH@Z
$LN2@create:

; 354  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create@Mat@cv@@QAEXHHH@Z ENDP				; cv::Mat::create
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1Mat@cv@@QAE@XZ
_TEXT	SEGMENT
??1Mat@cv@@QAE@XZ PROC					; cv::Mat::~Mat, COMDAT
; _this$ = eax

; 275  : {

	push	esi
	mov	esi, eax

; 276  :     release();

	mov	eax, DWORD PTR [esi+20]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN7@Mat
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN7@Mat
	mov	ecx, esi
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN7@Mat:
	xor	eax, eax
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+16], edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN4@Mat
	npad	7
$LL6@Mat:
	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [ecx+eax*4], edi
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL6@Mat
$LN4@Mat:

; 277  :     if( step.p != step.buf )

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+20], edi
	add	esi, 48					; 00000030H
	pop	edi
	cmp	eax, esi
	pop	esi
	je	SHORT $LN1@Mat

; 278  :         fastFree(step.p);

	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	pop	ecx
$LN1@Mat:

; 279  : }

	ret	0
??1Mat@cv@@QAE@XZ ENDP					; cv::Mat::~Mat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0Mat@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0Mat@cv@@QAE@ABV01@@Z PROC				; cv::Mat::Mat, COMDAT
; _this$ = esi
; _m$ = edi

; 115  : {

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], ecx
	mov	edx, DWORD PTR [edi+16]
	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], edx
	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], ecx
	mov	edx, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], edx
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], edx
	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], ecx
	mov	DWORD PTR [esi+40], eax
	lea	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [eax+4], 0
	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [edx], 0

; 116  :     if( refcount )

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN3@Mat@2

; 117  :         CV_XADD(refcount, 1);

	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN3@Mat@2:

; 118  :     if( m.dims <= 2 )

	cmp	DWORD PTR [edi+4], 2
	jg	SHORT $LN2@Mat@2

; 119  :     {
; 120  :         step[0] = m.step[0]; step[1] = m.step[1];

	mov	eax, DWORD PTR [edi+44]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [edi+44]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [ecx+4], edx

; 126  :     }
; 127  : }

	mov	eax, esi
	ret	0
$LN2@Mat@2:

; 121  :     }
; 122  :     else
; 123  :     {
; 124  :         dims = 0;
; 125  :         copySize(m);

	push	edi
	mov	ecx, esi
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp_?copySize@Mat@cv@@QAEXABV12@@Z

; 126  :     }
; 127  : }

	mov	eax, esi
	ret	0
??0Mat@cv@@QAE@ABV01@@Z ENDP				; cv::Mat::Mat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?initEmpty@Mat@cv@@IAEXXZ
_TEXT	SEGMENT
?initEmpty@Mat@cv@@IAEXXZ PROC				; cv::Mat::initEmpty, COMDAT
; _this$ = eax

; 60   :     flags = MAGIC_VAL;
; 61   :     dims = rows = cols = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], 1124007936		; 42ff0000H
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+4], ecx

; 62   :     data = datastart = dataend = datalimit = 0;

	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+16], ecx

; 63   :     refcount = 0;

	mov	DWORD PTR [eax+20], ecx

; 64   :     allocator = 0;

	mov	DWORD PTR [eax+36], ecx

; 65   : }

	ret	0
?initEmpty@Mat@cv@@IAEXXZ ENDP				; cv::Mat::initEmpty
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 49   : 		}

	ret	0
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT
; __Left$ = edx
; __Right$ = eax

; 527  : 		_Left = _Right;

	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 528  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT
; __First1$ = edx
; __First2$ = ecx
; __Count$ = eax

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 518  : 		}

	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT
; __First1$ = edx
; __First2$ = ecx
; __Count$ = eax

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 498  : 		}

	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = eax

; 491  : 		return (_CSTD strlen(_First));

	lea	edx, DWORD PTR [eax+1]
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 492  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Where$ = eax

; 57   : 	return (_Where);
; 58   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = -4						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = esi

; 345  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Message$[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

	mov	eax, esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@MABM@std@@YAXPAMABM@Z
_TEXT	SEGMENT
??$_Construct@MABM@std@@YAXPAMABM@Z PROC		; std::_Construct<float,float const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
$LN3@Construct:

; 49   : 	}

	ret	0
??$_Construct@MABM@std@@YAXPAMABM@Z ENDP		; std::_Construct<float,float const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$_Construct@UDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::_Construct<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN3@Construct@2:

; 49   : 	}

	ret	0
??$_Construct@UDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::_Construct<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UDTree@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$_Construct@UDTree@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::_Construct<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@3:

; 49   : 	}

	ret	0
??$_Construct@UDTree@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::_Construct<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UStage@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$_Construct@UStage@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::_Construct<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Construct@4:

; 49   : 	}

	ret	0
??$_Construct@UStage@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::_Construct<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@HABH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
??$_Construct@HABH@std@@YAXPAHABH@Z PROC		; std::_Construct<int,int const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@5:

; 49   : 	}

	ret	0
??$_Construct@HABH@std@@YAXPAHABH@Z ENDP		; std::_Construct<int,int const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@M@std@@QAEXPAMABM@Z
_TEXT	SEGMENT
?construct@?$allocator@M@std@@QAEXPAMABM@Z PROC		; std::allocator<float>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
$LN5@construct:

; 198  : 		}

	ret	0
?construct@?$allocator@M@std@@QAEXPAMABM@Z ENDP		; std::allocator<float>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@Z
_TEXT	SEGMENT
?construct@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN5@construct@2:

; 198  : 		}

	ret	0
?construct@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@ABU3456@@Z
_TEXT	SEGMENT
?construct@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@ABU3456@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@3:

; 198  : 		}

	ret	0
?construct@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@ABU3456@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@ABU3456@@Z
_TEXT	SEGMENT
?construct@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@ABU3456@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN5@construct@4:

; 198  : 		}

	ret	0
?construct@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@ABU3456@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@5:

; 198  : 		}

	ret	0
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@M@std@@MABM@std@@YAXAAV?$allocator@M@0@PAMABM@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@M@std@@MABM@std@@YAXAAV?$allocator@M@0@PAMABM@Z PROC ; std::_Cons_val<std::allocator<float>,float,float const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
$LN9@Cons_val:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@M@std@@MABM@std@@YAXAAV?$allocator@M@0@PAMABM@Z ENDP ; std::_Cons_val<std::allocator<float>,float,float const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@ABU2345@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@ABU2345@@Z PROC ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN9@Cons_val@2:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@ABU2345@@Z ENDP ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@ABU2345@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@ABU2345@@Z PROC ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val@3
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN9@Cons_val@3:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@ABU2345@@Z ENDP ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@ABU2345@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@ABU2345@@Z PROC ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN9@Cons_val@4:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@ABU2345@@Z ENDP ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN9@Cons_val@5:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int const &>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	npad	3
$LL14@Uninit_cop:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
$LN32@Uninit_cop:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop
$LN4@Uninit_cop:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
	npad	2
$LL14@Uninit_cop@2:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
$LN32@Uninit_cop@2:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
	npad	2
$LL14@Uninit_cop@3:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN32@Uninit_cop@3:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
	npad	2
$LL14@Uninit_cop@4:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
$LN32@Uninit_cop@4:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@5
	push	esi
	npad	2
$LL14@Uninit_cop@5:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop@5
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN32@Uninit_cop@5:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@5
	pop	esi
$LN4@Uninit_cop@5:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@@Z
_TEXT	SEGMENT
__Cat$140842 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$140842[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
__Cat$140849 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$140849[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
__Cat$140856 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$140856[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
__Cat$140863 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$140863[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__Cat$140870 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$140870[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
_TEXT	ENDS
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T140874 = -16						; size = 12
$T140882 = -4						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN1@Allocate
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	eax, DWORD PTR $T140882[ebp]
	push	eax
	lea	ecx, DWORD PTR $T140874[ebp]
	mov	DWORD PTR $T140882[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T140874[ebp]
	push	ecx
	mov	DWORD PTR $T140874[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate:
$LN7@Allocate:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT
$T140887 = -16						; size = 12
$T140895 = -4						; size = 4
??$_Allocate@M@std@@YAPAMIPAM@Z PROC			; std::_Allocate<float>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 1073741823				; 3fffffffH
	ja	SHORT $LN1@Allocate@2
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	ecx, DWORD PTR $T140895[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T140887[ebp]
	mov	DWORD PTR $T140895[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T140887[ebp]
	push	edx
	mov	DWORD PTR $T140887[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@2:
$LN7@Allocate@2:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@2:
??$_Allocate@M@std@@YAPAMIPAM@Z ENDP			; std::_Allocate<float>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@IPAU1234@@Z
_TEXT	SEGMENT
$T140900 = -16						; size = 12
$T140908 = -4						; size = 4
??$_Allocate@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@IPAU1234@@Z PROC ; std::_Allocate<cv::CascadeClassifier::Data::DTreeNode>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 268435455				; 0fffffffH
	ja	SHORT $LN1@Allocate@3
	shl	eax, 4
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	eax, DWORD PTR $T140908[ebp]
	push	eax
	lea	ecx, DWORD PTR $T140900[ebp]
	mov	DWORD PTR $T140908[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T140900[ebp]
	push	ecx
	mov	DWORD PTR $T140900[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@3:
$LN7@Allocate@3:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@3:
??$_Allocate@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@IPAU1234@@Z ENDP ; std::_Allocate<cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UDTree@Data@CascadeClassifier@cv@@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@IPAU1234@@Z
_TEXT	SEGMENT
$T140913 = -16						; size = 12
$T140921 = -4						; size = 4
??$_Allocate@UDTree@Data@CascadeClassifier@cv@@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@IPAU1234@@Z PROC ; std::_Allocate<cv::CascadeClassifier::Data::DTree>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 1073741823				; 3fffffffH
	ja	SHORT $LN1@Allocate@4
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	ecx, DWORD PTR $T140921[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T140913[ebp]
	mov	DWORD PTR $T140921[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T140913[ebp]
	push	edx
	mov	DWORD PTR $T140913[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@4:
$LN7@Allocate@4:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@4:
??$_Allocate@UDTree@Data@CascadeClassifier@cv@@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@IPAU1234@@Z ENDP ; std::_Allocate<cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UStage@Data@CascadeClassifier@cv@@@std@@YAPAUStage@Data@CascadeClassifier@cv@@IPAU1234@@Z
_TEXT	SEGMENT
$T140926 = -16						; size = 12
$T140934 = -4						; size = 4
??$_Allocate@UStage@Data@CascadeClassifier@cv@@@std@@YAPAUStage@Data@CascadeClassifier@cv@@IPAU1234@@Z PROC ; std::_Allocate<cv::CascadeClassifier::Data::Stage>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 357913941				; 15555555H
	ja	SHORT $LN1@Allocate@5
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@5
$LN1@Allocate@5:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	ecx, DWORD PTR $T140934[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T140926[ebp]
	mov	DWORD PTR $T140934[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T140926[ebp]
	push	edx
	mov	DWORD PTR $T140926[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@5:
$LN7@Allocate@5:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@5:
??$_Allocate@UStage@Data@CascadeClassifier@cv@@@std@@YAPAUStage@Data@CascadeClassifier@cv@@IPAU1234@@Z ENDP ; std::_Allocate<cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T140939 = -16						; size = 12
$T140947 = -4						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 1073741823				; 3fffffffH
	ja	SHORT $LN1@Allocate@6
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@6
$LN1@Allocate@6:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	ecx, DWORD PTR $T140947[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T140939[ebp]
	mov	DWORD PTR $T140947[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T140939[ebp]
	push	edx
	mov	DWORD PTR $T140939[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@6:
$LN7@Allocate@6:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@6:
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IAEPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@1@0PAM@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$140961 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IAEPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@1@0PAM@Z PROC ; std::vector<float,std::allocator<float> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$140961[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IAEPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@1@0PAM@Z ENDP ; std::vector<float,std::allocator<float> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$140977 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$140977[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$140993 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$140993[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$141009 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$141009[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@1@0PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$141025 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@1@0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$141025[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@1@0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T141039 = -16						; size = 12
$T141037 = -4						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate
	cmp	ecx, -1
	ja	SHORT $LN3@allocate
	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate
$LN3@allocate:
	lea	eax, DWORD PTR $T141037[ebp]
	push	eax
	lea	ecx, DWORD PTR $T141039[ebp]
	mov	DWORD PTR $T141037[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T141039[ebp]
	push	ecx
	mov	DWORD PTR $T141039[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = eax
; __Ptr$ = esi

; 1973 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

	test	esi, esi
	je	SHORT $LN2@Inside
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN8@Inside
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	ecx, eax
$LN9@Inside:
	cmp	esi, ecx
	jb	SHORT $LN2@Inside
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN12@Inside
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN13@Inside
$LN12@Inside:
	mov	ecx, eax
$LN13@Inside:
	mov	eax, DWORD PTR [eax+16]
	add	eax, ecx
	cmp	eax, esi
	jbe	SHORT $LN2@Inside

; 1975 : 		else
; 1976 : 			return (true);

	mov	al, 1

; 1977 : 		}

	ret	0
$LN2@Inside:

; 1974 : 			return (false);	// don't ask

	xor	al, al

; 1977 : 		}

	ret	0
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAE@PAMPBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAE@PAMPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAE@PAMPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTreeNode@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTreeNode@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTreeNode@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTree@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTree@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTree@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUStage@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUStage@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUStage@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT
$T141115 = -16						; size = 12
$T141107 = -4						; size = 4
?allocate@?$allocator@M@std@@QAEPAMI@Z PROC		; std::allocator<float>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@2
	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN3@allocate@2
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@2
$LN3@allocate@2:
	lea	ecx, DWORD PTR $T141107[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T141115[ebp]
	mov	DWORD PTR $T141107[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T141115[ebp]
	push	edx
	mov	DWORD PTR $T141115[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@2:
?allocate@?$allocator@M@std@@QAEPAMI@Z ENDP		; std::allocator<float>::allocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
$T141138 = -16						; size = 12
$T141130 = -4						; size = 4
?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@3
	cmp	ecx, 268435455				; 0fffffffH
	ja	SHORT $LN3@allocate@3
	shl	ecx, 4
	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@3
$LN3@allocate@3:
	lea	eax, DWORD PTR $T141130[ebp]
	push	eax
	lea	ecx, DWORD PTR $T141138[ebp]
	mov	DWORD PTR $T141130[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T141138[ebp]
	push	ecx
	mov	DWORD PTR $T141138[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@3:
$LN1@allocate@3:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@3:
?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
$T141161 = -16						; size = 12
$T141153 = -4						; size = 4
?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@4
	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN3@allocate@4
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@4
$LN3@allocate@4:
	lea	ecx, DWORD PTR $T141153[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T141161[ebp]
	mov	DWORD PTR $T141153[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T141161[ebp]
	push	edx
	mov	DWORD PTR $T141161[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@4:
$LN1@allocate@4:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@4:
?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
$T141184 = -16						; size = 12
$T141176 = -4						; size = 4
?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@5
	cmp	ecx, 357913941				; 15555555H
	ja	SHORT $LN3@allocate@5
	lea	eax, DWORD PTR [ecx+ecx*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@5
$LN3@allocate@5:
	lea	ecx, DWORD PTR $T141176[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T141184[ebp]
	mov	DWORD PTR $T141176[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T141184[ebp]
	push	edx
	mov	DWORD PTR $T141184[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@5:
$LN1@allocate@5:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@5:
?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
$T141203 = -16						; size = 12
$T141199 = -4						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@6
	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN3@allocate@6
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@6
$LN3@allocate@6:
	lea	ecx, DWORD PTR $T141199[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T141203[ebp]
	mov	DWORD PTR $T141199[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T141203[ebp]
	push	edx
	mov	DWORD PTR $T141203[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@6:
$LN1@allocate@6:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@6:
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = eax
; __Newsize$ = ecx

; 1953 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	mov	DWORD PTR [eax+16], ecx
	jb	SHORT $LN5@Eos
	mov	eax, DWORD PTR [eax]
$LN5@Eos:
	mov	BYTE PTR [eax+ecx], 0

; 1954 : 		}

	ret	0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = esi
; __Off$ = ecx
; __Count$ = eax

; 1108 : 		{	// erase elements [_Off, _Off + _Count)

	push	edi
	mov	edi, eax

; 1109 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ecx
	jae	SHORT $LN3@erase

; 1110 : 			_Xran();	// _Off off end

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN28@erase:
$LN3@erase:

; 1111 : 		if (this->_Mysize - _Off < _Count)

	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN2@erase

; 1112 : 			_Count = this->_Mysize - _Off;	// trim _Count

	mov	edi, eax
$LN2@erase:

; 1113 : 		if (0 < _Count)

	test	edi, edi
	je	SHORT $LN25@erase

; 1114 : 			{	// move elements down
; 1115 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1116 : 				this->_Mysize - _Off - _Count);

	mov	edx, DWORD PTR [esi+20]
	push	ebx
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN11@erase
	mov	ebx, DWORD PTR [esi]
	jmp	SHORT $LN12@erase
$LN11@erase:
	mov	ebx, esi
$LN12@erase:
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN15@erase
	mov	edx, DWORD PTR [esi]
	jmp	SHORT $LN16@erase
$LN15@erase:
	mov	edx, esi
$LN16@erase:
	sub	eax, edi
	add	ebx, ecx
	push	eax
	add	ebx, edi
	add	edx, ecx
	push	ebx
	push	edx
	call	DWORD PTR __imp__memmove

; 1117 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	eax, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	sub	eax, edi

; 1118 : 			_Eos(_Newsize);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], eax
	pop	ebx
	jb	SHORT $LN23@erase
	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR [ecx+eax], 0

; 1119 : 			}
; 1120 : 		return (*this);

	mov	eax, esi
	pop	edi

; 1121 : 		}

	ret	0

; 1118 : 			_Eos(_Newsize);

$LN23@erase:
	mov	ecx, esi
	mov	BYTE PTR [ecx+eax], 0
$LN25@erase:

; 1119 : 			}
; 1120 : 		return (*this);

	mov	eax, esi
	pop	edi

; 1121 : 		}

	ret	0
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z PROC	; std::vector<float,std::allocator<float> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy

; 1256 : 			return (false);

	xor	al, al

; 1266 : 		}

	ret	0
$LN4@Buy:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy:
$LN2@Buy:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@M@std@@QAEPAMI@Z	; std::allocator<float>::allocate
	mov	DWORD PTR [esi], eax

; 1262 : 			this->_Mylast = this->_Myfirst;

	mov	DWORD PTR [esi+4], eax

; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1

; 1266 : 		}

	ret	0
$LN16@Buy:
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ENDP	; std::vector<float,std::allocator<float> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = eax

; 1250 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, eax

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [edi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [edi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [edi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	esi, eax
	jne	SHORT $LN4@Buy@2

; 1256 : 			return (false);

	xor	al, al
	pop	esi

; 1266 : 		}

	ret	0
$LN4@Buy@2:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	esi, 268435455				; 0fffffffH
	jbe	SHORT $LN2@Buy@2

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy@2:
$LN2@Buy@2:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, esi
	call	?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate

; 1262 : 			this->_Mylast = this->_Myfirst;
; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	shl	esi, 4
	add	esi, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], esi

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1
	pop	esi

; 1266 : 		}

	ret	0
$LN16@Buy@2:
?_Buy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@3

; 1256 : 			return (false);

	xor	al, al

; 1266 : 		}

	ret	0
$LN4@Buy@3:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@3

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy@3:
$LN2@Buy@3:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate
	mov	DWORD PTR [esi], eax

; 1262 : 			this->_Mylast = this->_Myfirst;

	mov	DWORD PTR [esi+4], eax

; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1

; 1266 : 		}

	ret	0
$LN16@Buy@3:
?_Buy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@4

; 1256 : 			return (false);

	xor	al, al

; 1266 : 		}

	ret	0
$LN4@Buy@4:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy@4

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy@4:
$LN2@Buy@4:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate

; 1262 : 			this->_Mylast = this->_Myfirst;
; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edx

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1

; 1266 : 		}

	ret	0
$LN16@Buy@4:
?_Buy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@5

; 1256 : 			return (false);

	xor	al, al

; 1266 : 		}

	ret	0
$LN4@Buy@5:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@5

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy@5:
$LN2@Buy@5:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	DWORD PTR [esi], eax

; 1262 : 			this->_Mylast = this->_Myfirst;

	mov	DWORD PTR [esi+4], eax

; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1

; 1266 : 		}

	ret	0
$LN16@Buy@5:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = esi
; __Newsize$ = edi

; 1987 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 1988 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	je	SHORT $LN9@Tidy@7

; 1989 : 			;
; 1990 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN9@Tidy@7

; 1991 : 			{	// copy any leftovers to small buffer and deallocate
; 1992 : 			_Elem *_Ptr = this->_Bx._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 1993 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN7@Tidy@7

; 1994 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@Tidy@7:

; 1995 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

	push	ebx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
	pop	ebx
$LN9@Tidy@7:

; 1996 : 			}
; 1997 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1998 : 		_Eos(_Newsize);

	mov	DWORD PTR [esi+16], edi
	mov	BYTE PTR [edi+esi], 0

; 1999 : 		}

	pop	ebp
	ret	4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$141669 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+4]
	sub	edi, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	sar	edi, 2
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@7
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN18@vector@7
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@7:
$LN18@vector@7:
	mov	ecx, edi
	call	?allocate@?$allocator@M@std@@QAEPAMI@Z	; std::allocator<float>::allocate

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$141669[ebp]
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax
$LN7@vector@7:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@7:
$LN54@vector@7:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$141805 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	edi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, DWORD PTR [ebx]
	mov	DWORD PTR [edi], eax
	sar	esi, 4
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	cmp	esi, eax
	je	SHORT $LN7@vector@8
	cmp	esi, 268435455				; 0fffffffH
	jbe	SHORT $LN18@vector@8
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@8:
$LN18@vector@8:
	mov	ecx, esi
	call	?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$141805[ebp]
	shl	esi, 4
	add	esi, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], esi
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+4], eax
$LN7@vector@8:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@8:
$LN54@vector@8:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$141940 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+4]
	sub	edi, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	sar	edi, 2
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@9
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN18@vector@9
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@9:
$LN18@vector@9:
	mov	ecx, edi
	call	?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$141940[ebp]
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax
$LN7@vector@9:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@9:
$LN54@vector@9:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$142075 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	edi, edx
	mov	eax, 0
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $LN7@vector@10
	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN18@vector@10
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@10:
$LN18@vector@10:
	mov	ecx, edi
	call	?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$142075[ebp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax
$LN7@vector@10:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@10:
$LN54@vector@10:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$142211 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+4]
	sub	edi, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	sar	edi, 2
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@11
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN18@vector@11
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@11:
$LN18@vector@11:
	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$142211[ebp]
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax
$LN7@vector@11:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@11:
$LN54@vector@11:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = esi

; 753  : 		_Tidy(true);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN11@basic_stri
	mov	eax, DWORD PTR [esi]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN11@basic_stri:
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0

; 754  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = eax

; 551  : 		_Tidy();

	mov	DWORD PTR [eax+20], 15			; 0000000fH
	mov	DWORD PTR [eax+16], 0
	mov	BYTE PTR [eax], 0

; 552  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$3
__ehfuncinfo$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z PROC	; cv::CascadeClassifier::Data::Data, COMDAT
; ___that$ = edi
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edi]
	mov	BYTE PTR [esi], al
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	lea	eax, DWORD PTR [esi+24]
	lea	ecx, DWORD PTR [edi+24]
	push	eax
	mov	DWORD PTR [esi+20], edx
	call	??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
	lea	edx, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [edi+40]
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
	lea	eax, DWORD PTR [esi+56]
	lea	ecx, DWORD PTR [edi+56]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
	lea	edx, DWORD PTR [esi+72]
	lea	ecx, DWORD PTR [edi+72]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	lea	eax, DWORD PTR [esi+88]
	lea	ecx, DWORD PTR [edi+88]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$0:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 24					; 00000018H
	jmp	??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$1:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 40					; 00000028H
	jmp	??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$2:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 56					; 00000038H
	jmp	??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$3:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 72					; 00000048H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
__ehhandler$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z ENDP	; cv::CascadeClassifier::Data::Data
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CascadeClassifier@cv@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$2
__ehfuncinfo$??0CascadeClassifier@cv@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CascadeClassifier@cv@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0CascadeClassifier@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0CascadeClassifier@cv@@QAE@ABV01@@Z PROC		; cv::CascadeClassifier::CascadeClassifier, COMDAT
; ___that$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CascadeClassifier@cv@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [ebx+4]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7CascadeClassifier@cv@@6B@
	call	??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [ebx+108]
	mov	edi, DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	mov	DWORD PTR [esi+108], ecx
	mov	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [esi+112], eax
	test	eax, eax
	je	SHORT $LN9@CascadeCla
	push	1
	push	eax
	call	edi
	add	esp, 8
$LN9@CascadeCla:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR [ebx+116]
	mov	DWORD PTR [esi+116], edx
	mov	eax, DWORD PTR [ebx+120]
	mov	DWORD PTR [esi+120], eax
	test	eax, eax
	je	SHORT $LN14@CascadeCla
	push	1
	push	eax
	call	edi
	add	esp, 8
$LN14@CascadeCla:
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR [ebx+124]
	mov	DWORD PTR [esi+124], eax
	mov	ebx, DWORD PTR [ebx+128]
	mov	DWORD PTR [esi+128], ebx
	test	ebx, ebx
	je	SHORT $LN22@CascadeCla
	push	1
	push	ebx
	call	edi
	add	esp, 8
$LN22@CascadeCla:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$0:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 4
	jmp	??1Data@CascadeClassifier@cv@@QAE@XZ
__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$1:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 108				; 0000006cH
	jmp	??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ ; cv::Ptr<cv::FeatureEvaluator>::~Ptr<cv::FeatureEvaluator>
__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$2:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 116				; 00000074H
	jmp	??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ ; cv::Ptr<CvHaarClassifierCascade>::~Ptr<CvHaarClassifierCascade>
__ehhandler$??0CascadeClassifier@cv@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CascadeClassifier@cv@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CascadeClassifier@cv@@QAE@ABV01@@Z ENDP		; cv::CascadeClassifier::CascadeClassifier
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
;	COMDAT ??0Mat@cv@@QAE@XZ
_TEXT	SEGMENT
??0Mat@cv@@QAE@XZ PROC					; cv::Mat::Mat, COMDAT
; _this$ = eax

; 68   : {

	xor	ecx, ecx
	push	esi
	lea	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+40], edx
	lea	esi, DWORD PTR [eax+48]
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [esi+4], ecx
	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [esi], ecx

; 69   :     initEmpty();

	mov	DWORD PTR [eax], 1124007936		; 42ff0000H
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+36], ecx
	pop	esi

; 70   : }

	ret	0
??0Mat@cv@@QAE@XZ ENDP					; cv::Mat::Mat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
$T142533 = -36						; size = 12
__Newres$ = -24						; size = 4
$T142517 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Newsize$ = 12						; size = 4
__Oldlen$ = 16						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT

; 1918 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, DWORD PTR _this$[ebp]

; 1919 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	esi, eax
	or	esi, 15					; 0000000fH

; 1920 : 		if (max_size() < _Newres)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN9@Copy

; 1921 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	esi, eax
	jmp	SHORT $LN39@Copy
$LN9@Copy:

; 1922 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	ebx, DWORD PTR [edi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN39@Copy

; 1923 : 			;
; 1924 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, -2					; fffffffeH
	sub	eax, ecx

; 1925 : 			_Newres = this->_Myres
; 1926 : 				+ this->_Myres / 2;	// grow exponentially if possible

	lea	esi, DWORD PTR [ecx+ebx]
	cmp	ebx, eax
	jbe	SHORT $LN39@Copy

; 1927 : 		else
; 1928 : 			_Newres = max_size();	// settle for max_size()

	mov	esi, -2					; fffffffeH
$LN39@Copy:

; 1929 : 
; 1930 : 		_Elem *_Ptr;
; 1931 : 		_TRY_BEGIN

	xor	eax, eax

; 1932 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	cmp	ecx, eax
	jbe	SHORT $LN47@Copy
	cmp	ecx, -1
	ja	SHORT $LN46@Copy
	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	je	SHORT $LN46@Copy
$LN47@Copy:
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN19@Copy
$LN46@Copy:
	lea	ecx, DWORD PTR $T142517[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T142533[ebp]
	mov	DWORD PTR $T142517[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T142533[ebp]
	push	edx
	mov	DWORD PTR $T142533[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN112@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1933 : 		_CATCH_ALL
; 1934 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1935 : 			_TRY_BEGIN
; 1936 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Newres$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1940 : 			_CATCH_END
; 1941 : 		_CATCH_END

	mov	eax, $LN107@Copy
	ret	0
$LN107@Copy:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN19@Copy:

; 1942 : 
; 1943 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	je	SHORT $LN78@Copy

; 1944 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN76@Copy
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN77@Copy
$LN76@Copy:
	mov	eax, edi
$LN77@Copy:
	push	ebx
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN78@Copy:

; 1945 : 		_Tidy(true);

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN88@Copy
	mov	ecx, DWORD PTR [edi]
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN88@Copy:

; 1946 : 		this->_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edi], 0
	mov	DWORD PTR [edi], eax

; 1947 : 		this->_Myres = _Newres;

	mov	DWORD PTR [edi+20], esi

; 1948 : 		_Eos(_Oldlen);

	mov	DWORD PTR [edi+16], ebx
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN102@Copy
	mov	edi, eax
$LN102@Copy:
	mov	BYTE PTR [edi+ebx], 0

; 1949 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1937 : 			_CATCH_ALL
; 1938 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN64@Copy
	mov	edx, DWORD PTR [esi]
	push	edx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN64@Copy:

; 1939 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	push	0
	mov	BYTE PTR [esi], 0
	call	__CxxThrowException@8
$LN113@Copy:
$LN111@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = eax
; __Newsize$ = esi

; 1959 : 		if (max_size() < _Newsize)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN6@Grow

; 1960 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN49@Grow:
$LN6@Grow:

; 1961 : 		if (this->_Myres < _Newsize)

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, esi
	jae	SHORT $LN3@Grow

; 1962 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	esi
	push	eax
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	edx, edx
	cmp	edx, esi
	sbb	eax, eax
	neg	eax

; 1969 : 		}

	ret	0
$LN3@Grow:

; 1963 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 1964 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1965 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 1966 : 		else if (_Newsize == 0)

	test	esi, esi
	jne	SHORT $LN46@Grow

; 1967 : 			_Eos(0);	// new size is zero, just null terminate

	mov	DWORD PTR [eax+16], esi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN44@Grow
	mov	eax, DWORD PTR [eax]
$LN44@Grow:
	mov	BYTE PTR [eax], 0
$LN46@Grow:

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	edx, edx
	cmp	edx, esi
	sbb	eax, eax
	neg	eax

; 1969 : 		}

	ret	0
$LN48@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx
; __Roff$ = ebx
; __Count$ = eax

; 892  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 893  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	push	edi
	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, ebx
	jae	SHORT $LN5@assign

; 894  : 			_Xran();	// _Roff off end

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN83@assign:
$LN5@assign:

; 895  : 		size_type _Num = _Right.size() - _Roff;

	sub	edi, ebx

; 896  : 		if (_Count < _Num)

	cmp	eax, edi
	jae	SHORT $LN4@assign

; 897  : 			_Num = _Count;	// trim _Num to size

	mov	edi, eax
$LN4@assign:

; 898  : 
; 899  : 		if (this == &_Right)

	cmp	esi, ecx
	jne	SHORT $LN3@assign

; 900  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	lea	ecx, DWORD PTR [edi+ebx]
	or	eax, -1
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	eax, ebx
	xor	ecx, ecx
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4
$LN3@assign:

; 901  : 		else if (_Grow(_Num))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN20@assign
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN84@assign:
$LN20@assign:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN19@assign
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	edi
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Right$[ebp]
	test	edi, edi
	je	SHORT $LN78@assign
$LN82@assign:

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	eax, 16					; 00000010H
	cmp	DWORD PTR [ecx+20], eax
	jb	SHORT $LN64@assign
	mov	ecx, DWORD PTR [ecx]
$LN64@assign:
	cmp	DWORD PTR [esi+20], eax
	jb	SHORT $LN68@assign
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN69@assign

; 901  : 		else if (_Grow(_Num))

$LN19@assign:
	test	edi, edi
	jne	SHORT $LN82@assign
	mov	DWORD PTR [esi+16], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN58@assign
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax], 0
	pop	edi

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4

; 901  : 		else if (_Grow(_Num))

$LN58@assign:
	mov	eax, esi
	pop	edi
	mov	BYTE PTR [eax], 0
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$LN68@assign:
	mov	eax, esi
$LN69@assign:
	push	edi
	add	ecx, ebx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 904  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], edi
	jb	SHORT $LN76@assign
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4

; 904  : 			_Eos(_Num);

$LN76@assign:
	mov	eax, esi
	mov	BYTE PTR [eax+edi], 0
$LN78@assign:

; 905  : 			}
; 906  : 		return (*this);

	pop	edi
	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4
$LN80@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	__real@4076800000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff199999999999a
PUBLIC	__$ArrayPad$
PUBLIC	?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z ; CVDetector::detectAndDisplay
;	COMDAT __real@4076800000000000
; File c:\programs & apps\visual studio 10\vc\include\vector
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff199999999999a
CONST	SEGMENT
__real@3ff199999999999a DQ 03ff199999999999ar	; 1.1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$5
__ehfuncinfo$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
xdata$x	ENDS
;	COMDAT ?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z
_TEXT	SEGMENT
$T143008 = -180						; size = 20
$T143005 = -180						; size = 20
_center$126107 = -160					; size = 8
$T143168 = -152						; size = 4
$T143014 = -148						; size = 4
$T143013 = -148						; size = 4
tv1236 = -144						; size = 4
_disableSigns$ = -140					; size = 16
_enableSigns$ = -124					; size = 16
$T143127 = -108						; size = 4
$T143012 = -108						; size = 4
$T143011 = -108						; size = 4
$T143010 = -108						; size = 4
$T143009 = -108						; size = 4
$T126109 = -104						; size = 32
$T143007 = -92						; size = 20
$T143006 = -92						; size = 20
_frame_gray$ = -72					; size = 56
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_enableCascade$ = 8					; size = 132
_disableCascade$ = 140					; size = 132
_frame$ = 272						; size = 56
?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z PROC ; CVDetector::detectAndDisplay, COMDAT

; 70   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp+8], ebx

; 71   : 		std::vector<Rect> enableSigns, disableSigns;

	mov	DWORD PTR _enableSigns$[ebp], ebx
	mov	DWORD PTR _enableSigns$[ebp+4], ebx
	mov	DWORD PTR _enableSigns$[ebp+8], ebx
	mov	DWORD PTR _disableSigns$[ebp], ebx
	mov	DWORD PTR _disableSigns$[ebp+4], ebx
	mov	DWORD PTR _disableSigns$[ebp+8], ebx

; 72   : 		Mat frame_gray;

	lea	eax, DWORD PTR _frame_gray$[ebp+8]
	lea	ecx, DWORD PTR _frame_gray$[ebp+48]
	mov	DWORD PTR _frame_gray$[ebp+40], eax
	mov	DWORD PTR _frame_gray$[ebp+44], ecx
	mov	DWORD PTR _frame_gray$[ebp+52], ebx
	mov	DWORD PTR _frame_gray$[ebp+48], ebx
	mov	DWORD PTR _frame_gray$[ebp], 1124007936	; 42ff0000H
	mov	DWORD PTR _frame_gray$[ebp+12], ebx
	mov	DWORD PTR _frame_gray$[ebp+8], ebx
	mov	DWORD PTR _frame_gray$[ebp+4], ebx
	mov	DWORD PTR _frame_gray$[ebp+32], ebx
	mov	DWORD PTR _frame_gray$[ebp+28], ebx
	mov	DWORD PTR _frame_gray$[ebp+24], ebx
	mov	DWORD PTR _frame_gray$[ebp+16], ebx
	mov	DWORD PTR _frame_gray$[ebp+20], ebx
	mov	DWORD PTR _frame_gray$[ebp+36], ebx

; 73   : 
; 74   : 		cvtColor( frame, frame_gray, CV_BGR2GRAY );

	lea	edx, DWORD PTR _frame_gray$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	esi, DWORD PTR __imp_??0_OutputArray@cv@@QAE@AAVMat@1@@Z
	push	edx
	lea	ecx, DWORD PTR $T143005[ebp]
	call	esi
	mov	edi, DWORD PTR __imp_??0_InputArray@cv@@QAE@ABVMat@1@@Z
	lea	eax, DWORD PTR _frame$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T143006[ebp]
	call	edi
	push	ebx
	push	6
	lea	ecx, DWORD PTR $T143005[ebp]
	push	ecx
	lea	edx, DWORD PTR $T143006[ebp]
	push	edx
	call	DWORD PTR __imp_?cvtColor@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@HH@Z
	add	esp, 16					; 00000010H

; 75   : 		equalizeHist( frame_gray, frame_gray );

	lea	eax, DWORD PTR _frame_gray$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T143007[ebp]
	call	esi
	lea	ecx, DWORD PTR _frame_gray$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T143008[ebp]
	call	edi
	lea	edx, DWORD PTR $T143007[ebp]
	push	edx
	lea	eax, DWORD PTR $T143008[ebp]
	push	eax
	call	DWORD PTR __imp_?equalizeHist@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@@Z

; 76   : 
; 77   : 		//-- Detect signs, load 'em up into appropriate arrays
; 78   : 		enableCascade.detectMultiScale( frame_gray, enableSigns, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(30, 30)  );

	fld	QWORD PTR __real@3ff199999999999a
	mov	eax, esp
	mov	DWORD PTR $T143009[ebp], esp
	sub	esp, 8
	mov	DWORD PTR $T143010[ebp], esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	eax, esp
	push	2
	push	2
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	ecx, DWORD PTR _enableSigns$[ebp]
	mov	edi, 30					; 0000001eH
	push	ecx
	lea	edx, DWORD PTR _frame_gray$[ebp]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	push	edx
	mov	esi, DWORD PTR __imp_?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@NHHV?$Size_@H@2@2@Z
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	call	esi

; 79   : 		disableCascade.detectMultiScale( frame_gray, disableSigns, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(30, 30));

	fld	QWORD PTR __real@3ff199999999999a
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T143011[ebp], esp
	sub	esp, 8
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	eax, esp
	mov	DWORD PTR $T143012[ebp], esp
	push	2
	push	2
	sub	esp, 8
	mov	DWORD PTR [eax], edi
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [eax+4], edi
	lea	eax, DWORD PTR _disableSigns$[ebp]
	push	eax
	lea	ecx, DWORD PTR _frame_gray$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	call	esi

; 80   : 		for( size_t i = 0; i < enableSigns.size(); i++ )

	mov	eax, DWORD PTR _enableSigns$[ebp+4]
	mov	ecx, DWORD PTR _enableSigns$[ebp]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 4
	xor	edi, edi
	test	edx, edx
	je	$LN3@detectAndD

; 70   : 	{

	mov	DWORD PTR tv1236[ebp], ebx
$LL172@detectAndD:
	fld	QWORD PTR __real@3fe0000000000000

; 81   : 		{
; 82   : 			Point center( enableSigns[i].x + enableSigns[i].width*0.5, enableSigns[i].y + enableSigns[i].height*0.5 );

	mov	esi, DWORD PTR tv1236[ebp]
	fld	QWORD PTR __real@406fe00000000000
	add	esi, ecx
	fldz
	fild	DWORD PTR [esi+12]
	fmul	ST(0), ST(3)
	fiadd	DWORD PTR [esi+4]
	call	__ftol2_sse
	fild	DWORD PTR [esi+8]
	mov	DWORD PTR $T143127[ebp], eax
	fmul	ST(0), ST(3)
	fiadd	DWORD PTR [esi]
	call	__ftol2_sse

; 83   : 			ellipse( frame, center, Size( enableSigns[i].width*0.5, enableSigns[i].height*0.5), 0, 0, 360, Scalar( 255, 0, 255 ), 4, 8, 0 );

	fxch	ST(1)
	mov	DWORD PTR _center$126107[ebp], eax
	xor	eax, eax
	push	ebx
	mov	DWORD PTR $T126109[ebp], eax
	mov	DWORD PTR $T126109[ebp+4], eax
	fst	QWORD PTR $T126109[ebp]
	mov	DWORD PTR $T126109[ebp+16], eax
	mov	DWORD PTR $T126109[ebp+20], eax
	fstp	QWORD PTR $T126109[ebp+16]
	push	8
	mov	DWORD PTR $T126109[ebp+8], eax
	mov	DWORD PTR $T126109[ebp+12], eax
	fst	QWORD PTR $T126109[ebp+8]
	push	4
	lea	ecx, DWORD PTR $T126109[ebp]
	mov	DWORD PTR $T126109[ebp+24], eax
	mov	DWORD PTR $T126109[ebp+28], eax
	fst	QWORD PTR $T126109[ebp+24]
	fld	QWORD PTR __real@4076800000000000
	push	ecx
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	fild	DWORD PTR [esi+12]
	fmul	ST(0), ST(1)
	call	__ftol2_sse
	fimul	DWORD PTR [esi+8]
	mov	DWORD PTR $T143168[ebp], eax
	call	__ftol2_sse
	mov	edx, DWORD PTR $T143168[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR $T143013[ebp], esp
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR _center$126107[ebp]
	mov	edx, DWORD PTR $T143127[ebp]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	lea	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR $T143014[ebp], esp
	push	eax
	call	DWORD PTR __imp_?ellipse@cv@@YAXAAVMat@1@V?$Point_@H@1@V?$Size_@H@1@NNNABV?$Scalar_@N@1@HHH@Z
	mov	eax, DWORD PTR _enableSigns$[ebp+4]
	mov	ecx, DWORD PTR _enableSigns$[ebp]
	add	DWORD PTR tv1236[ebp], 16		; 00000010H
	mov	edx, eax
	sub	edx, ecx
	inc	edi
	sar	edx, 4
	add	esp, 60					; 0000003cH
	cmp	edi, edx
	jb	$LL172@detectAndD
$LN3@detectAndD:

; 84   : 		}
; 85   : 
; 86   : 		//-- Show what you got
; 87   : 		//imshow( window_name, frame ); // -----------> comment this for release
; 88   : 
; 89   : 		if (enableSigns.size() > 0)

	sub	eax, ecx
	sar	eax, 4
	test	eax, eax
	je	$LN2@detectAndD

; 90   : 			return 1;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _frame_gray$[ebp+20]
	mov	edi, DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	cmp	eax, ebx
	je	SHORT $LN83@detectAndD
	push	-1
	push	eax
	call	edi
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN83@detectAndD
	lea	ecx, DWORD PTR _frame_gray$[ebp]
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN83@detectAndD:
	xor	eax, eax
	mov	DWORD PTR _frame_gray$[ebp+32], ebx
	mov	DWORD PTR _frame_gray$[ebp+28], ebx
	mov	DWORD PTR _frame_gray$[ebp+24], ebx
	mov	DWORD PTR _frame_gray$[ebp+16], ebx
	cmp	DWORD PTR _frame_gray$[ebp+4], ebx
	jle	SHORT $LN80@detectAndD
$LL82@detectAndD:
	mov	ecx, DWORD PTR _frame_gray$[ebp+40]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	eax
	cmp	eax, DWORD PTR _frame_gray$[ebp+4]
	jl	SHORT $LL82@detectAndD
$LN80@detectAndD:
	mov	eax, DWORD PTR _frame_gray$[ebp+44]
	lea	edx, DWORD PTR _frame_gray$[ebp+48]
	mov	DWORD PTR _frame_gray$[ebp+20], ebx
	cmp	eax, edx
	je	SHORT $LN77@detectAndD
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN77@detectAndD:
	mov	eax, DWORD PTR _disableSigns$[ebp]
	mov	esi, DWORD PTR __imp_??3@YAXPAX@Z
	cmp	eax, ebx
	je	SHORT $LN93@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN93@detectAndD:
	mov	eax, DWORD PTR _enableSigns$[ebp]
	mov	DWORD PTR _disableSigns$[ebp], ebx
	mov	DWORD PTR _disableSigns$[ebp+4], ebx
	mov	DWORD PTR _disableSigns$[ebp+8], ebx
	cmp	eax, ebx
	je	SHORT $LN104@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN104@detectAndD:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _frame$[ebp+20]
	mov	DWORD PTR _enableSigns$[ebp], ebx
	mov	DWORD PTR _enableSigns$[ebp+4], ebx
	mov	DWORD PTR _enableSigns$[ebp+8], ebx
	cmp	eax, ebx
	je	SHORT $LN114@detectAndD
	push	-1
	push	eax
	call	edi
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN114@detectAndD
	lea	ecx, DWORD PTR _frame$[ebp]
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN114@detectAndD:
	xor	eax, eax
	mov	DWORD PTR _frame$[ebp+32], ebx
	mov	DWORD PTR _frame$[ebp+28], ebx
	mov	DWORD PTR _frame$[ebp+24], ebx
	mov	DWORD PTR _frame$[ebp+16], ebx
	cmp	DWORD PTR _frame$[ebp+4], ebx
	jle	SHORT $LN111@detectAndD
$LL113@detectAndD:
	mov	ecx, DWORD PTR _frame$[ebp+40]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	eax
	cmp	eax, DWORD PTR _frame$[ebp+4]
	jl	SHORT $LL113@detectAndD
$LN111@detectAndD:
	mov	eax, DWORD PTR _frame$[ebp+44]
	lea	edx, DWORD PTR _frame$[ebp+48]
	mov	DWORD PTR _frame$[ebp+20], ebx
	cmp	eax, edx
	je	SHORT $LN108@detectAndD
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN108@detectAndD:
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	mov	esi, DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	call	esi
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	esi
	mov	eax, 1
	jmp	$LN6@detectAndD
$LN2@detectAndD:

; 91   : 		if (disableSigns.size() > 0)

	mov	eax, DWORD PTR _disableSigns$[ebp+4]
	sub	eax, DWORD PTR _disableSigns$[ebp]

; 92   : 			return 2;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sar	eax, 4
	test	eax, eax
	lea	eax, DWORD PTR _frame_gray$[ebp]
	je	$LN1@detectAndD
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	eax, DWORD PTR _disableSigns$[ebp]
	mov	esi, DWORD PTR __imp_??3@YAXPAX@Z
	cmp	eax, ebx
	je	SHORT $LN126@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN126@detectAndD:
	mov	eax, DWORD PTR _enableSigns$[ebp]
	mov	DWORD PTR _disableSigns$[ebp], ebx
	mov	DWORD PTR _disableSigns$[ebp+4], ebx
	mov	DWORD PTR _disableSigns$[ebp+8], ebx
	cmp	eax, ebx
	je	SHORT $LN137@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN137@detectAndD:
	lea	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _enableSigns$[ebp], ebx
	mov	DWORD PTR _enableSigns$[ebp+4], ebx
	mov	DWORD PTR _enableSigns$[ebp+8], ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	mov	esi, DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	call	esi
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	esi
	mov	eax, 2
	jmp	SHORT $LN6@detectAndD
$LN1@detectAndD:

; 93   : 		// otherwise
; 94   : 		return 0;

	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	eax, DWORD PTR _disableSigns$[ebp]
	mov	esi, DWORD PTR __imp_??3@YAXPAX@Z
	cmp	eax, ebx
	je	SHORT $LN148@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN148@detectAndD:
	mov	eax, DWORD PTR _enableSigns$[ebp]
	mov	DWORD PTR _disableSigns$[ebp], ebx
	mov	DWORD PTR _disableSigns$[ebp+4], ebx
	mov	DWORD PTR _disableSigns$[ebp+8], ebx
	cmp	eax, ebx
	je	SHORT $LN159@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN159@detectAndD:
	lea	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _enableSigns$[ebp], ebx
	mov	DWORD PTR _enableSigns$[ebp+4], ebx
	mov	DWORD PTR _enableSigns$[ebp+8], ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	mov	esi, DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	call	esi
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	esi
	xor	eax, eax
$LN6@detectAndD:

; 95   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$0:
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	jmp	DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$1:
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	jmp	DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$2:
	lea	eax, DWORD PTR _frame$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$3:
	lea	esi, DWORD PTR _enableSigns$[ebp]
	jmp	??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$4:
	lea	esi, DWORD PTR _disableSigns$[ebp]
	jmp	??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$5:
	lea	eax, DWORD PTR _frame_gray$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__ehhandler$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z ENDP ; CVDetector::detectAndDisplay
PUBLIC	_hwnd$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z ; CVDetector::hwnd2mat
_hDesktopWnd DD	01H DUP (?)
;	COMDAT xdata$x
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
xdata$x	SEGMENT
__unwindtable$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z$0
__ehfuncinfo$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
xdata$x	ENDS
;	COMDAT ?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -112				; size = 4
_sz$143466 = -108					; size = 8
_srcheight$ = -100					; size = 4
_hwnd$GSCopy$ = -96					; size = 4
_srcwidth$ = -92					; size = 4
_hwindowCompatibleDC$ = -88				; size = 4
$T143435 = -84						; size = 4
_hbwindow$ = -84					; size = 4
_width$ = -80						; size = 4
_hwindowDC$ = -76					; size = 4
_windowsize$ = -72					; size = 16
_bi$ = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z PROC	; CVDetector::hwnd2mat, COMDAT
; ___$ReturnUdt$ = esi

; 20   : 	Mat hwnd2mat(HWND hwnd){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 21   : 
; 22   : 		HDC hwindowDC,hwindowCompatibleDC;
; 23   : 
; 24   : 		int height,width,srcheight,srcwidth;
; 25   : 		HBITMAP hbwindow;
; 26   : 		Mat src;
; 27   : 		BITMAPINFOHEADER  bi;
; 28   : 
; 29   : 		hwindowDC=GetDC(hwnd);
; 30   : 		hwindowCompatibleDC=CreateCompatibleDC(hwindowDC);
; 31   : 		SetStretchBltMode(hwindowCompatibleDC,COLORONCOLOR);  
; 32   : 
; 33   : 		RECT windowsize;    // get the height and width of the screen
; 34   : 		GetClientRect(hwnd, &windowsize);
; 35   : 
; 36   : 		srcheight = windowsize.bottom;
; 37   : 		srcwidth = windowsize.right;
; 38   : 		height = windowsize.bottom/2;  //change this to whatever size you want to resize to
; 39   : 		width = windowsize.right/2;
; 40   : 
; 41   : 		src.create(height,width,CV_8UC4);

	xor	edi, edi
	mov	DWORD PTR $T143435[ebp], edi
	mov	edx, DWORD PTR _hDesktopWnd
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+40], ecx
	lea	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [eax+4], edi
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edi
	mov	ebx, edx
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
	mov	DWORD PTR _hwnd$GSCopy$[ebp], ebx
	mov	DWORD PTR [esi], 1124007936		; 42ff0000H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+36], edi

; 65   : 
; 66   : 		return src;

	mov	DWORD PTR __$EHRec$[ebp+8], edi
	push	edx
	mov	DWORD PTR $T143435[ebp], 1
	call	DWORD PTR __imp__GetDC@4
	push	eax
	mov	DWORD PTR _hwindowDC$[ebp], eax
	call	DWORD PTR __imp__CreateCompatibleDC@4
	push	3
	push	eax
	mov	DWORD PTR _hwindowCompatibleDC$[ebp], eax
	call	DWORD PTR __imp__SetStretchBltMode@8
	lea	ecx, DWORD PTR _windowsize$[ebp]
	push	ecx
	push	ebx
	call	DWORD PTR __imp__GetClientRect@8
	mov	eax, DWORD PTR _windowsize$[ebp+12]
	mov	ecx, DWORD PTR _windowsize$[ebp+8]
	mov	DWORD PTR _srcheight$[ebp], eax
	cdq
	sub	eax, edx
	mov	ebx, eax
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	sar	ebx, 1
	cmp	DWORD PTR [esi+4], 2
	mov	DWORD PTR _srcwidth$[ebp], ecx
	mov	DWORD PTR _width$[ebp], eax
	jg	SHORT $LN13@hwnd2mat

; 21   : 
; 22   : 		HDC hwindowDC,hwindowCompatibleDC;
; 23   : 
; 24   : 		int height,width,srcheight,srcwidth;
; 25   : 		HBITMAP hbwindow;
; 26   : 		Mat src;
; 27   : 		BITMAPINFOHEADER  bi;
; 28   : 
; 29   : 		hwindowDC=GetDC(hwnd);
; 30   : 		hwindowCompatibleDC=CreateCompatibleDC(hwindowDC);
; 31   : 		SetStretchBltMode(hwindowCompatibleDC,COLORONCOLOR);  
; 32   : 
; 33   : 		RECT windowsize;    // get the height and width of the screen
; 34   : 		GetClientRect(hwnd, &windowsize);
; 35   : 
; 36   : 		srcheight = windowsize.bottom;
; 37   : 		srcwidth = windowsize.right;
; 38   : 		height = windowsize.bottom/2;  //change this to whatever size you want to resize to
; 39   : 		width = windowsize.right/2;
; 40   : 
; 41   : 		src.create(height,width,CV_8UC4);

	cmp	DWORD PTR [esi+8], ebx
	jne	SHORT $LN13@hwnd2mat
	cmp	DWORD PTR [esi+12], eax
	jne	SHORT $LN13@hwnd2mat
	mov	edx, DWORD PTR [esi]
	and	edx, 4095				; 00000fffH
	cmp	edx, 24					; 00000018H
	jne	SHORT $LN13@hwnd2mat
	cmp	DWORD PTR [esi+16], edi
	jne	SHORT $LN14@hwnd2mat
$LN13@hwnd2mat:
	mov	DWORD PTR _sz$143466[ebp+4], eax
	push	24					; 00000018H
	lea	eax, DWORD PTR _sz$143466[ebp]
	push	eax
	push	2
	mov	ecx, esi
	mov	DWORD PTR _sz$143466[ebp], ebx
	call	DWORD PTR __imp_?create@Mat@cv@@QAEXHPBHH@Z
	mov	eax, DWORD PTR _width$[ebp]
$LN14@hwnd2mat:

; 42   : 
; 43   : 		// create a bitmap
; 44   : 		hbwindow = CreateCompatibleBitmap( hwindowDC, width, height);

	mov	ecx, DWORD PTR _hwindowDC$[ebp]
	push	ebx
	push	eax
	push	ecx
	call	DWORD PTR __imp__CreateCompatibleBitmap@12

; 45   : 		bi.biSize = sizeof(BITMAPINFOHEADER);  
; 46   : 		bi.biWidth = width;    

	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _bi$[ebp+4], edx

; 47   : 		bi.biHeight = -height;  //this is the line that makes it draw upside down or not
; 48   : 		bi.biPlanes = 1;    
; 49   : 		bi.biBitCount = 32;    
; 50   : 		bi.biCompression = BI_RGB;    
; 51   : 		bi.biSizeImage = 0;  
; 52   : 		bi.biXPelsPerMeter = 0;    
; 53   : 		bi.biYPelsPerMeter = 0;    
; 54   : 		bi.biClrUsed = 0;    
; 55   : 		bi.biClrImportant = 0;
; 56   : 
; 57   : 		// use the previously created device context with the bitmap
; 58   : 		SelectObject(hwindowCompatibleDC, hbwindow);

	mov	edx, DWORD PTR _hwindowCompatibleDC$[ebp]
	mov	ecx, ebx
	push	eax
	neg	ecx
	push	edx
	mov	DWORD PTR _hbwindow$[ebp], eax
	mov	DWORD PTR _bi$[ebp], 40			; 00000028H
	mov	DWORD PTR _bi$[ebp+8], ecx
	mov	DWORD PTR _bi$[ebp+12], 2097153		; 00200001H
	mov	DWORD PTR _bi$[ebp+16], edi
	mov	DWORD PTR _bi$[ebp+20], edi
	mov	DWORD PTR _bi$[ebp+24], edi
	mov	DWORD PTR _bi$[ebp+28], edi
	mov	DWORD PTR _bi$[ebp+32], edi
	mov	DWORD PTR _bi$[ebp+36], edi
	call	DWORD PTR __imp__SelectObject@8

; 59   : 		// copy from the window device context to the bitmap device context
; 60   : 		StretchBlt( hwindowCompatibleDC, 0,0, width, height, hwindowDC, 0, 0,srcwidth,srcheight, SRCCOPY); //change SRCCOPY to NOTSRCCOPY for wacky colors !

	mov	eax, DWORD PTR _srcheight$[ebp]
	mov	ecx, DWORD PTR _srcwidth$[ebp]
	mov	edx, DWORD PTR _hwindowDC$[ebp]
	push	13369376				; 00cc0020H
	push	eax
	mov	eax, DWORD PTR _width$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _hwindowCompatibleDC$[ebp]
	push	edi
	push	edi
	push	edx
	push	ebx
	push	eax
	push	edi
	push	edi
	push	ecx
	call	DWORD PTR __imp__StretchBlt@44

; 61   : 		GetDIBits(hwindowCompatibleDC,hbwindow,0,height,src.data,(BITMAPINFO *)&bi,DIB_RGB_COLORS);  //copy from hwindowCompatibleDC to hbwindow

	mov	eax, DWORD PTR [esi+16]
	push	edi
	lea	edx, DWORD PTR _bi$[ebp]
	push	edx
	push	eax
	push	ebx
	mov	ebx, DWORD PTR _hwindowCompatibleDC$[ebp]
	push	edi
	mov	edi, DWORD PTR _hbwindow$[ebp]
	push	edi
	push	ebx
	call	DWORD PTR __imp__GetDIBits@28

; 62   : 
; 63   : 		// avoid memory leak
; 64   : 		DeleteObject (hbwindow); DeleteDC(hwindowCompatibleDC); ReleaseDC(hwnd, hwindowDC);

	push	edi
	call	DWORD PTR __imp__DeleteObject@4
	push	ebx
	call	DWORD PTR __imp__DeleteDC@4
	mov	ecx, DWORD PTR _hwindowDC$[ebp]
	mov	edx, DWORD PTR _hwnd$GSCopy$[ebp]
	push	ecx
	push	edx
	call	DWORD PTR __imp__ReleaseDC@8

; 65   : 
; 66   : 		return src;

	mov	eax, esi

; 67   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z$0:
	mov	eax, DWORD PTR $T143435[ebp]
	and	eax, 1
	je	$LN4@hwnd2mat
	and	DWORD PTR $T143435[ebp], -2		; fffffffeH
	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
$LN4@hwnd2mat:
	ret	0
__ehhandler$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z ENDP	; CVDetector::hwnd2mat
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = esi
; __Ptr$ = eax
; __Count$ = edi

; 910  : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebx
	mov	ebx, eax

; 911  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 912  : 		if (_Count != 0)
; 913  : 			_DEBUG_POINTER(_Ptr);
; 914  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 915  : 
; 916  : 		if (_Inside(_Ptr))

	test	ebx, ebx
	je	SHORT $LN85@assign@2
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@assign@2
$LN12@assign@2:
	mov	eax, esi
$LN13@assign@2:
	cmp	ebx, eax
	jb	SHORT $LN85@assign@2
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN16@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN17@assign@2
$LN16@assign@2:
	mov	eax, esi
$LN17@assign@2:
	mov	edx, DWORD PTR [esi+16]
	add	edx, eax
	cmp	edx, ebx
	jbe	SHORT $LN85@assign@2

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign@2
	mov	eax, DWORD PTR [esi]
	sub	ebx, eax
	push	esi
	mov	eax, edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	ebx

; 925  : 		}

	ret	0

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

$LN20@assign@2:
	mov	eax, esi
	sub	ebx, eax
	push	esi
	mov	eax, edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	ebx

; 925  : 		}

	ret	0
$LN85@assign@2:

; 918  : 
; 919  : 		if (_Grow(_Count))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@assign@2
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN90@assign@2:
$LN27@assign@2:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN26@assign@2
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	edi
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
	je	SHORT $LN82@assign@2
$LN89@assign@2:

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN72@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN73@assign@2

; 918  : 
; 919  : 		if (_Grow(_Count))

$LN26@assign@2:
	test	edi, edi
	jne	SHORT $LN89@assign@2
	mov	DWORD PTR [esi+16], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN65@assign@2
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax], 0

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 925  : 		}

	ret	0

; 918  : 
; 919  : 		if (_Grow(_Count))

$LN65@assign@2:
	mov	eax, esi
	mov	BYTE PTR [eax], 0
	pop	ebx

; 925  : 		}

	ret	0

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

$LN72@assign@2:
	mov	eax, esi
$LN73@assign@2:
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 922  : 			_Eos(_Count);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], edi
	jb	SHORT $LN80@assign@2
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi], 0

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 925  : 		}

	ret	0

; 922  : 			_Eos(_Count);

$LN80@assign@2:
	mov	eax, esi
	mov	BYTE PTR [eax+edi], 0
$LN82@assign@2:

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 925  : 		}

	ret	0
$LN87@assign@2:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; __Ptr$ = eax

; 928  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi

; 929  : 		_DEBUG_POINTER(_Ptr);
; 930  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, eax
	push	edi
	lea	esi, DWORD PTR [ecx+1]
	npad	6
$LL5@assign@3:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL5@assign@3
	sub	ecx, esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, ecx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 931  : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; __Ptr$ = eax

; 767  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi

; 768  : 		return (assign(_Ptr));

	mov	ecx, eax
	push	edi
	lea	esi, DWORD PTR [ecx+1]
	npad	6
$LL7@operator:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL7@operator
	sub	ecx, esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, ecx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 769  : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?detectSigns@SignDetector@CVDetector@@SAXXZ	; CVDetector::SignDetector::detectSigns
_enable_cascade DD 01H DUP (?)
_disable_cascade DD 01H DUP (?)
;	COMDAT xdata$x
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
xdata$x	SEGMENT
__unwindtable$?detectSigns@SignDetector@CVDetector@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$2
__ehfuncinfo$?detectSigns@SignDetector@CVDetector@@SAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?detectSigns@SignDetector@CVDetector@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?detectSigns@SignDetector@CVDetector@@SAXXZ
_TEXT	SEGMENT
tv145 = -88						; size = 4
$T143728 = -88						; size = 4
$T143726 = -84						; size = 4
$T143727 = -80						; size = 4
_frame$ = -76						; size = 56
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?detectSigns@SignDetector@CVDetector@@SAXXZ PROC	; CVDetector::SignDetector::detectSigns, COMDAT

; 130  : 		{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?detectSigns@SignDetector@CVDetector@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+88], eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, eax

; 131  : 			Mat frame = hwnd2mat(hDesktopWnd);

	lea	esi, DWORD PTR _frame$[esp+100]
	call	?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z ; CVDetector::hwnd2mat

; 132  : 			signID = detectAndDisplay(frame, *enable_cascade, *disable_cascade);

	sub	esp, 56					; 00000038H
	mov	edi, esi
	mov	DWORD PTR __$EHRec$[esp+164], 0
	mov	esi, esp
	mov	DWORD PTR $T143728[esp+156], esp
	call	??0Mat@cv@@QAE@ABV01@@Z			; cv::Mat::Mat
	sub	esp, 132				; 00000084H
	mov	BYTE PTR __$EHRec$[esp+296], 1
	mov	ecx, DWORD PTR _disable_cascade
	mov	eax, esp
	mov	DWORD PTR $T143726[esp+288], esp
	push	eax
	call	??0CascadeClassifier@cv@@QAE@ABV01@@Z
	sub	esp, 132				; 00000084H
	mov	ecx, esp
	mov	DWORD PTR $T143727[esp+420], esp
	mov	BYTE PTR __$EHRec$[esp+428], 2
	push	ecx
	mov	ecx, DWORD PTR _enable_cascade
	call	??0CascadeClassifier@cv@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[esp+428], 0
	call	?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z ; CVDetector::detectAndDisplay
	mov	DWORD PTR tv145[esp+420], eax
	fild	DWORD PTR tv145[esp+420]
	add	esp, 320				; 00000140H

; 133  : 			//printf("Found = %lf\n",signID);
; 134  : 			//waitKey(30); // -------------->uncomment this for debug mode
; 135  : 		}

	mov	eax, edi
	fstp	QWORD PTR _signID
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+88]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$0:
	lea	eax, DWORD PTR _frame$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$1:
	mov	eax, DWORD PTR $T143728[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$2:
	mov	ecx, DWORD PTR $T143726[ebp]
	jmp	DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
__ehhandler$?detectSigns@SignDetector@CVDetector@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-84]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 8
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?detectSigns@SignDetector@CVDetector@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?detectSigns@SignDetector@CVDetector@@SAXXZ ENDP	; CVDetector::SignDetector::detectSigns
PUBLIC	?initialiseDetector@SignDetector@CVDetector@@SAHXZ ; CVDetector::SignDetector::initialiseDetector
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?initialiseDetector@SignDetector@CVDetector@@SAHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initialiseDetector@SignDetector@CVDetector@@SAHXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialiseDetector@SignDetector@CVDetector@@SAHXZ$1
__ehfuncinfo$?initialiseDetector@SignDetector@CVDetector@@SAHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?initialiseDetector@SignDetector@CVDetector@@SAHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
xdata$x	ENDS
;	COMDAT ?initialiseDetector@SignDetector@CVDetector@@SAHXZ
_TEXT	SEGMENT
$T143746 = -20						; size = 4
$T143742 = -20						; size = 4
_hDesktopDC$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?initialiseDetector@SignDetector@CVDetector@@SAHXZ PROC	; CVDetector::SignDetector::initialiseDetector, COMDAT

; 102  : 		{			

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?initialiseDetector@SignDetector@CVDetector@@SAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 103  : 			HDC hDesktopDC;
; 104  : 			hDesktopWnd=GetDesktopWindow();

	call	DWORD PTR __imp__GetDesktopWindow@0

; 105  : 			hDesktopDC=GetDC(hDesktopWnd);

	push	eax
	mov	DWORD PTR _hDesktopWnd, eax
	call	DWORD PTR __imp__GetDC@4

; 106  : 			disable_cascade = new CascadeClassifier;

	mov	esi, DWORD PTR __imp_??2@YAPAXI@Z
	push	132					; 00000084H
	mov	DWORD PTR _hDesktopDC$[ebp], eax
	call	esi
	add	esp, 4
	mov	DWORD PTR $T143742[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edi, DWORD PTR __imp_??0CascadeClassifier@cv@@QAE@XZ
	test	eax, eax
	je	SHORT $LN5@initialise
	mov	ecx, eax
	call	edi
	jmp	SHORT $LN6@initialise
$LN5@initialise:
	xor	eax, eax
$LN6@initialise:
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 107  : 			enable_cascade = new CascadeClassifier;

	push	132					; 00000084H
	mov	DWORD PTR _disable_cascade, eax
	call	esi
	add	esp, 4
	mov	DWORD PTR $T143746[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN7@initialise
	mov	ecx, eax
	call	edi
	jmp	SHORT $LN8@initialise
$LN7@initialise:
	xor	eax, eax
$LN8@initialise:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR _enable_cascade, eax

; 108  : 			
; 109  : 			window_name  = "Detecting ...";

	mov	edi, 13					; 0000000dH
	mov	eax, OFFSET ??_C@_0O@ENPJBMMB@Detecting?5?4?4?4?$AA@
	mov	esi, OFFSET ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; window_name
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 110  : 			cascade_enable = "classifier_enable.xml";

	mov	edi, 21					; 00000015H
	mov	eax, OFFSET ??_C@_0BG@GANHPLLF@classifier_enable?4xml?$AA@
	mov	esi, OFFSET ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_enable
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 111  : 			cascade_disable = "classifier_disable.xml";

	mov	edi, 22					; 00000016H
	mov	eax, OFFSET ??_C@_0BH@OOLANKBA@classifier_disable?4xml?$AA@
	mov	esi, OFFSET ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_disable
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 112  : 			if( !(*enable_cascade).load( cascade_enable ) ){ return -1; };

	mov	ecx, DWORD PTR _enable_cascade
	mov	esi, DWORD PTR __imp_?load@CascadeClassifier@cv@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	push	OFFSET ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_enable
	call	esi
	test	al, al
	jne	SHORT $LN2@initialise
$LN30@initialise:
	or	eax, -1

; 127  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@initialise:

; 113  : 			if( !(*disable_cascade).load( cascade_disable ) ){ return -1; };

	mov	ecx, DWORD PTR _disable_cascade
	push	OFFSET ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_disable
	call	esi
	test	al, al
	je	SHORT $LN30@initialise

; 114  : 
; 115  : 			// get the height and width of the screen
; 116  : 			int height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

	mov	esi, DWORD PTR __imp__GetSystemMetrics@4
	push	79					; 0000004fH
	call	esi

; 117  : 			int width = GetSystemMetrics(SM_CXVIRTUALSCREEN);

	push	78					; 0000004eH
	mov	edi, eax
	call	esi

; 118  : 
; 119  : 			// create a bitmap
; 120  : 			HBITMAP hbDesktop = CreateCompatibleBitmap( hDesktopDC, width, height);

	push	edi
	push	eax
	mov	eax, DWORD PTR _hDesktopDC$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateCompatibleBitmap@12

; 121  : 
; 122  : 			/*while(1){ //----------->comment this for release mode
; 123  : 				detectSigns();
; 124  : 			}*/
; 125  : 			
; 126  : 			return 0;

	xor	eax, eax

; 127  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?initialiseDetector@SignDetector@CVDetector@@SAHXZ$0:
	mov	eax, DWORD PTR $T143742[ebp]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx
	ret	0
__unwindfunclet$?initialiseDetector@SignDetector@CVDetector@@SAHXZ$1:
	mov	eax, DWORD PTR $T143746[ebp]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx
	ret	0
__ehhandler$?initialiseDetector@SignDetector@CVDetector@@SAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?initialiseDetector@SignDetector@CVDetector@@SAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?initialiseDetector@SignDetector@CVDetector@@SAHXZ ENDP	; CVDetector::SignDetector::initialiseDetector
PUBLIC	?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; window_name
?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; window_name
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
; Function compile flags: /Ogtp
;	COMDAT ??__Ewindow_name@@YAXXZ
text$yc	SEGMENT
??__Ewindow_name@@YAXXZ PROC				; `dynamic initializer for 'window_name'', COMDAT

; 12   : string window_name;

	push	OFFSET ??__Fwindow_name@@YAXXZ		; `dynamic atexit destructor for 'window_name''
	call	_atexit
	pop	ecx
	ret	0
??__Ewindow_name@@YAXXZ ENDP				; `dynamic initializer for 'window_name''
text$yc	ENDS
PUBLIC	?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_enable
	ORG $+4
?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; cascade_enable
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
; Function compile flags: /Ogtp
;	COMDAT ??__Ecascade_enable@@YAXXZ
text$yc	SEGMENT
??__Ecascade_enable@@YAXXZ PROC				; `dynamic initializer for 'cascade_enable'', COMDAT

; 13   : String cascade_enable, cascade_disable;

	push	OFFSET ??__Fcascade_enable@@YAXXZ	; `dynamic atexit destructor for 'cascade_enable''
	call	_atexit
	pop	ecx
	ret	0
??__Ecascade_enable@@YAXXZ ENDP				; `dynamic initializer for 'cascade_enable''
text$yc	ENDS
PUBLIC	?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_disable
	ORG $+4
?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; cascade_disable
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
; Function compile flags: /Ogtp
;	COMDAT ??__Ecascade_disable@@YAXXZ
text$yc	SEGMENT
??__Ecascade_disable@@YAXXZ PROC			; `dynamic initializer for 'cascade_disable'', COMDAT

; 13   : String cascade_enable, cascade_disable;

	push	OFFSET ??__Fcascade_disable@@YAXXZ	; `dynamic atexit destructor for 'cascade_disable''
	call	_atexit
	pop	ecx
	ret	0
??__Ecascade_disable@@YAXXZ ENDP			; `dynamic initializer for 'cascade_disable''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fcascade_enable@@YAXXZ
text$yd	SEGMENT
??__Fcascade_enable@@YAXXZ PROC				; `dynamic atexit destructor for 'cascade_enable'', COMDAT
	cmp	DWORD PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
	jb	SHORT $LN13@dynamic
	mov	eax, DWORD PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN13@dynamic:
	xor	eax, eax
	mov	DWORD PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH
	mov	DWORD PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax
	mov	BYTE PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, al
	ret	0
??__Fcascade_enable@@YAXXZ ENDP				; `dynamic atexit destructor for 'cascade_enable''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fcascade_disable@@YAXXZ
text$yd	SEGMENT
??__Fcascade_disable@@YAXXZ PROC			; `dynamic atexit destructor for 'cascade_disable'', COMDAT
	cmp	DWORD PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
	jb	SHORT $LN13@dynamic@2
	mov	eax, DWORD PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN13@dynamic@2:
	xor	eax, eax
	mov	DWORD PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH
	mov	DWORD PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax
	mov	BYTE PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, al
	ret	0
??__Fcascade_disable@@YAXXZ ENDP			; `dynamic atexit destructor for 'cascade_disable''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fwindow_name@@YAXXZ
text$yd	SEGMENT
??__Fwindow_name@@YAXXZ PROC				; `dynamic atexit destructor for 'window_name'', COMDAT
	cmp	DWORD PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
	jb	SHORT $LN13@dynamic@3
	mov	eax, DWORD PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN13@dynamic@3:
	xor	eax, eax
	mov	DWORD PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH
	mov	DWORD PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax
	mov	BYTE PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, al
	ret	0
??__Fwindow_name@@YAXXZ ENDP				; `dynamic atexit destructor for 'window_name''
text$yd	ENDS
CRT$XCU	SEGMENT
_window_name$initializer$ DD FLAT:??__Ewindow_name@@YAXXZ
_cascade_enable$initializer$ DD FLAT:??__Ecascade_enable@@YAXXZ
_cascade_disable$initializer$ DD FLAT:??__Ecascade_disable@@YAXXZ
CRT$XCU	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\OJ\Documents\Visual Studio 2010\Projects\CVDetectorDLL\CVDetectorDLL.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4CascadeClassifier@cv@@6B@			; cv::CascadeClassifier::`RTTI Complete Object Locator'
PUBLIC	??_R3CascadeClassifier@cv@@8			; cv::CascadeClassifier::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CascadeClassifier@cv@@8			; cv::CascadeClassifier::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CascadeClassifier@cv@@8		; cv::CascadeClassifier::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCascadeClassifier@cv@@@8		; cv::CascadeClassifier `RTTI Type Descriptor'
PUBLIC	??_R4_OutputArray@cv@@6B@			; cv::_OutputArray::`RTTI Complete Object Locator'
PUBLIC	??_R3_OutputArray@cv@@8				; cv::_OutputArray::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_OutputArray@cv@@8				; cv::_OutputArray::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_OutputArray@cv@@8		; cv::_OutputArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_OutputArray@cv@@@8			; cv::_OutputArray `RTTI Type Descriptor'
PUBLIC	??_R4_InputArray@cv@@6B@			; cv::_InputArray::`RTTI Complete Object Locator'
PUBLIC	??_R3_InputArray@cv@@8				; cv::_InputArray::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_InputArray@cv@@8				; cv::_InputArray::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_InputArray@cv@@8			; cv::_InputArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_InputArray@cv@@@8			; cv::_InputArray `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
PUBLIC	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator!=<char,char>
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?eq@?$char_traits@D@std@@SA_NABD0@Z		; std::char_traits<char>::eq
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	??0?$fpos@H@std@@QAE@_J@Z			; std::fpos<int>::fpos<int>
PUBLIC	??B?$fpos@H@std@@QBE_JXZ			; std::fpos<int>::operator __int64
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	?type@Mat@cv@@QBEHXZ				; cv::Mat::type
PUBLIC	?create@Mat@cv@@QAEXHHH@Z			; cv::Mat::create
PUBLIC	??0?$Point_@H@cv@@QAE@ABV01@@Z			; cv::Point_<int>::Point_<int>
PUBLIC	??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@XZ	; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >
PUBLIC	??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@ABV01@@Z ; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >
PUBLIC	??0?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@V?$allocator@V?$Rect_@H@cv@@@1@@Z ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
PUBLIC	??0?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
PUBLIC	??1?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
PUBLIC	?deallocate@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@I@Z ; std::allocator<cv::Rect_<int> >::deallocate
PUBLIC	??$_Ptr_cat@V?$Rect_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Rect_@H@cv@@0@Z ; std::_Ptr_cat<cv::Rect_<int>,cv::Rect_<int> >
PUBLIC	??$_Destroy@V?$Rect_@H@cv@@@std@@YAXPAV?$Rect_@H@cv@@@Z ; std::_Destroy<cv::Rect_<int> >
PUBLIC	?destroy@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@@Z ; std::allocator<cv::Rect_<int> >::destroy
PUBLIC	??$_Dest_val@V?$allocator@V?$Rect_@H@cv@@@std@@V?$Rect_@H@cv@@@std@@YAXAAV?$allocator@V?$Rect_@H@cv@@@0@PAV?$Rect_@H@cv@@@Z ; std::_Dest_val<std::allocator<cv::Rect_<int> >,cv::Rect_<int> >
PUBLIC	??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >
PUBLIC	?_Destroy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXPAV?$Rect_@H@cv@@0@Z ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Tidy
PUBLIC	??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
PUBLIC	?size@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::size
PUBLIC	??A?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAEAAV?$Rect_@H@cv@@I@Z ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::operator[]
PUBLIC	??0?$Point_@H@cv@@QAE@XZ			; cv::Point_<int>::Point_<int>
PUBLIC	??0?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
PUBLIC	??0?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
PUBLIC	??0?$_Vector_val@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@1@@Z ; std::_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
PUBLIC	??0?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
PUBLIC	??1?$_Vector_val@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::~_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
PUBLIC	?deallocate@?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@I@Z ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::deallocate
PUBLIC	??$_Ptr_cat@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0@Z ; std::_Ptr_cat<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
PUBLIC	??1?$_Vector_val@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::Point_<int>,std::allocator<cv::Point_<int> > >::~_Vector_val<cv::Point_<int>,std::allocator<cv::Point_<int> > >
PUBLIC	?deallocate@?$allocator@V?$Point_@H@cv@@@std@@QAEXPAV?$Point_@H@cv@@I@Z ; std::allocator<cv::Point_<int> >::deallocate
PUBLIC	??$_Ptr_cat@V?$Point_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Point_@H@cv@@0@Z ; std::_Ptr_cat<cv::Point_<int>,cv::Point_<int> >
PUBLIC	??$_Destroy@V?$Point_@H@cv@@@std@@YAXPAV?$Point_@H@cv@@@Z ; std::_Destroy<cv::Point_<int> >
PUBLIC	?destroy@?$allocator@V?$Point_@H@cv@@@std@@QAEXPAV?$Point_@H@cv@@@Z ; std::allocator<cv::Point_<int> >::destroy
PUBLIC	??$_Dest_val@V?$allocator@V?$Point_@H@cv@@@std@@V?$Point_@H@cv@@@std@@YAXAAV?$allocator@V?$Point_@H@cv@@@0@PAV?$Point_@H@cv@@@Z ; std::_Dest_val<std::allocator<cv::Point_<int> >,cv::Point_<int> >
PUBLIC	??$_Destroy_range@V?$allocator@V?$Point_@H@cv@@@std@@@std@@YAXPAV?$Point_@H@cv@@0AAV?$allocator@V?$Point_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::Point_<int> > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$Point_@H@cv@@@std@@@std@@YAXPAV?$Point_@H@cv@@0AAV?$allocator@V?$Point_@H@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::Point_<int> > >
PUBLIC	?_Destroy@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@IAEXPAV?$Point_@H@cv@@0@Z ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::_Tidy
PUBLIC	??1?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::~vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >
PUBLIC	??_G?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAEPAXI@Z ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::`scalar deleting destructor'
PUBLIC	??$_Destroy@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@@Z ; std::_Destroy<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
PUBLIC	?destroy@?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@@Z ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::destroy
PUBLIC	??$_Dest_val@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@@std@@YAXAAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@PAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >,std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0AAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0AAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
PUBLIC	?_Destroy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@0@Z ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Tidy
PUBLIC	??1?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::~vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
PUBLIC	??A?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAEAAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@1@I@Z ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::operator[]
PUBLIC	??0?$allocator@V?$Vec@H$03@cv@@@std@@QAE@XZ	; std::allocator<cv::Vec<int,4> >::allocator<cv::Vec<int,4> >
PUBLIC	??0?$allocator@V?$Vec@H$03@cv@@@std@@QAE@ABV01@@Z ; std::allocator<cv::Vec<int,4> >::allocator<cv::Vec<int,4> >
PUBLIC	??0?$_Vector_val@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@V?$allocator@V?$Vec@H$03@cv@@@1@@Z ; std::_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >
PUBLIC	??0?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >
PUBLIC	??1?$_Vector_val@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::~_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >
PUBLIC	?deallocate@?$allocator@V?$Vec@H$03@cv@@@std@@QAEXPAV?$Vec@H$03@cv@@I@Z ; std::allocator<cv::Vec<int,4> >::deallocate
PUBLIC	??$_Ptr_cat@V?$Vec@H$03@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Vec@H$03@cv@@0@Z ; std::_Ptr_cat<cv::Vec<int,4>,cv::Vec<int,4> >
PUBLIC	??$_Destroy@V?$Vec@H$03@cv@@@std@@YAXPAV?$Vec@H$03@cv@@@Z ; std::_Destroy<cv::Vec<int,4> >
PUBLIC	?destroy@?$allocator@V?$Vec@H$03@cv@@@std@@QAEXPAV?$Vec@H$03@cv@@@Z ; std::allocator<cv::Vec<int,4> >::destroy
PUBLIC	??$_Dest_val@V?$allocator@V?$Vec@H$03@cv@@@std@@V?$Vec@H$03@cv@@@std@@YAXAAV?$allocator@V?$Vec@H$03@cv@@@0@PAV?$Vec@H$03@cv@@@Z ; std::_Dest_val<std::allocator<cv::Vec<int,4> >,cv::Vec<int,4> >
PUBLIC	??$_Destroy_range@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@YAXPAV?$Vec@H$03@cv@@0AAV?$allocator@V?$Vec@H$03@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::Vec<int,4> > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@YAXPAV?$Vec@H$03@cv@@0AAV?$allocator@V?$Vec@H$03@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::Vec<int,4> > >
PUBLIC	?_Destroy@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@IAEXPAV?$Vec@H$03@cv@@0@Z ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::_Tidy
PUBLIC	??1?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::~vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >
PUBLIC	?size@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::size
PUBLIC	??A?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAEAAV?$Vec@H$03@cv@@I@Z ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::operator[]
PUBLIC	??A?$Vec@H$03@cv@@QAEAAHH@Z			; cv::Vec<int,4>::operator[]
PUBLIC	??$?0V?$Point_@H@cv@@@_InputArray@cv@@QAE@ABV?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@@Z ; cv::_InputArray::_InputArray<cv::Point_<int> >
PUBLIC	??$?0V?$Point_@H@cv@@@_OutputArray@cv@@QAE@AAV?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@@Z ; cv::_OutputArray::_OutputArray<cv::Point_<int> >
PUBLIC	??0?$Size_@H@cv@@QAE@XZ				; cv::Size_<int>::Size_<int>
PUBLIC	??$?0V?$Vec@H$03@cv@@@_InputArray@cv@@QAE@ABV?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@@Z ; cv::_InputArray::_InputArray<cv::Vec<int,4> >
PUBLIC	??$?0V?$Vec@H$03@cv@@@_OutputArray@cv@@QAE@AAV?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@@Z ; cv::_OutputArray::_OutputArray<cv::Vec<int,4> >
PUBLIC	??0Mat@cv@@QAE@HHHPAXI@Z			; cv::Mat::Mat
PUBLIC	?size@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::size
PUBLIC	?empty@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBE_NXZ ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::empty
PUBLIC	??A?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBEABV?$Point_@H@cv@@I@Z ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::operator[]
PUBLIC	??$?0V?$Point_@H@cv@@@Mat@cv@@QAE@ABV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@_N@Z ; cv::Mat::Mat<cv::Point_<int> >
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?release@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ ; cv::Ptr<CvHaarClassifierCascade>::release
PUBLIC	??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ	; cv::Ptr<CvHaarClassifierCascade>::~Ptr<CvHaarClassifierCascade>
PUBLIC	?addref@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ ; cv::Ptr<CvHaarClassifierCascade>::addref
PUBLIC	??0?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@ABV01@@Z ; cv::Ptr<CvHaarClassifierCascade>::Ptr<CvHaarClassifierCascade>
PUBLIC	??1Data@CascadeClassifier@cv@@QAE@XZ		; cv::CascadeClassifier::Data::~Data
PUBLIC	??0?$Size_@H@cv@@QAE@ABV01@@Z			; cv::Size_<int>::Size_<int>
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@AAPAH@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=
PUBLIC	??$_Construct@HABH@std@@YAXPAHABH@Z		; std::_Construct<int,int const &>
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
PUBLIC	??$_Destroy@H@std@@YAXPAH@Z			; std::_Destroy<int>
PUBLIC	?destroy@?$allocator@H@std@@QAEXPAH@Z		; std::allocator<int>::destroy
PUBLIC	??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z ; std::_Dest_val<std::allocator<int>,int>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@1@0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > > >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??0?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocator<cv::CascadeClassifier::Data::Stage>
PUBLIC	??0?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UStage@Data@CascadeClassifier@cv@@@1@@Z ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	?begin@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::begin
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUStage@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >
PUBLIC	?end@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::end
PUBLIC	?size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::size
PUBLIC	??$_Allocate@UStage@Data@CascadeClassifier@cv@@@std@@YAPAUStage@Data@CascadeClassifier@cv@@IPAU1234@@Z ; std::_Allocate<cv::CascadeClassifier::Data::Stage>
PUBLIC	?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate
PUBLIC	?max_size@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QBEIXZ ; std::allocator<cv::CascadeClassifier::Data::Stage>::max_size
PUBLIC	?max_size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::max_size
PUBLIC	?_Xlen@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Xlen
PUBLIC	?_Buy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUStage@Data@CascadeClassifier@cv@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUStage@Data@CascadeClassifier@cv@@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator!=
PUBLIC	??$_Construct@UStage@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::_Construct<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>
PUBLIC	?construct@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@ABU3456@@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::construct
PUBLIC	??$forward@ABUStage@Data@CascadeClassifier@cv@@@std@@YAABUStage@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::forward<cv::CascadeClassifier::Data::Stage const &>
PUBLIC	??$_Cons_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@ABU2345@@Z ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > > >
PUBLIC	??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??1?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	?deallocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::deallocate
PUBLIC	??$_Ptr_cat@UStage@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUStage@Data@CascadeClassifier@cv@@0@Z ; std::_Ptr_cat<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage>
PUBLIC	??$_Destroy@UStage@Data@CascadeClassifier@cv@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@@Z ; std::_Destroy<cv::CascadeClassifier::Data::Stage>
PUBLIC	?destroy@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::destroy
PUBLIC	??$_Dest_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@@Z ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage>
PUBLIC	??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	?_Destroy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUStage@Data@CascadeClassifier@cv@@0@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Destroy
PUBLIC	?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Tidy
PUBLIC	??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
PUBLIC	??0?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocator<cv::CascadeClassifier::Data::DTree>
PUBLIC	??0?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@1@@Z ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	?begin@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::begin
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTree@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >
PUBLIC	?end@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::end
PUBLIC	?size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::size
PUBLIC	??$_Allocate@UDTree@Data@CascadeClassifier@cv@@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@IPAU1234@@Z ; std::_Allocate<cv::CascadeClassifier::Data::DTree>
PUBLIC	?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate
PUBLIC	?max_size@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QBEIXZ ; std::allocator<cv::CascadeClassifier::Data::DTree>::max_size
PUBLIC	?max_size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::max_size
PUBLIC	?_Xlen@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Xlen
PUBLIC	?_Buy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTree@Data@CascadeClassifier@cv@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTree@Data@CascadeClassifier@cv@@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator!=
PUBLIC	??$_Construct@UDTree@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::_Construct<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>
PUBLIC	?construct@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@ABU3456@@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::construct
PUBLIC	??$forward@ABUDTree@Data@CascadeClassifier@cv@@@std@@YAABUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::forward<cv::CascadeClassifier::Data::DTree const &>
PUBLIC	??$_Cons_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@ABU2345@@Z ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > > >
PUBLIC	??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??1?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	?deallocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::deallocate
PUBLIC	??$_Ptr_cat@UDTree@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTree@Data@CascadeClassifier@cv@@0@Z ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree>
PUBLIC	??$_Destroy@UDTree@Data@CascadeClassifier@cv@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@@Z ; std::_Destroy<cv::CascadeClassifier::Data::DTree>
PUBLIC	?destroy@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::destroy
PUBLIC	??$_Dest_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@@Z ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree>
PUBLIC	??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	?_Destroy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTree@Data@CascadeClassifier@cv@@0@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Destroy
PUBLIC	?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Tidy
PUBLIC	??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
PUBLIC	??0?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocator<cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	??0?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@1@@Z ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	?begin@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::begin
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTreeNode@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >
PUBLIC	?end@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::end
PUBLIC	?size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::size
PUBLIC	??$_Allocate@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@IPAU1234@@Z ; std::_Allocate<cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate
PUBLIC	?max_size@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QBEIXZ ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::max_size
PUBLIC	?max_size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::max_size
PUBLIC	?_Xlen@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Xlen
PUBLIC	?_Buy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTreeNode@Data@CascadeClassifier@cv@@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator!=
PUBLIC	??$_Construct@UDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::_Construct<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>
PUBLIC	?construct@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::construct
PUBLIC	??$forward@ABUDTreeNode@Data@CascadeClassifier@cv@@@std@@YAABUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z ; std::forward<cv::CascadeClassifier::Data::DTreeNode const &>
PUBLIC	??$_Cons_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@ABU2345@@Z ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > > >
PUBLIC	??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??1?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	?deallocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::deallocate
PUBLIC	??$_Ptr_cat@UDTreeNode@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTreeNode@Data@CascadeClassifier@cv@@0@Z ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	??$_Destroy@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ; std::_Destroy<cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	?destroy@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::destroy
PUBLIC	??$_Dest_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@@Z ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode>
PUBLIC	??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	?_Destroy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTreeNode@Data@CascadeClassifier@cv@@0@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Destroy
PUBLIC	?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Tidy
PUBLIC	??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
PUBLIC	??0?$allocator@M@std@@QAE@ABV01@@Z		; std::allocator<float>::allocator<float>
PUBLIC	??0?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@V?$allocator@M@1@@Z ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
PUBLIC	?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ ; std::vector<float,std::allocator<float> >::begin
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAE@PAMPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >
PUBLIC	?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ ; std::vector<float,std::allocator<float> >::end
PUBLIC	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::size
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@M@std@@YAPAMIPAM@Z			; std::_Allocate<float>
PUBLIC	?allocate@?$allocator@M@std@@QAEPAMI@Z		; std::allocator<float>::allocate
PUBLIC	?max_size@?$allocator@M@std@@QBEIXZ		; std::allocator<float>::max_size
PUBLIC	?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::max_size
PUBLIC	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ ; std::vector<float,std::allocator<float> >::_Xlen
PUBLIC	?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ; std::vector<float,std::allocator<float> >::_Buy
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAM@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@AAPAM@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *>
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEABMXZ ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator!=
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$_Construct@MABM@std@@YAXPAMABM@Z		; std::_Construct<float,float const &>
PUBLIC	?construct@?$allocator@M@std@@QAEXPAMABM@Z	; std::allocator<float>::construct
PUBLIC	??$forward@ABM@std@@YAABMABM@Z			; std::forward<float const &>
PUBLIC	??$_Cons_val@V?$allocator@M@std@@MABM@std@@YAXAAV?$allocator@M@0@PAMABM@Z ; std::_Cons_val<std::allocator<float>,float,float const &>
PUBLIC	??$_Destroy@M@std@@YAXPAM@Z			; std::_Destroy<float>
PUBLIC	?destroy@?$allocator@M@std@@QAEXPAM@Z		; std::allocator<float>::destroy
PUBLIC	??$_Dest_val@V?$allocator@M@std@@M@std@@YAXAAV?$allocator@M@0@PAM@Z ; std::_Dest_val<std::allocator<float>,float>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IAEPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@1@0PAM@Z ; std::vector<float,std::allocator<float> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > > >
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
PUBLIC	?deallocate@?$allocator@M@std@@QAEXPAMI@Z	; std::allocator<float>::deallocate
PUBLIC	??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z ; std::_Ptr_cat<float,float>
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ; std::vector<float,std::allocator<float> >::_Destroy
PUBLIC	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float> >::_Tidy
PUBLIC	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
PUBLIC	??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z	; cv::CascadeClassifier::Data::Data
PUBLIC	?delete_obj@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::FeatureEvaluator>::delete_obj
PUBLIC	?release@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::FeatureEvaluator>::release
PUBLIC	??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ	; cv::Ptr<cv::FeatureEvaluator>::~Ptr<cv::FeatureEvaluator>
PUBLIC	?addref@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ	; cv::Ptr<cv::FeatureEvaluator>::addref
PUBLIC	??0?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@ABV01@@Z ; cv::Ptr<cv::FeatureEvaluator>::Ptr<cv::FeatureEvaluator>
PUBLIC	?delete_obj@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::delete_obj
PUBLIC	?release@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::release
PUBLIC	??1?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@XZ ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::~Ptr<cv::CascadeClassifier::MaskGenerator>
PUBLIC	?addref@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::addref
PUBLIC	??0?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@ABV01@@Z ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::Ptr<cv::CascadeClassifier::MaskGenerator>
PUBLIC	??_GCascadeClassifier@cv@@UAEPAXI@Z		; cv::CascadeClassifier::`scalar deleting destructor'
PUBLIC	??0CascadeClassifier@cv@@QAE@ABV01@@Z		; cv::CascadeClassifier::CascadeClassifier
PUBLIC	??0_InputArray@cv@@QAE@ABV?$Scalar_@N@1@@Z	; cv::_InputArray::_InputArray
PUBLIC	??0?$Size_@H@cv@@QAE@HH@Z			; cv::Size_<int>::Size_<int>
PUBLIC	?initEmpty@Mat@cv@@IAEXXZ			; cv::Mat::initEmpty
PUBLIC	??0Mat@cv@@QAE@XZ				; cv::Mat::Mat
PUBLIC	??0MSize@Mat@cv@@QAE@PAH@Z			; cv::Mat::MSize::MSize
PUBLIC	??0MStep@Mat@cv@@QAE@XZ				; cv::Mat::MStep::MStep
PUBLIC	??AMStep@Mat@cv@@QBEABIH@Z			; cv::Mat::MStep::operator[]
PUBLIC	??AMStep@Mat@cv@@QAEAAIH@Z			; cv::Mat::MStep::operator[]
PUBLIC	??0Mat@cv@@QAE@ABV01@@Z				; cv::Mat::Mat
PUBLIC	?release@Mat@cv@@QAEXXZ				; cv::Mat::release
PUBLIC	??1Mat@cv@@QAE@XZ				; cv::Mat::~Mat
PUBLIC	??0?$Point_@H@cv@@QAE@HH@Z			; cv::Point_<int>::Point_<int>
PUBLIC	??0?$Matx@N$03$00@cv@@QAE@XZ			; cv::Matx<double,4,1>::Matx<double,4,1>
PUBLIC	??0?$Vec@N$03@cv@@QAE@XZ			; cv::Vec<double,4>::Vec<double,4>
PUBLIC	??0?$Scalar_@N@cv@@QAE@NNNN@Z			; cv::Scalar_<double>::Scalar_<double>
PUBLIC	?all@?$Scalar_@N@cv@@SA?AV12@N@Z		; cv::Scalar_<double>::all
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	_signID
PUBLIC	_axisValue
PUBLIC	?MAX_OBJECT_AREA@@3HA				; MAX_OBJECT_AREA
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0O@ENPJBMMB@Detecting?5?4?4?4?$AA@	; `string'
PUBLIC	??_C@_0BG@GANHPLLF@classifier_enable?4xml?$AA@	; `string'
PUBLIC	??_C@_0BH@OOLANKBA@classifier_disable?4xml?$AA@	; `string'
PUBLIC	??_C@_0BB@HGDFHEIC@Axis?5value?5?$DN?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?_Stz@?$fpos@H@std@@0HB				; std::fpos<int>::_Stz
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_7_InputArray@cv@@6B@				; cv::_InputArray::`vftable'
PUBLIC	??_7_OutputArray@cv@@6B@			; cv::_OutputArray::`vftable'
PUBLIC	??_7CascadeClassifier@cv@@6B@			; cv::CascadeClassifier::`vftable'
EXTRN	?runAt@CascadeClassifier@cv@@MAEHAAV?$Ptr@VFeatureEvaluator@cv@@@2@V?$Point_@H@2@AAN@Z:PROC ; cv::CascadeClassifier::runAt
EXTRN	?detectSingleScale@CascadeClassifier@cv@@MAE_NABVMat@2@HV?$Size_@H@2@HHNAAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@6@AAV?$vector@NV?$allocator@N@std@@@6@_N@Z:PROC ; cv::CascadeClassifier::detectSingleScale
EXTRN	?getOriginalWindowSize@CascadeClassifier@cv@@UBE?AV?$Size_@H@2@XZ:PROC ; cv::CascadeClassifier::getOriginalWindowSize
EXTRN	?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@NHHV?$Size_@H@2@2@Z:PROC ; cv::CascadeClassifier::detectMultiScale
EXTRN	?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@5@AAV?$vector@NV?$allocator@N@std@@@5@NHHV?$Size_@H@2@4_N@Z:PROC ; cv::CascadeClassifier::detectMultiScale
EXTRN	?read@CascadeClassifier@cv@@UAE_NABVFileNode@2@@Z:PROC ; cv::CascadeClassifier::read
EXTRN	?empty@CascadeClassifier@cv@@UBE_NXZ:PROC	; cv::CascadeClassifier::empty
EXTRN	?clear@_OutputArray@cv@@UBEXXZ:PROC		; cv::_OutputArray::clear
EXTRN	?release@_OutputArray@cv@@UBEXXZ:PROC		; cv::_OutputArray::release
EXTRN	?create@_OutputArray@cv@@UBEXV?$Size_@H@2@HH_NH@Z:PROC ; cv::_OutputArray::create
EXTRN	?create@_OutputArray@cv@@UBEXHHHH_NH@Z:PROC	; cv::_OutputArray::create
EXTRN	?create@_OutputArray@cv@@UBEXHPBHHH_NH@Z:PROC	; cv::_OutputArray::create
EXTRN	?getMatRef@_OutputArray@cv@@UBEAAVMat@2@H@Z:PROC ; cv::_OutputArray::getMatRef
EXTRN	?needed@_OutputArray@cv@@UBE_NXZ:PROC		; cv::_OutputArray::needed
EXTRN	?fixedType@_OutputArray@cv@@UBE_NXZ:PROC	; cv::_OutputArray::fixedType
EXTRN	?fixedSize@_OutputArray@cv@@UBE_NXZ:PROC	; cv::_OutputArray::fixedSize
EXTRN	?empty@_InputArray@cv@@UBE_NXZ:PROC		; cv::_InputArray::empty
EXTRN	?channels@_InputArray@cv@@UBEHH@Z:PROC		; cv::_InputArray::channels
EXTRN	?depth@_InputArray@cv@@UBEHH@Z:PROC		; cv::_InputArray::depth
EXTRN	?type@_InputArray@cv@@UBEHH@Z:PROC		; cv::_InputArray::type
EXTRN	?total@_InputArray@cv@@UBEIH@Z:PROC		; cv::_InputArray::total
EXTRN	?size@_InputArray@cv@@UBE?AV?$Size_@H@2@H@Z:PROC ; cv::_InputArray::size
EXTRN	?kind@_InputArray@cv@@UBEHXZ:PROC		; cv::_InputArray::kind
EXTRN	?getGpuMat@_InputArray@cv@@UBE?AVGpuMat@gpu@2@XZ:PROC ; cv::_InputArray::getGpuMat
EXTRN	?getGlTexture@_InputArray@cv@@UBE?AVGlTexture@2@XZ:PROC ; cv::_InputArray::getGlTexture
EXTRN	?getGlBuffer@_InputArray@cv@@UBE?AVGlBuffer@2@XZ:PROC ; cv::_InputArray::getGlBuffer
EXTRN	?getMatVector@_InputArray@cv@@UBEXAAV?$vector@VMat@cv@@V?$allocator@VMat@cv@@@std@@@std@@@Z:PROC ; cv::_InputArray::getMatVector
EXTRN	?getMat@_InputArray@cv@@UBE?AVMat@2@H@Z:PROC	; cv::_InputArray::getMat
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@:QWORD
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@:QWORD
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@:QWORD
EXTRN	__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC
EXTRN	__imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC
EXTRN	__imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC
EXTRN	__imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	__imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	__imp_?create@Mat@cv@@QAEXHPBHH@Z:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__GetDIBits@28:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__StretchBlt@44:PROC
EXTRN	__imp__SetStretchBltMode@8:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp_?ellipse@cv@@YAXAAVMat@1@V?$Point_@H@1@V?$Size_@H@1@NNNABV?$Scalar_@N@1@HHH@Z:PROC
EXTRN	__imp_?equalizeHist@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@@Z:PROC
EXTRN	__imp_?moments@cv@@YA?AVMoments@1@ABV_InputArray@1@_N@Z:PROC
EXTRN	__imp_?findContours@cv@@YAXABV_OutputArray@1@00HHV?$Point_@H@1@@Z:PROC
EXTRN	__imp_?fixedSize@_OutputArray@cv@@UBE_NXZ:PROC
EXTRN	__imp_?fixedType@_OutputArray@cv@@UBE_NXZ:PROC
EXTRN	__imp_?needed@_OutputArray@cv@@UBE_NXZ:PROC
EXTRN	__imp_?getMatRef@_OutputArray@cv@@UBEAAVMat@2@H@Z:PROC
EXTRN	__imp_?create@_OutputArray@cv@@UBEXV?$Size_@H@2@HH_NH@Z:PROC
EXTRN	__imp_?create@_OutputArray@cv@@UBEXHHHH_NH@Z:PROC
EXTRN	__imp_?create@_OutputArray@cv@@UBEXHPBHHH_NH@Z:PROC
EXTRN	__imp_?release@_OutputArray@cv@@UBEXXZ:PROC
EXTRN	__imp_?clear@_OutputArray@cv@@UBEXXZ:PROC
EXTRN	__imp_?copyTo@Mat@cv@@QBEXABV_OutputArray@2@@Z:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_??0CascadeClassifier@cv@@QAE@XZ:PROC
EXTRN	__imp_?load@CascadeClassifier@cv@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC
EXTRN	__imp__CreateCompatibleBitmap@12:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp_?delete_obj@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ:PROC
EXTRN	__imp_??2@YAPAXI@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?what@exception@std@@UBEPBDXZ:PROC
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
EXTRN	__imp_?empty@CascadeClassifier@cv@@UBE_NXZ:PROC
EXTRN	__imp_?read@CascadeClassifier@cv@@UAE_NABVFileNode@2@@Z:PROC
EXTRN	__imp_?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@NHHV?$Size_@H@2@2@Z:PROC
EXTRN	__imp_?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@5@AAV?$vector@NV?$allocator@N@std@@@5@NHHV?$Size_@H@2@4_N@Z:PROC
EXTRN	__imp_?getOriginalWindowSize@CascadeClassifier@cv@@UBE?AV?$Size_@H@2@XZ:PROC
EXTRN	__imp_?detectSingleScale@CascadeClassifier@cv@@MAE_NABVMat@2@HV?$Size_@H@2@HHNAAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@6@AAV?$vector@NV?$allocator@N@std@@@6@_N@Z:PROC
EXTRN	__imp_?runAt@CascadeClassifier@cv@@MAEHAAV?$Ptr@VFeatureEvaluator@cv@@@2@V?$Point_@H@2@AAN@Z:PROC
EXTRN	__imp_??1CascadeClassifier@cv@@UAE@XZ:PROC
EXTRN	??_ECascadeClassifier@cv@@UAEPAXI@Z:PROC	; cv::CascadeClassifier::`vector deleting destructor'
EXTRN	__imp_?waitKey@cv@@YAHH@Z:PROC
EXTRN	__imp__printf:PROC
EXTRN	__imp_??0_InputArray@cv@@QAE@ABVMat@1@@Z:PROC
EXTRN	__imp_?getMat@_InputArray@cv@@UBE?AVMat@2@H@Z:PROC
EXTRN	__imp_?getMatVector@_InputArray@cv@@UBEXAAV?$vector@VMat@cv@@V?$allocator@VMat@cv@@@std@@@std@@@Z:PROC
EXTRN	__imp_?getGlBuffer@_InputArray@cv@@UBE?AVGlBuffer@2@XZ:PROC
EXTRN	__imp_?getGlTexture@_InputArray@cv@@UBE?AVGlTexture@2@XZ:PROC
EXTRN	__imp_?getGpuMat@_InputArray@cv@@UBE?AVGpuMat@gpu@2@XZ:PROC
EXTRN	__imp_?kind@_InputArray@cv@@UBEHXZ:PROC
EXTRN	__imp_?size@_InputArray@cv@@UBE?AV?$Size_@H@2@H@Z:PROC
EXTRN	__imp_?total@_InputArray@cv@@UBEIH@Z:PROC
EXTRN	__imp_?type@_InputArray@cv@@UBEHH@Z:PROC
EXTRN	__imp_?depth@_InputArray@cv@@UBEHH@Z:PROC
EXTRN	__imp_?channels@_InputArray@cv@@UBEHH@Z:PROC
EXTRN	__imp_?empty@_InputArray@cv@@UBE_NXZ:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_??0_OutputArray@cv@@QAE@AAVMat@1@@Z:PROC
EXTRN	__imp_?copySize@Mat@cv@@QAEXABV12@@Z:PROC
EXTRN	__imp_?fastFree@cv@@YAXPAX@Z:PROC
EXTRN	__imp_?deallocate@Mat@cv@@QAEXXZ:PROC
EXTRN	__imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z:PROC
EXTRN	__imp_?inRange@cv@@YAXABV_InputArray@1@00ABV_OutputArray@1@@Z:PROC
EXTRN	__imp_?getStructuringElement@cv@@YA?AVMat@1@HV?$Size_@H@1@V?$Point_@H@1@@Z:PROC
EXTRN	__imp_?erode@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z:PROC
EXTRN	__imp_?dilate@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z:PROC
EXTRN	__imp_?cvtColor@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@HH@Z:PROC
EXTRN	_atexit:PROC
EXTRN	__imp_??3@YAXPAX@Z:PROC
_signID	DQ	01H DUP (?)
_axisValue DQ	01H DUP (?)
?MAX_OBJECT_AREA@@3HA DD 01H DUP (?)			; MAX_OBJECT_AREA
;	COMDAT ??_7CascadeClassifier@cv@@6B@
CONST	SEGMENT
??_7CascadeClassifier@cv@@6B@ DD FLAT:??_R4CascadeClassifier@cv@@6B@ ; cv::CascadeClassifier::`vftable'
	DD	FLAT:??_ECascadeClassifier@cv@@UAEPAXI@Z
	DD	FLAT:?empty@CascadeClassifier@cv@@UBE_NXZ
	DD	FLAT:?read@CascadeClassifier@cv@@UAE_NABVFileNode@2@@Z
	DD	FLAT:?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@5@AAV?$vector@NV?$allocator@N@std@@@5@NHHV?$Size_@H@2@4_N@Z
	DD	FLAT:?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@NHHV?$Size_@H@2@2@Z
	DD	FLAT:?getOriginalWindowSize@CascadeClassifier@cv@@UBE?AV?$Size_@H@2@XZ
	DD	FLAT:?detectSingleScale@CascadeClassifier@cv@@MAE_NABVMat@2@HV?$Size_@H@2@HHNAAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@AAV?$vector@HV?$allocator@H@std@@@6@AAV?$vector@NV?$allocator@N@std@@@6@_N@Z
	DD	FLAT:?runAt@CascadeClassifier@cv@@MAEHAAV?$Ptr@VFeatureEvaluator@cv@@@2@V?$Point_@H@2@AAN@Z
CONST	ENDS
;	COMDAT ??_R4CascadeClassifier@cv@@6B@
rdata$r	SEGMENT
??_R4CascadeClassifier@cv@@6B@ DD 00H			; cv::CascadeClassifier::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCascadeClassifier@cv@@@8
	DD	FLAT:??_R3CascadeClassifier@cv@@8
rdata$r	ENDS
;	COMDAT ??_R3CascadeClassifier@cv@@8
rdata$r	SEGMENT
??_R3CascadeClassifier@cv@@8 DD 00H			; cv::CascadeClassifier::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CascadeClassifier@cv@@8
rdata$r	ENDS
;	COMDAT ??_R2CascadeClassifier@cv@@8
rdata$r	SEGMENT
??_R2CascadeClassifier@cv@@8 DD FLAT:??_R1A@?0A@EA@CascadeClassifier@cv@@8 ; cv::CascadeClassifier::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CascadeClassifier@cv@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CascadeClassifier@cv@@8 DD FLAT:??_R0?AVCascadeClassifier@cv@@@8 ; cv::CascadeClassifier::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CascadeClassifier@cv@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCascadeClassifier@cv@@@8
_DATA	SEGMENT
??_R0?AVCascadeClassifier@cv@@@8 DD FLAT:??_7type_info@@6B@ ; cv::CascadeClassifier `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCascadeClassifier@cv@@', 00H
_DATA	ENDS
;	COMDAT ??_7_OutputArray@cv@@6B@
CONST	SEGMENT
??_7_OutputArray@cv@@6B@ DD FLAT:??_R4_OutputArray@cv@@6B@ ; cv::_OutputArray::`vftable'
	DD	FLAT:?getMat@_InputArray@cv@@UBE?AVMat@2@H@Z
	DD	FLAT:?getMatVector@_InputArray@cv@@UBEXAAV?$vector@VMat@cv@@V?$allocator@VMat@cv@@@std@@@std@@@Z
	DD	FLAT:?getGlBuffer@_InputArray@cv@@UBE?AVGlBuffer@2@XZ
	DD	FLAT:?getGlTexture@_InputArray@cv@@UBE?AVGlTexture@2@XZ
	DD	FLAT:?getGpuMat@_InputArray@cv@@UBE?AVGpuMat@gpu@2@XZ
	DD	FLAT:?kind@_InputArray@cv@@UBEHXZ
	DD	FLAT:?size@_InputArray@cv@@UBE?AV?$Size_@H@2@H@Z
	DD	FLAT:?total@_InputArray@cv@@UBEIH@Z
	DD	FLAT:?type@_InputArray@cv@@UBEHH@Z
	DD	FLAT:?depth@_InputArray@cv@@UBEHH@Z
	DD	FLAT:?channels@_InputArray@cv@@UBEHH@Z
	DD	FLAT:?empty@_InputArray@cv@@UBE_NXZ
	DD	FLAT:?fixedSize@_OutputArray@cv@@UBE_NXZ
	DD	FLAT:?fixedType@_OutputArray@cv@@UBE_NXZ
	DD	FLAT:?needed@_OutputArray@cv@@UBE_NXZ
	DD	FLAT:?getMatRef@_OutputArray@cv@@UBEAAVMat@2@H@Z
	DD	FLAT:?create@_OutputArray@cv@@UBEXHPBHHH_NH@Z
	DD	FLAT:?create@_OutputArray@cv@@UBEXHHHH_NH@Z
	DD	FLAT:?create@_OutputArray@cv@@UBEXV?$Size_@H@2@HH_NH@Z
	DD	FLAT:?release@_OutputArray@cv@@UBEXXZ
	DD	FLAT:?clear@_OutputArray@cv@@UBEXXZ
CONST	ENDS
;	COMDAT ??_R4_OutputArray@cv@@6B@
rdata$r	SEGMENT
??_R4_OutputArray@cv@@6B@ DD 00H			; cv::_OutputArray::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_OutputArray@cv@@@8
	DD	FLAT:??_R3_OutputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R3_OutputArray@cv@@8
rdata$r	SEGMENT
??_R3_OutputArray@cv@@8 DD 00H				; cv::_OutputArray::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_OutputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R2_OutputArray@cv@@8
rdata$r	SEGMENT
??_R2_OutputArray@cv@@8 DD FLAT:??_R1A@?0A@EA@_OutputArray@cv@@8 ; cv::_OutputArray::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_InputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_OutputArray@cv@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_OutputArray@cv@@8 DD FLAT:??_R0?AV_OutputArray@cv@@@8 ; cv::_OutputArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_OutputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_OutputArray@cv@@@8
_DATA	SEGMENT
??_R0?AV_OutputArray@cv@@@8 DD FLAT:??_7type_info@@6B@	; cv::_OutputArray `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_OutputArray@cv@@', 00H
_DATA	ENDS
;	COMDAT ??_7_InputArray@cv@@6B@
CONST	SEGMENT
??_7_InputArray@cv@@6B@ DD FLAT:??_R4_InputArray@cv@@6B@ ; cv::_InputArray::`vftable'
	DD	FLAT:?getMat@_InputArray@cv@@UBE?AVMat@2@H@Z
	DD	FLAT:?getMatVector@_InputArray@cv@@UBEXAAV?$vector@VMat@cv@@V?$allocator@VMat@cv@@@std@@@std@@@Z
	DD	FLAT:?getGlBuffer@_InputArray@cv@@UBE?AVGlBuffer@2@XZ
	DD	FLAT:?getGlTexture@_InputArray@cv@@UBE?AVGlTexture@2@XZ
	DD	FLAT:?getGpuMat@_InputArray@cv@@UBE?AVGpuMat@gpu@2@XZ
	DD	FLAT:?kind@_InputArray@cv@@UBEHXZ
	DD	FLAT:?size@_InputArray@cv@@UBE?AV?$Size_@H@2@H@Z
	DD	FLAT:?total@_InputArray@cv@@UBEIH@Z
	DD	FLAT:?type@_InputArray@cv@@UBEHH@Z
	DD	FLAT:?depth@_InputArray@cv@@UBEHH@Z
	DD	FLAT:?channels@_InputArray@cv@@UBEHH@Z
	DD	FLAT:?empty@_InputArray@cv@@UBE_NXZ
CONST	ENDS
;	COMDAT ??_R4_InputArray@cv@@6B@
rdata$r	SEGMENT
??_R4_InputArray@cv@@6B@ DD 00H				; cv::_InputArray::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_InputArray@cv@@@8
	DD	FLAT:??_R3_InputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R3_InputArray@cv@@8
rdata$r	SEGMENT
??_R3_InputArray@cv@@8 DD 00H				; cv::_InputArray::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_InputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R2_InputArray@cv@@8
rdata$r	SEGMENT
??_R2_InputArray@cv@@8 DD FLAT:??_R1A@?0A@EA@_InputArray@cv@@8 ; cv::_InputArray::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_InputArray@cv@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_InputArray@cv@@8 DD FLAT:??_R0?AV_InputArray@cv@@@8 ; cv::_InputArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_InputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_InputArray@cv@@@8
_DATA	SEGMENT
??_R0?AV_InputArray@cv@@@8 DD FLAT:??_7type_info@@6B@	; cv::_InputArray `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_InputArray@cv@@', 00H
_DATA	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	050H
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	060H
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	060H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
_DATA	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
_DATA	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HB
CONST	SEGMENT
?_Stz@?$fpos@H@std@@0HB DD 00H				; std::fpos<int>::_Stz
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HGDFHEIC@Axis?5value?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@HGDFHEIC@Axis?5value?5?$DN?5?$CFd?6?$AA@ DB 'Axis value = %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OOLANKBA@classifier_disable?4xml?$AA@
CONST	SEGMENT
??_C@_0BH@OOLANKBA@classifier_disable?4xml?$AA@ DB 'classifier_disable.xm'
	DB	'l', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GANHPLLF@classifier_enable?4xml?$AA@
CONST	SEGMENT
??_C@_0BG@GANHPLLF@classifier_enable?4xml?$AA@ DB 'classifier_enable.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ENPJBMMB@Detecting?5?4?4?4?$AA@
CONST	SEGMENT
??_C@_0O@ENPJBMMB@Detecting?5?4?4?4?$AA@ DB 'Detecting ...', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_DATA	ENDS
;	COMDAT ??$_Destroy@V?$Point_@H@cv@@@std@@YAXPAV?$Point_@H@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@V?$Point_@H@cv@@@std@@YAXPAV?$Point_@H@cv@@@Z PROC ; std::_Destroy<cv::Point_<int> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@V?$Point_@H@cv@@@std@@YAXPAV?$Point_@H@cv@@@Z ENDP ; std::_Destroy<cv::Point_<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$Point_@H@cv@@@std@@QAEXPAV?$Point_@H@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@V?$Point_@H@cv@@@std@@QAEXPAV?$Point_@H@cv@@@Z PROC ; std::allocator<cv::Point_<int> >::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@V?$Point_@H@cv@@@std@@QAEXPAV?$Point_@H@cv@@@Z ENDP ; std::allocator<cv::Point_<int> >::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@V?$Point_@H@cv@@@std@@V?$Point_@H@cv@@@std@@YAXAAV?$allocator@V?$Point_@H@cv@@@0@PAV?$Point_@H@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@V?$Point_@H@cv@@@std@@V?$Point_@H@cv@@@std@@YAXAAV?$allocator@V?$Point_@H@cv@@@0@PAV?$Point_@H@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::Point_<int> >,cv::Point_<int> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@V?$Point_@H@cv@@@std@@V?$Point_@H@cv@@@std@@YAXAAV?$allocator@V?$Point_@H@cv@@@0@PAV?$Point_@H@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::Point_<int> >,cv::Point_<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Point_@H@cv@@@std@@@std@@YAXPAV?$Point_@H@cv@@0AAV?$allocator@V?$Point_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@V?$Point_@H@cv@@@std@@@std@@YAXPAV?$Point_@H@cv@@0AAV?$allocator@V?$Point_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::Point_<int> > >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Point_@H@cv@@@std@@@std@@YAXPAV?$Point_@H@cv@@0AAV?$allocator@V?$Point_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::Point_<int> > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$Point_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Point_@H@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$Point_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Point_@H@cv@@0@Z PROC ; std::_Ptr_cat<cv::Point_<int>,cv::Point_<int> >, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$Point_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Point_@H@cv@@0@Z ENDP ; std::_Ptr_cat<cv::Point_<int>,cv::Point_<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Point_@H@cv@@@std@@@std@@YAXPAV?$Point_@H@cv@@0AAV?$allocator@V?$Point_@H@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@V?$Point_@H@cv@@@std@@@std@@YAXPAV?$Point_@H@cv@@0AAV?$allocator@V?$Point_@H@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::Point_<int> > >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Point_@H@cv@@@std@@@std@@YAXPAV?$Point_@H@cv@@0AAV?$allocator@V?$Point_@H@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::Point_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@M@std@@YAXPAM@Z
_TEXT	SEGMENT
??$_Destroy@M@std@@YAXPAM@Z PROC			; std::_Destroy<float>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@M@std@@YAXPAM@Z ENDP			; std::_Destroy<float>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@H@std@@YAXPAH@Z
_TEXT	SEGMENT
??$_Destroy@H@std@@YAXPAH@Z PROC			; std::_Destroy<int>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@H@std@@YAXPAH@Z ENDP			; std::_Destroy<int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABM@std@@YAABMABM@Z
_TEXT	SEGMENT
??$forward@ABM@std@@YAABMABM@Z PROC			; std::forward<float const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABM@std@@YAABMABM@Z ENDP			; std::forward<float const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABUDTreeNode@Data@CascadeClassifier@cv@@@std@@YAABUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$forward@ABUDTreeNode@Data@CascadeClassifier@cv@@@std@@YAABUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::forward<cv::CascadeClassifier::Data::DTreeNode const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABUDTreeNode@Data@CascadeClassifier@cv@@@std@@YAABUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::forward<cv::CascadeClassifier::Data::DTreeNode const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABUDTree@Data@CascadeClassifier@cv@@@std@@YAABUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$forward@ABUDTree@Data@CascadeClassifier@cv@@@std@@YAABUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::forward<cv::CascadeClassifier::Data::DTree const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABUDTree@Data@CascadeClassifier@cv@@@std@@YAABUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::forward<cv::CascadeClassifier::Data::DTree const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABUStage@Data@CascadeClassifier@cv@@@std@@YAABUStage@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$forward@ABUStage@Data@CascadeClassifier@cv@@@std@@YAABUStage@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::forward<cv::CascadeClassifier::Data::Stage const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABUStage@Data@CascadeClassifier@cv@@@std@@YAABUStage@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::forward<cv::CascadeClassifier::Data::Stage const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

	ret	0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$Point_@H@cv@@@std@@QAEXPAV?$Point_@H@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V?$Point_@H@cv@@@std@@QAEXPAV?$Point_@H@cv@@I@Z PROC ; std::allocator<cv::Point_<int> >::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@V?$Point_@H@cv@@@std@@QAEXPAV?$Point_@H@cv@@I@Z ENDP ; std::allocator<cv::Point_<int> >::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@IAEXPAV?$Point_@H@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@IAEXPAV?$Point_@H@cv@@0@Z PROC ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@IAEXPAV?$Point_@H@cv@@0@Z ENDP ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::Point_<int>,std::allocator<cv::Point_<int> > >::~_Vector_val<cv::Point_<int>,std::allocator<cv::Point_<int> > >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::Point_<int>,std::allocator<cv::Point_<int> > >::~_Vector_val<cv::Point_<int>,std::allocator<cv::Point_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::~vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::~vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@M@std@@QAEXPAM@Z
_TEXT	SEGMENT
?destroy@?$allocator@M@std@@QAEXPAM@Z PROC		; std::allocator<float>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@M@std@@QAEXPAM@Z ENDP		; std::allocator<float>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@H@std@@QAEXPAH@Z
_TEXT	SEGMENT
?destroy@?$allocator@H@std@@QAEXPAH@Z PROC		; std::allocator<int>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@H@std@@QAEXPAH@Z ENDP		; std::allocator<int>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAEPAXI@Z PROC ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@scalar
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN11@scalar:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	eax, esi
	ret	0
??_G?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QAEPAXI@Z ENDP ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$Vec@H$03@cv@@@std@@YAXPAV?$Vec@H$03@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@V?$Vec@H$03@cv@@@std@@YAXPAV?$Vec@H$03@cv@@@Z PROC ; std::_Destroy<cv::Vec<int,4> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@V?$Vec@H$03@cv@@@std@@YAXPAV?$Vec@H$03@cv@@@Z ENDP ; std::_Destroy<cv::Vec<int,4> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@@Z PROC ; std::_Destroy<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >, COMDAT
; __Ptr$ = esi

; 63   : 	_Ptr->~_Ty();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@Destroy
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN13@Destroy:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 64   : 	}

	ret	0
??$_Destroy@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@@Z ENDP ; std::_Destroy<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$Rect_@H@cv@@@std@@YAXPAV?$Rect_@H@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@V?$Rect_@H@cv@@@std@@YAXPAV?$Rect_@H@cv@@@Z PROC ; std::_Destroy<cv::Rect_<int> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@V?$Rect_@H@cv@@@std@@YAXPAV?$Rect_@H@cv@@@Z ENDP ; std::_Destroy<cv::Rect_<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z PROC ; std::_Destroy<cv::CascadeClassifier::Data::DTreeNode>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Destroy<cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UDTree@Data@CascadeClassifier@cv@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@UDTree@Data@CascadeClassifier@cv@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@@Z PROC ; std::_Destroy<cv::CascadeClassifier::Data::DTree>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@UDTree@Data@CascadeClassifier@cv@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Destroy<cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UStage@Data@CascadeClassifier@cv@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Destroy@UStage@Data@CascadeClassifier@cv@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@@Z PROC ; std::_Destroy<cv::CascadeClassifier::Data::Stage>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@UStage@Data@CascadeClassifier@cv@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Destroy<cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@M@std@@M@std@@YAXAAV?$allocator@M@0@PAM@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@M@std@@M@std@@YAXAAV?$allocator@M@0@PAM@Z PROC ; std::_Dest_val<std::allocator<float>,float>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@M@std@@M@std@@YAXAAV?$allocator@M@0@PAM@Z ENDP ; std::_Dest_val<std::allocator<float>,float>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z PROC ; std::_Dest_val<std::allocator<int>,int>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z ENDP ; std::_Dest_val<std::allocator<int>,int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEABMXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEABMXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QBEABMXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 16			; 00000010H

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTreeNode@Data@CascadeClassifier@cv@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTreeNode@Data@CascadeClassifier@cv@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTreeNode@Data@CascadeClassifier@cv@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTree@Data@CascadeClassifier@cv@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTree@Data@CascadeClassifier@cv@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUDTree@Data@CascadeClassifier@cv@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUStage@Data@CascadeClassifier@cv@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUStage@Data@CascadeClassifier@cv@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QBEABUStage@Data@CascadeClassifier@cv@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator++, COMDAT
; _this$ = eax

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

	add	DWORD PTR [eax], 4

; 111  : 		return (*this);
; 112  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator*, COMDAT
; _this$ = eax

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 85   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator*
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$Vec@H$03@cv@@@std@@QAEXPAV?$Vec@H$03@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@V?$Vec@H$03@cv@@@std@@QAEXPAV?$Vec@H$03@cv@@@Z PROC ; std::allocator<cv::Vec<int,4> >::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@V?$Vec@H$03@cv@@@std@@QAEXPAV?$Vec@H$03@cv@@@Z ENDP ; std::allocator<cv::Vec<int,4> >::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@@Z PROC ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::destroy, COMDAT
; __Ptr$ = esi

; 213  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN15@destroy
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN15@destroy:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 214  : 		}

	ret	0
?destroy@?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@@Z ENDP ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@@Z PROC ; std::allocator<cv::Rect_<int> >::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@@Z ENDP ; std::allocator<cv::Rect_<int> >::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

	ret	0
?destroy@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@V?$Vec@H$03@cv@@@std@@V?$Vec@H$03@cv@@@std@@YAXAAV?$allocator@V?$Vec@H$03@cv@@@0@PAV?$Vec@H$03@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@V?$Vec@H$03@cv@@@std@@V?$Vec@H$03@cv@@@std@@YAXAAV?$allocator@V?$Vec@H$03@cv@@@0@PAV?$Vec@H$03@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::Vec<int,4> >,cv::Vec<int,4> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@V?$Vec@H$03@cv@@@std@@V?$Vec@H$03@cv@@@std@@YAXAAV?$allocator@V?$Vec@H$03@cv@@@0@PAV?$Vec@H$03@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::Vec<int,4> >,cv::Vec<int,4> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@@std@@YAXAAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@PAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@@std@@YAXAAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@PAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >,std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >, COMDAT
; __Pdest$ = esi

; 287  : 	_Alval.destroy(_Pdest);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@Dest_val
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN17@Dest_val:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@@std@@YAXAAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@PAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >,std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@V?$Rect_@H@cv@@@std@@V?$Rect_@H@cv@@@std@@YAXAAV?$allocator@V?$Rect_@H@cv@@@0@PAV?$Rect_@H@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@V?$Rect_@H@cv@@@std@@V?$Rect_@H@cv@@@std@@YAXAAV?$allocator@V?$Rect_@H@cv@@@0@PAV?$Rect_@H@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::Rect_<int> >,cv::Rect_<int> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@V?$Rect_@H@cv@@@std@@V?$Rect_@H@cv@@@std@@YAXAAV?$allocator@V?$Rect_@H@cv@@@0@PAV?$Rect_@H@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::Rect_<int> >,cv::Rect_<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@@Z PROC ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Dest_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAM@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@AAPAM@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAM@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@AAPAM@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAM@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@AAPAM@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTreeNode@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTreeNode@Data@CascadeClassifier@cv@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTreeNode@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTree@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTree@Data@CascadeClassifier@cv@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUDTree@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUStage@Data@CascadeClassifier@cv@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUStage@Data@CascadeClassifier@cv@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@AAPAUStage@Data@CascadeClassifier@cv@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@AAPAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@AAPAH@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	push	ecx

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 488  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@AAPAH@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *>
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
_TEXT	ENDS
;	COMDAT ?delete_obj@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?delete_obj@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::delete_obj, COMDAT
; _this$ = eax

; 2614 :     if( obj ) delete obj;

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@delete_obj
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN4@delete_obj:

; 2615 : }

	ret	0
?delete_obj@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::delete_obj
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?delete_obj@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?delete_obj@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ PROC ; cv::Ptr<cv::FeatureEvaluator>::delete_obj, COMDAT
; _this$ = eax

; 2614 :     if( obj ) delete obj;

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@delete_obj@2
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax
$LN4@delete_obj@2:

; 2615 : }

	ret	0
?delete_obj@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ENDP ; cv::Ptr<cv::FeatureEvaluator>::delete_obj
_TEXT	ENDS
PUBLIC	__real@0000000000000000
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0?$Matx@N$03$00@cv@@QAE@XZ
_TEXT	SEGMENT
??0?$Matx@N$03$00@cv@@QAE@XZ PROC			; cv::Matx<double,4,1>::Matx<double,4,1>, COMDAT
; _this$ = eax

; 208  :     for(int i = 0; i < channels; i++) val[i] = _Tp(0);

	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]

; 209  : }

	ret	0
??0?$Matx@N$03$00@cv@@QAE@XZ ENDP			; cv::Matx<double,4,1>::Matx<double,4,1>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat, COMDAT

; 253  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 204  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setne	al

; 209  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@YAXPAV?$Vec@H$03@cv@@0AAV?$allocator@V?$Vec@H$03@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@YAXPAV?$Vec@H$03@cv@@0AAV?$allocator@V?$Vec@H$03@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::Vec<int,4> > >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@YAXPAV?$Vec@H$03@cv@@0AAV?$allocator@V?$Vec@H$03@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::Vec<int,4> > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$Vec@H$03@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Vec@H$03@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$Vec@H$03@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Vec@H$03@cv@@0@Z PROC ; std::_Ptr_cat<cv::Vec<int,4>,cv::Vec<int,4> >, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$Vec@H$03@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Vec@H$03@cv@@0@Z ENDP ; std::_Ptr_cat<cv::Vec<int,4>,cv::Vec<int,4> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0AAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0AAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >, COMDAT
; __First$ = eax
; __Last$ = ebx

; 95   : 	{	// destroy [_First, _Last), arbitrary type

	push	esi
	mov	esi, eax

; 96   : 	for (; _First != _Last; ++_First)

	cmp	esi, ebx
	je	SHORT $LN1@Destroy_ra
	push	edi
	xor	edi, edi
	npad	6
$LL3@Destroy_ra:

; 97   : 		_Dest_val(_Al, _First);

	mov	eax, DWORD PTR [esi]
	cmp	eax, edi
	je	SHORT $LN22@Destroy_ra
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN22@Destroy_ra:
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	add	esi, 16					; 00000010H
	cmp	esi, ebx
	jne	SHORT $LL3@Destroy_ra
	pop	edi
$LN1@Destroy_ra:
	pop	esi

; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0AAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$Rect_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Rect_@H@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$Rect_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Rect_@H@cv@@0@Z PROC ; std::_Ptr_cat<cv::Rect_<int>,cv::Rect_<int> >, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$Rect_@H@cv@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$Rect_@H@cv@@0@Z ENDP ; std::_Ptr_cat<cv::Rect_<int>,cv::Rect_<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 105  : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z PROC ; std::_Ptr_cat<float,float>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z ENDP ; std::_Ptr_cat<float,float>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UDTreeNode@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTreeNode@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@UDTreeNode@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTreeNode@Data@CascadeClassifier@cv@@0@Z PROC ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@UDTreeNode@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTreeNode@Data@CascadeClassifier@cv@@0@Z ENDP ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UDTree@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTree@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@UDTree@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTree@Data@CascadeClassifier@cv@@0@Z PROC ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@UDTree@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDTree@Data@CascadeClassifier@cv@@0@Z ENDP ; std::_Ptr_cat<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UStage@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUStage@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@UStage@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUStage@Data@CascadeClassifier@cv@@0@Z PROC ; std::_Ptr_cat<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@UStage@Data@CascadeClassifier@cv@@U1234@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUStage@Data@CascadeClassifier@cv@@0@Z ENDP ; std::_Ptr_cat<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 105  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z PROC ; std::_Ptr_cat<int,int>, COMDAT

; 516  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ENDP ; std::_Ptr_cat<int,int>
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
_TEXT	ENDS
;	COMDAT ?release@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?release@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::release, COMDAT
; _this$ = esi

; 2603 :     if( refcount && CV_XADD(refcount, -1) == 1 )

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN10@release
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN10@release

; 2604 :     {
; 2605 :         delete_obj();

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@release
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN7@release:

; 2606 :         fastFree(refcount);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN10@release:

; 2607 :     }
; 2608 :     refcount = 0;

	mov	DWORD PTR [esi+4], 0

; 2609 :     obj = 0;

	mov	DWORD PTR [esi], 0

; 2610 : }

	ret	0
?release@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?addref@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?addref@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::addref, COMDAT
; _this$ = eax

; 2599 : { if( refcount ) CV_XADD(refcount, 1); }

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN1@addref
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN1@addref:
	ret	0
?addref@?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAEXXZ ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::addref
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?release@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?release@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ PROC	; cv::Ptr<cv::FeatureEvaluator>::release, COMDAT
; _this$ = esi

; 2603 :     if( refcount && CV_XADD(refcount, -1) == 1 )

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN10@release@2
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN10@release@2

; 2604 :     {
; 2605 :         delete_obj();

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@release@2
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN7@release@2:

; 2606 :         fastFree(refcount);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN10@release@2:

; 2607 :     }
; 2608 :     refcount = 0;

	mov	DWORD PTR [esi+4], 0

; 2609 :     obj = 0;

	mov	DWORD PTR [esi], 0

; 2610 : }

	ret	0
?release@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ENDP	; cv::Ptr<cv::FeatureEvaluator>::release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?addref@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ
_TEXT	SEGMENT
?addref@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ PROC	; cv::Ptr<cv::FeatureEvaluator>::addref, COMDAT
; _this$ = eax

; 2599 : { if( refcount ) CV_XADD(refcount, 1); }

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN1@addref@2
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN1@addref@2:
	ret	0
?addref@?$Ptr@VFeatureEvaluator@cv@@@cv@@QAEXXZ ENDP	; cv::Ptr<cv::FeatureEvaluator>::addref
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?release@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ
_TEXT	SEGMENT
?release@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ PROC ; cv::Ptr<CvHaarClassifierCascade>::release, COMDAT
; _this$ = esi

; 2603 :     if( refcount && CV_XADD(refcount, -1) == 1 )

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN5@release@3
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN5@release@3

; 2604 :     {
; 2605 :         delete_obj();

	mov	ecx, esi
	call	DWORD PTR __imp_?delete_obj@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ

; 2606 :         fastFree(refcount);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN5@release@3:

; 2607 :     }
; 2608 :     refcount = 0;

	mov	DWORD PTR [esi+4], 0

; 2609 :     obj = 0;

	mov	DWORD PTR [esi], 0

; 2610 : }

	ret	0
?release@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ ENDP ; cv::Ptr<CvHaarClassifierCascade>::release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?addref@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ
_TEXT	SEGMENT
?addref@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ PROC ; cv::Ptr<CvHaarClassifierCascade>::addref, COMDAT
; _this$ = eax

; 2599 : { if( refcount ) CV_XADD(refcount, 1); }

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN1@addref@3
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN1@addref@3:
	ret	0
?addref@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ ENDP ; cv::Ptr<CvHaarClassifierCascade>::addref
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Vec@N$03@cv@@QAE@XZ
_TEXT	SEGMENT
??0?$Vec@N$03@cv@@QAE@XZ PROC				; cv::Vec<double,4>::Vec<double,4>, COMDAT
; _this$ = eax

; 1138 : {}

	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	ret	0
??0?$Vec@N$03@cv@@QAE@XZ ENDP				; cv::Vec<double,4>::Vec<double,4>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBEABV?$Point_@H@cv@@I@Z
_TEXT	SEGMENT
??A?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBEABV?$Point_@H@cv@@I@Z PROC ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::operator[], COMDAT
; _this$ = eax

; 913  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 914  : 		if (size() <= _Pos)
; 915  : 			{	// report error
; 916  : 			_DEBUG_ERROR("vector subscript out of range");
; 917  : 			_SCL_SECURE_OUT_OF_RANGE;
; 918  : 			}
; 919  : 
; 920  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 921  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 922  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 923  : 
; 924  : 		return (*(this->_Myfirst + _Pos));

	mov	eax, DWORD PTR [eax]

; 925  : 		}

	ret	0
??A?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBEABV?$Point_@H@cv@@I@Z ENDP ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBE_NXZ PROC ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::empty, COMDAT
; _this$ = eax

; 889  : 		return (this->_Myfirst == this->_Mylast);

	mov	ecx, DWORD PTR [eax]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	sete	al

; 890  : 		}

	ret	0
?empty@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBE_NXZ ENDP ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 880  : 		}

	ret	0
?size@?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@YAXPAV?$Vec@H$03@cv@@0AAV?$allocator@V?$Vec@H$03@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@YAXPAV?$Vec@H$03@cv@@0AAV?$allocator@V?$Vec@H$03@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::Vec<int,4> > >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@YAXPAV?$Vec@H$03@cv@@0AAV?$allocator@V?$Vec@H$03@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::Vec<int,4> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0AAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0AAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >, COMDAT
; __First$ = eax
; __Last$ = ebx

; 87   : 	{	// destroy [_First, _Last)

	push	esi
	mov	esi, eax

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	cmp	esi, ebx
	je	SHORT $LN5@Destroy_ra@2
	push	edi
	xor	edi, edi
	npad	6
$LL7@Destroy_ra@2:
	mov	eax, DWORD PTR [esi]
	cmp	eax, edi
	je	SHORT $LN26@Destroy_ra@2
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN26@Destroy_ra@2:
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	add	esi, 16					; 00000010H
	cmp	esi, ebx
	jne	SHORT $LL7@Destroy_ra@2
	pop	edi
$LN5@Destroy_ra@2:
	pop	esi

; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@@std@@YAXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@0@0AAV?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@YAXPAV?$Rect_@H@cv@@0AAV?$allocator@V?$Rect_@H@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@0AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@0AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
_TEXT	ENDS
;	COMDAT ??A?$Vec@H$03@cv@@QAEAAHH@Z
_TEXT	SEGMENT
??A?$Vec@H$03@cv@@QAEAAHH@Z PROC			; cv::Vec<int,4>::operator[], COMDAT
; _this$ = eax

; 1285 :     CV_DbgAssert( (unsigned)i < (unsigned)cn );
; 1286 :     return this->val[i];
; 1287 : }

	ret	0
??A?$Vec@H$03@cv@@QAEAAHH@Z ENDP			; cv::Vec<int,4>::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@XZ
_TEXT	SEGMENT
??1?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@XZ PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::~Ptr<cv::CascadeClassifier::MaskGenerator>, COMDAT
; _this$ = esi

; 2617 : template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@Ptr
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN12@Ptr
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN9@Ptr
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN9@Ptr:
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN12@Ptr:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	ret	0
??1?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@XZ ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::~Ptr<cv::CascadeClassifier::MaskGenerator>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@ABV01@@Z PROC ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::Ptr<cv::CascadeClassifier::MaskGenerator>, COMDAT
; _this$ = esi
; __ptr$ = eax

; 2621 :     obj = _ptr.obj;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx

; 2622 :     refcount = _ptr.refcount;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax

; 2623 :     addref();

	test	eax, eax
	je	SHORT $LN6@Ptr@2
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN6@Ptr@2:

; 2624 : }

	mov	eax, esi
	ret	0
??0?$Ptr@VMaskGenerator@CascadeClassifier@cv@@@cv@@QAE@ABV01@@Z ENDP ; cv::Ptr<cv::CascadeClassifier::MaskGenerator>::Ptr<cv::CascadeClassifier::MaskGenerator>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ
_TEXT	SEGMENT
??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ PROC		; cv::Ptr<cv::FeatureEvaluator>::~Ptr<cv::FeatureEvaluator>, COMDAT
; _this$ = esi

; 2617 : template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@Ptr@3
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN12@Ptr@3
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN9@Ptr@3
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx
$LN9@Ptr@3:
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN12@Ptr@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	ret	0
??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ ENDP		; cv::Ptr<cv::FeatureEvaluator>::~Ptr<cv::FeatureEvaluator>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@ABV01@@Z PROC	; cv::Ptr<cv::FeatureEvaluator>::Ptr<cv::FeatureEvaluator>, COMDAT
; _this$ = esi
; __ptr$ = eax

; 2621 :     obj = _ptr.obj;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx

; 2622 :     refcount = _ptr.refcount;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax

; 2623 :     addref();

	test	eax, eax
	je	SHORT $LN6@Ptr@4
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN6@Ptr@4:

; 2624 : }

	mov	eax, esi
	ret	0
??0?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@ABV01@@Z ENDP	; cv::Ptr<cv::FeatureEvaluator>::Ptr<cv::FeatureEvaluator>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ
_TEXT	SEGMENT
??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ PROC	; cv::Ptr<CvHaarClassifierCascade>::~Ptr<CvHaarClassifierCascade>, COMDAT
; _this$ = esi

; 2617 : template<typename _Tp> inline Ptr<_Tp>::~Ptr() { release(); }

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN7@Ptr@5
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN7@Ptr@5
	mov	ecx, esi
	call	DWORD PTR __imp_?delete_obj@?$Ptr@UCvHaarClassifierCascade@@@cv@@QAEXXZ
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN7@Ptr@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	ret	0
??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ ENDP	; cv::Ptr<CvHaarClassifierCascade>::~Ptr<CvHaarClassifierCascade>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@ABV01@@Z PROC ; cv::Ptr<CvHaarClassifierCascade>::Ptr<CvHaarClassifierCascade>, COMDAT
; _this$ = esi
; __ptr$ = eax

; 2621 :     obj = _ptr.obj;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx

; 2622 :     refcount = _ptr.refcount;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax

; 2623 :     addref();

	test	eax, eax
	je	SHORT $LN6@Ptr@6
	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN6@Ptr@6:

; 2624 : }

	mov	eax, esi
	ret	0
??0?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@ABV01@@Z ENDP ; cv::Ptr<CvHaarClassifierCascade>::Ptr<CvHaarClassifierCascade>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Point_@H@cv@@QAE@XZ
_TEXT	SEGMENT
??0?$Point_@H@cv@@QAE@XZ PROC				; cv::Point_<int>::Point_<int>, COMDAT
; _this$ = eax

; 1620 : template<typename _Tp> inline Point_<_Tp>::Point_() : x(0), y(0) {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$Point_@H@cv@@QAE@XZ ENDP				; cv::Point_<int>::Point_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Point_@H@cv@@QAE@HH@Z
_TEXT	SEGMENT
??0?$Point_@H@cv@@QAE@HH@Z PROC				; cv::Point_<int>::Point_<int>, COMDAT
; _this$ = eax
; __x$ = ecx
; __y$ = edx

; 1621 : template<typename _Tp> inline Point_<_Tp>::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) {}

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	0
??0?$Point_@H@cv@@QAE@HH@Z ENDP				; cv::Point_<int>::Point_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Point_@H@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Point_@H@cv@@QAE@ABV01@@Z PROC			; cv::Point_<int>::Point_<int>, COMDAT
; _this$ = eax
; _pt$ = ecx

; 1622 : template<typename _Tp> inline Point_<_Tp>::Point_(const Point_& pt) : x(pt.x), y(pt.y) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	ret	0
??0?$Point_@H@cv@@QAE@ABV01@@Z ENDP			; cv::Point_<int>::Point_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Scalar_@N@cv@@QAE@NNNN@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 8
_v1$ = 16						; size = 8
_v2$ = 24						; size = 8
_v3$ = 32						; size = 8
??0?$Scalar_@N@cv@@QAE@NNNN@Z PROC			; cv::Scalar_<double>::Scalar_<double>, COMDAT
; _this$ = eax

; 2019 : { this->val[0] = v0; this->val[1] = v1; this->val[2] = v2; this->val[3] = v3; }

	push	ebp
	mov	ebp, esp
	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR _v0$[ebp]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _v1$[ebp]
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR _v2$[ebp]
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR _v3$[ebp]
	fstp	QWORD PTR [eax+24]
	pop	ebp
	ret	32					; 00000020H
??0?$Scalar_@N@cv@@QAE@NNNN@Z ENDP			; cv::Scalar_<double>::Scalar_<double>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Size_@H@cv@@QAE@XZ
_TEXT	SEGMENT
??0?$Size_@H@cv@@QAE@XZ PROC				; cv::Size_<int>::Size_<int>, COMDAT
; _this$ = eax

; 1858 :     : width(0), height(0) {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$Size_@H@cv@@QAE@XZ ENDP				; cv::Size_<int>::Size_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Size_@H@cv@@QAE@HH@Z
_TEXT	SEGMENT
??0?$Size_@H@cv@@QAE@HH@Z PROC				; cv::Size_<int>::Size_<int>, COMDAT
; _this$ = eax
; __width$ = ecx
; __height$ = edx

; 1860 :     : width(_width), height(_height) {}

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	0
??0?$Size_@H@cv@@QAE@HH@Z ENDP				; cv::Size_<int>::Size_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Size_@H@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$Size_@H@cv@@QAE@ABV01@@Z PROC			; cv::Size_<int>::Size_<int>, COMDAT
; _this$ = eax
; _sz$ = ecx

; 1862 :     : width(sz.width), height(sz.height) {}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	ret	0
??0?$Size_@H@cv@@QAE@ABV01@@Z ENDP			; cv::Size_<int>::Size_<int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 220  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@M@std@@QBEIXZ PROC		; std::allocator<float>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 220  : 		}

	ret	0
?max_size@?$allocator@M@std@@QBEIXZ ENDP		; std::allocator<float>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QBEIXZ PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 220  : 		}

	ret	0
?max_size@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QBEIXZ ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QBEIXZ PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 220  : 		}

	ret	0
?max_size@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QBEIXZ ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QBEIXZ PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 220  : 		}

	ret	0
?max_size@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QBEIXZ ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 220  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 2015 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 1516 : 		size_type _Num = this->_Alval.max_size();
; 1517 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1518 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$Vec@H$03@cv@@@std@@QAEXPAV?$Vec@H$03@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V?$Vec@H$03@cv@@@std@@QAEXPAV?$Vec@H$03@cv@@I@Z PROC ; std::allocator<cv::Vec<int,4> >::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@V?$Vec@H$03@cv@@@std@@QAEXPAV?$Vec@H$03@cv@@I@Z ENDP ; std::allocator<cv::Vec<int,4> >::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$Vec@H$03@cv@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$Vec@H$03@cv@@@std@@QAE@ABV01@@Z PROC	; std::allocator<cv::Vec<int,4> >::allocator<cv::Vec<int,4> >, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@V?$Vec@H$03@cv@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<cv::Vec<int,4> >::allocator<cv::Vec<int,4> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@IAEXPAV?$Vec@H$03@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@IAEXPAV?$Vec@H$03@cv@@0@Z PROC ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@IAEXPAV?$Vec@H$03@cv@@0@Z ENDP ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::_Destroy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@I@Z PROC ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@I@Z ENDP ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@0@Z PROC ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Destroy, COMDAT
; __First$ = eax
; __Last$ = ebx

; 1269 : 		{	// destroy [_First, _Last) using allocator

	push	esi
	mov	esi, eax

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

	cmp	esi, ebx
	je	SHORT $LN7@Destroy@2
	push	edi
	xor	edi, edi
	npad	6
$LL9@Destroy@2:
	mov	eax, DWORD PTR [esi]
	cmp	eax, edi
	je	SHORT $LN28@Destroy@2
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN28@Destroy@2:
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	add	esi, 16					; 00000010H
	cmp	esi, ebx
	jne	SHORT $LL9@Destroy@2
	pop	edi
$LN7@Destroy@2:
	pop	esi

; 1271 : 		}

	ret	0
?_Destroy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXPAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@2@0@Z ENDP ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Destroy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@I@Z PROC ; std::allocator<cv::Rect_<int> >::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@V?$Rect_@H@cv@@@std@@QAEXPAV?$Rect_@H@cv@@I@Z ENDP ; std::allocator<cv::Rect_<int> >::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@ABV01@@Z PROC	; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXPAV?$Rect_@H@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXPAV?$Rect_@H@cv@@0@Z PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXPAV?$Rect_@H@cv@@0@Z ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Destroy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@M@std@@QAEXPAMI@Z PROC		; std::allocator<float>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@M@std@@QAEXPAMI@Z ENDP		; std::allocator<float>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ PROC	; std::vector<float,std::allocator<float> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@2:
$LN3@Xlen@2:
	int	3
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ ENDP	; std::vector<float,std::allocator<float> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 885  : 		}

	ret	0
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@3:
$LN3@Xlen@3:
	int	3
?_Xlen@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTreeNode@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTreeNode@Data@CascadeClassifier@cv@@0@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTreeNode@Data@CascadeClassifier@cv@@0@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 885  : 		}

	ret	0
?max_size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@4:
$LN3@Xlen@4:
	int	3
?_Xlen@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTree@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTree@Data@CascadeClassifier@cv@@0@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUDTree@Data@CascadeClassifier@cv@@0@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 885  : 		}

	ret	0
?max_size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@5:
$LN3@Xlen@5:
	int	3
?_Xlen@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IBEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUStage@Data@CascadeClassifier@cv@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUStage@Data@CascadeClassifier@cv@@0@Z PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXPAUStage@Data@CascadeClassifier@cv@@0@Z ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 885  : 		}

	ret	0
?max_size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@6:
$LN3@Xlen@6:
	int	3
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 885  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT

; 2020 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = eax

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN4@Myptr
	mov	eax, DWORD PTR [eax]
$LN4@Myptr:

; 2005 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@H@std@@QBE_JXZ PROC				; std::fpos<int>::operator __int64, COMDAT
; _this$ = ecx

; 65   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	mov	eax, DWORD PTR [ecx+8]
	cdq
	add	eax, DWORD PTR [ecx]
	adc	edx, DWORD PTR [ecx+4]

; 66   : 		}

	ret	0
??B?$fpos@H@std@@QBE_JXZ ENDP				; std::fpos<int>::operator __int64
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@H@std@@QAE@_J@Z PROC				; std::fpos<int>::fpos<int>, COMDAT
; _this$ = eax

; 40   : 		{	// construct with stream offset

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Off$[ebp+4]
	mov	DWORD PTR [eax], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 41   : 		}

	pop	ebp
	ret	8
??0?$fpos@H@std@@QAE@_J@Z ENDP				; std::fpos<int>::fpos<int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$Vec@H$03@cv@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$Vec@H$03@cv@@@std@@QAE@XZ PROC	; std::allocator<cv::Vec<int,4> >::allocator<cv::Vec<int,4> >, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

	ret	0
??0?$allocator@V?$Vec@H$03@cv@@@std@@QAE@XZ ENDP	; std::allocator<cv::Vec<int,4> >::allocator<cv::Vec<int,4> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::~_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::~_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@V?$allocator@V?$Vec@H$03@cv@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@V?$allocator@V?$Vec@H$03@cv@@@1@@Z PROC ; std::_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@V?$allocator@V?$Vec@H$03@cv@@@1@@Z ENDP ; std::_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::_Vector_val<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::_Tidy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

	ret	0
??0?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::~_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::~_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@1@@Z PROC ; std::_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@1@@Z ENDP ; std::_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Vector_val<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Tidy, COMDAT
; _this$ = ebx

; 1301 : 		{	// free all storage

	push	esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	esi, DWORD PTR [ebx]
	xor	ecx, ecx
	cmp	esi, ecx
	je	SHORT $LN37@Tidy@3

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

	push	edi
	mov	edi, DWORD PTR [ebx+4]
	cmp	esi, edi
	je	SHORT $LN12@Tidy@3
$LL14@Tidy@3:
	mov	eax, DWORD PTR [esi]
	cmp	eax, ecx
	je	SHORT $LN33@Tidy@3
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
	xor	ecx, ecx
$LN33@Tidy@3:
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], ecx
	add	esi, 16					; 00000010H
	cmp	esi, edi
	jne	SHORT $LL14@Tidy@3
$LN12@Tidy@3:

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR [ebx]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
	xor	ecx, ecx
	pop	edi
$LN37@Tidy@3:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [ebx], ecx

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [ebx+4], ecx

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [ebx+8], ecx
	pop	esi

; 1312 : 		}

	ret	0
?_Tidy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Tidy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@XZ PROC		; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

	ret	0
??0?$allocator@V?$Rect_@H@cv@@@std@@QAE@XZ ENDP		; std::allocator<cv::Rect_<int> >::allocator<cv::Rect_<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@V?$allocator@V?$Rect_@H@cv@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@V?$allocator@V?$Rect_@H@cv@@@1@@Z PROC ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@V?$allocator@V?$Rect_@H@cv@@@1@@Z ENDP ; std::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Vector_val<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@4

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@4:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::_Tidy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@ABV01@@Z PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@M@std@@QAE@ABV01@@Z ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@V?$allocator@M@1@@Z PROC ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@V?$allocator@M@1@@Z ENDP ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ PROC	; std::vector<float,std::allocator<float> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@5

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@5:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ENDP	; std::vector<float,std::allocator<float> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 880  : 		}

	ret	0
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP	; std::vector<float,std::allocator<float> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocator<cv::CascadeClassifier::Data::DTreeNode>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocator<cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@1@@Z PROC ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@1@@Z ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@6

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@6:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4

; 880  : 		}

	ret	0
?size@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocator<cv::CascadeClassifier::Data::DTree>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocator<cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@1@@Z PROC ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@1@@Z ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@7

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@7:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 880  : 		}

	ret	0
?size@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocator<cv::CascadeClassifier::Data::Stage>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocator<cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UStage@Data@CascadeClassifier@cv@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UStage@Data@CascadeClassifier@cv@@@1@@Z PROC ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@V?$allocator@UStage@Data@CascadeClassifier@cv@@@1@@Z ENDP ; std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@8

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@8:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::size, COMDAT
; _this$ = eax

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 880  : 		}

	ret	0
?size@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT

; 434  : 		}

	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

	mov	DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

	mov	DWORD PTR [eax+8], ecx

; 430  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@9

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@Tidy@9:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

	mov	DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], 0

; 1312 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 880  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT

; 459  : 		}

	ret	0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = eax

; 455  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = eax

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN4@Myptr@2
	mov	eax, DWORD PTR [eax]
$LN4@Myptr@2:

; 2011 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAEAAV?$Vec@H$03@cv@@I@Z
_TEXT	SEGMENT
??A?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAEAAV?$Vec@H$03@cv@@I@Z PROC ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::operator[], COMDAT
; _this$ = ecx
; __Pos$ = eax

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 941  : 		}

	ret	0
??A?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAEAAV?$Vec@H$03@cv@@I@Z ENDP ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4

; 880  : 		}

	ret	0
?size@?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::~vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@2
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@2:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::~vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >, COMDAT
; _this$ = eax

; 507  : 		{	// construct empty vector

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 508  : 		}

	ret	0
??0?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >::vector<cv::Vec<int,4>,std::allocator<cv::Vec<int,4> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAEAAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAEAAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@1@I@Z PROC ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::operator[], COMDAT
; _this$ = ecx
; __Pos$ = eax

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 941  : 		}

	ret	0
??A?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAEAAV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@1@I@Z ENDP ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::~vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >, COMDAT
; _this$ = ebx

; 705  : 		_Tidy();

	jmp	?_Tidy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Tidy
??1?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::~vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >, COMDAT
; _this$ = eax

; 507  : 		{	// construct empty vector

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 508  : 		}

	ret	0
??0?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAEAAV?$Rect_@H@cv@@I@Z
_TEXT	SEGMENT
??A?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAEAAV?$Rect_@H@cv@@I@Z PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::operator[], COMDAT
; _this$ = ecx
; __Pos$ = eax

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 941  : 		}

	ret	0
??A?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAEAAV?$Rect_@H@cv@@I@Z ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QBEIXZ PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4

; 880  : 		}

	ret	0
?size@?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QBEIXZ ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@3
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@3:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >, COMDAT
; _this$ = eax

; 507  : 		{	// construct empty vector

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 508  : 		}

	ret	0
??0?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\sstream
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
tv341 = -12						; size = 4
tv326 = -12						; size = 4
tv333 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT
; _this$ = ecx

; 279  : 		{	// change position to _Pos, according to _Mode

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 280  : 		streamoff _Off = (streamoff)_Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp+8]
	sub	esp, 12					; 0000000cH
	push	ebx
	cdq
	push	esi
	mov	esi, eax
	add	esi, DWORD PTR __Ptr$[ebp]

; 281  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	eax, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax]
	mov	ebx, edx
	adc	ebx, DWORD PTR __Ptr$[ebp+4]
	push	edi
	test	eax, eax
	je	SHORT $LN12@seekpos
	cmp	DWORD PTR [ecx+60], eax
	jae	SHORT $LN12@seekpos

; 282  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	DWORD PTR [ecx+60], eax
$LN12@seekpos:

; 283  : 
; 284  : 		if (_Off == _BADOFF)

	mov	eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR tv333[esp+24], edi
	mov	DWORD PTR tv333[esp+28], eax
	cmp	esi, edi
	jne	SHORT $LN55@seekpos
	cmp	ebx, eax
	je	$LN1@seekpos
$LN55@seekpos:

; 285  : 			;
; 286  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

	test	BYTE PTR __Mode$[ebp], 1
	je	SHORT $LN9@seekpos
	mov	edx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR tv341[esp+24], edx
	test	edx, edx
	je	SHORT $LN9@seekpos

; 287  : 			{	// position within read buffer
; 288  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	ebx, ebx
	jl	$LN4@seekpos
	jg	SHORT $LN56@seekpos
	test	esi, esi
	jb	$LN4@seekpos
$LN56@seekpos:
	mov	eax, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+60]
	sub	eax, edi
	cdq
	cmp	ebx, edx
	jg	$LN61@seekpos
	jl	SHORT $LN57@seekpos
	cmp	esi, eax
	ja	SHORT $LN61@seekpos
$LN57@seekpos:

; 289  : 				{	// change read position
; 290  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	edi, DWORD PTR tv341[esp+24]
	mov	eax, DWORD PTR [ecx+48]
	add	edi, esi
	sub	DWORD PTR [eax], edi
	mov	eax, DWORD PTR [ecx+32]
	add	DWORD PTR [eax], edi

; 291  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	BYTE PTR __Mode$[ebp], 2
	je	SHORT $LN1@seekpos
	mov	edi, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [edi]
	test	edx, edx
	je	SHORT $LN1@seekpos

; 292  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 293  : 						_Mysb::epptr());	// change write position to match

	mov	eax, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	mov	edx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [edi], edx
	mov	ecx, DWORD PTR [ecx+52]
	sub	eax, edx
	mov	DWORD PTR [ecx], eax

; 294  : 				}
; 295  : 			else
; 296  : 				_Off = _BADOFF;

	jmp	SHORT $LN1@seekpos
$LN9@seekpos:

; 297  : 			}
; 298  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	BYTE PTR __Mode$[ebp], 2
	je	SHORT $LN4@seekpos
	mov	edx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR tv326[esp+24], edx
	test	edx, edx
	je	SHORT $LN4@seekpos

; 299  : 			{	// position within write buffer
; 300  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	ebx, ebx
	jl	SHORT $LN4@seekpos
	jg	SHORT $LN58@seekpos
	test	esi, esi
	jb	SHORT $LN4@seekpos
$LN58@seekpos:
	mov	edx, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx+60]
	sub	eax, edi
	cdq
	cmp	ebx, edx
	jg	SHORT $LN61@seekpos
	jl	SHORT $LN59@seekpos
	cmp	esi, eax
	ja	SHORT $LN61@seekpos
$LN59@seekpos:

; 301  : 				_Mysb::pbump((int)(_Mysb::eback()
; 302  : 					- _Mysb::pptr() + _Off));	// change write position

	sub	edi, DWORD PTR tv326[esp+24]
	mov	eax, DWORD PTR [ecx+52]
	add	edi, esi
	sub	DWORD PTR [eax], edi
	mov	ecx, DWORD PTR [ecx+36]
	add	DWORD PTR [ecx], edi

; 303  : 			else

	jmp	SHORT $LN1@seekpos
$LN61@seekpos:
	mov	eax, DWORD PTR tv333[esp+28]
	mov	edi, DWORD PTR tv333[esp+24]
$LN4@seekpos:

; 304  : 				_Off = _BADOFF;
; 305  : 			}
; 306  : 		else
; 307  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

	mov	esi, edi
	mov	ebx, eax
$LN1@seekpos:

; 308  : 		return (streampos(_Off));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 309  : 		}

	pop	edi
	xor	ecx, ecx
	mov	DWORD PTR [eax], esi
	pop	esi
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z
_TEXT	SEGMENT
tv400 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
tv388 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT
; _this$ = ecx

; 226  : 		{	// change position by _Off, according to _Way, _Mode

	push	ebp
	mov	ebp, esp
	push	ecx

; 227  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN21@seekoff
	cmp	DWORD PTR [ecx+60], eax
	jae	SHORT $LN21@seekoff

; 228  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	DWORD PTR [ecx+60], eax
$LN21@seekoff:
	push	ebx

; 229  : 
; 230  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

	mov	bl, BYTE PTR __Which$[ebp]
	push	esi
	push	edi
	test	bl, 1
	je	$LN20@seekoff
	mov	eax, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv400[ebp], eax
	test	eax, eax
	je	$LN20@seekoff

; 231  : 			{	// position within read buffer
; 232  : 			if (_Way == ios_base::end)

	mov	edx, DWORD PTR __Way$[ebp]
	cmp	edx, 2
	jne	SHORT $LN19@seekoff

; 233  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx+60]
	sub	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __Off$[ebp]
	mov	ebx, DWORD PTR __Off$[ebp+4]
	cdq
	add	esi, eax
	adc	ebx, edx

; 234  : 			else if (_Way == ios_base::cur

	jmp	SHORT $LN15@seekoff
$LN19@seekoff:

; 235  : 				&& (_Which & ios_base::out) == 0)

	cmp	edx, 1
	jne	SHORT $LN17@seekoff
	test	bl, 2
	jne	SHORT $LN74@seekoff

; 236  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

	mov	edx, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __Off$[ebp]
	mov	ebx, DWORD PTR __Off$[ebp+4]
	cdq
	add	esi, eax
	adc	ebx, edx
	jmp	SHORT $LN15@seekoff
$LN17@seekoff:

; 237  : 			else if (_Way != ios_base::beg)

	test	edx, edx
	je	SHORT $LN79@seekoff
$LN74@seekoff:

; 238  : 				_Off = _BADOFF;

	mov	eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	jmp	SHORT $LN15@seekoff
$LN79@seekoff:
	mov	ebx, DWORD PTR __Off$[ebp+4]
	mov	esi, DWORD PTR __Off$[ebp]
$LN15@seekoff:

; 239  : 
; 240  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	ebx, ebx
	jl	$LN81@seekoff
	jg	SHORT $LN75@seekoff
	test	esi, esi
	jb	$LN81@seekoff
$LN75@seekoff:
	mov	eax, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+60]
	sub	eax, edi
	cdq
	cmp	ebx, edx
	jg	$LN81@seekoff
	jl	SHORT $LN76@seekoff
	cmp	esi, eax
	ja	$LN81@seekoff
$LN76@seekoff:

; 241  : 				{	// change read position
; 242  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	edi, DWORD PTR tv400[ebp]
	mov	eax, DWORD PTR [ecx+48]
	add	edi, esi
	sub	DWORD PTR [eax], edi
	mov	eax, DWORD PTR [ecx+32]
	add	DWORD PTR [eax], edi

; 243  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	BYTE PTR __Which$[ebp], 2
	je	$LN83@seekoff
	mov	edi, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [edi]
	test	edx, edx
	je	$LN83@seekoff

; 244  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
; 245  : 						_Mysb::epptr());	// change write position to match

	mov	eax, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	mov	edx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [edi], edx
	mov	ecx, DWORD PTR [ecx+52]
	sub	eax, edx
	mov	DWORD PTR [ecx], eax

; 246  : 				}
; 247  : 			else

	jmp	$LN83@seekoff
$LN20@seekoff:

; 248  : 				_Off = _BADOFF;
; 249  : 			}
; 250  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	bl, 2
	je	$LN10@seekoff
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv388[ebp], eax
	test	eax, eax
	je	SHORT $LN10@seekoff

; 251  : 			{	// position within write buffer
; 252  : 			if (_Way == ios_base::end)

	mov	edx, DWORD PTR __Way$[ebp]
	cmp	edx, 2
	jne	SHORT $LN9@seekoff

; 253  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx+60]
	sub	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __Off$[ebp]
	mov	ebx, DWORD PTR __Off$[ebp+4]
	cdq
	add	esi, eax
	adc	ebx, edx
	jmp	SHORT $LN5@seekoff
$LN9@seekoff:

; 254  : 			else if (_Way == ios_base::cur)

	cmp	edx, 1
	jne	SHORT $LN7@seekoff

; 255  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

	mov	edx, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __Off$[ebp]
	mov	ebx, DWORD PTR __Off$[ebp+4]
	cdq
	add	esi, eax
	adc	ebx, edx
	jmp	SHORT $LN5@seekoff
$LN7@seekoff:

; 256  : 			else if (_Way != ios_base::beg)

	test	edx, edx
	je	SHORT $LN80@seekoff

; 257  : 				_Off = _BADOFF;

	mov	eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	jmp	SHORT $LN5@seekoff
$LN80@seekoff:
	mov	ebx, DWORD PTR __Off$[ebp+4]
	mov	esi, DWORD PTR __Off$[ebp]
$LN5@seekoff:

; 258  : 
; 259  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	ebx, ebx
	jl	SHORT $LN81@seekoff
	jg	SHORT $LN77@seekoff
	test	esi, esi
	jb	SHORT $LN81@seekoff
$LN77@seekoff:
	mov	eax, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+60]
	sub	eax, edi
	cdq
	cmp	ebx, edx
	jg	SHORT $LN81@seekoff
	jl	SHORT $LN78@seekoff
	cmp	esi, eax
	ja	SHORT $LN81@seekoff
$LN78@seekoff:

; 260  : 				_Mysb::pbump((int)(_Mysb::eback()
; 261  : 					- _Mysb::pptr() + _Off));	// change write position

	sub	edi, DWORD PTR tv388[ebp]
	mov	eax, DWORD PTR [ecx+52]
	add	edi, esi
	sub	DWORD PTR [eax], edi
	mov	ecx, DWORD PTR [ecx+36]
	add	DWORD PTR [ecx], edi

; 262  : 			else

	jmp	SHORT $LN83@seekoff
$LN10@seekoff:

; 263  : 				_Off = _BADOFF;
; 264  : 			}
; 265  : 
; 266  :  #if _HAS_CPP0X
; 267  : 		else if (_Off != 0)

	mov	esi, DWORD PTR __Off$[ebp]
	mov	ebx, DWORD PTR __Off$[ebp+4]
	mov	ecx, esi
	or	ecx, ebx
	je	SHORT $LN83@seekoff
$LN81@seekoff:

; 268  : 
; 269  :  #else /* _HAS_CPP0X */
; 270  : 		else
; 271  :  #endif /* _HAS_CPP0X */
; 272  : 
; 273  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

	mov	eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
$LN83@seekoff:

; 274  : 		return (pos_type(_Off));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	xor	ecx, ecx
	mov	DWORD PTR [eax], esi
	pop	esi
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	pop	ebx

; 275  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@4
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@4:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@5
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@5:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@6
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@6:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@7
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@7:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@8
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN8@vector@8:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 706  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = eax

; 1511 : 		return (this->_Mysize);

	mov	eax, DWORD PTR [eax+16]

; 1512 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?getHorizontalAxis@RoadTracker@CVDetector@@SANXZ ; CVDetector::RoadTracker::getHorizontalAxis
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
;	COMDAT ?getHorizontalAxis@RoadTracker@CVDetector@@SANXZ
_TEXT	SEGMENT
?getHorizontalAxis@RoadTracker@CVDetector@@SANXZ PROC	; CVDetector::RoadTracker::getHorizontalAxis, COMDAT

; 235  : 			return axisValue;

	fld	QWORD PTR _axisValue

; 236  : 		}

	ret	0
?getHorizontalAxis@RoadTracker@CVDetector@@SANXZ ENDP	; CVDetector::RoadTracker::getHorizontalAxis
_TEXT	ENDS
PUBLIC	?getFoundSign@SignDetector@CVDetector@@SAHXZ	; CVDetector::SignDetector::getFoundSign
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT ?getFoundSign@SignDetector@CVDetector@@SAHXZ
_TEXT	SEGMENT
?getFoundSign@SignDetector@CVDetector@@SAHXZ PROC	; CVDetector::SignDetector::getFoundSign, COMDAT

; 230  : 			return signID;

	fld	QWORD PTR _signID
	jmp	__ftol2_sse
?getFoundSign@SignDetector@CVDetector@@SAHXZ ENDP	; CVDetector::SignDetector::getFoundSign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1Data@CascadeClassifier@cv@@QAE@XZ
_TEXT	SEGMENT
??1Data@CascadeClassifier@cv@@QAE@XZ PROC		; cv::CascadeClassifier::Data::~Data, COMDAT
; _this$ = esi
	mov	eax, DWORD PTR [esi+88]
	push	ebx
	mov	ebx, DWORD PTR __imp_??3@YAXPAX@Z
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN15@Data
	push	eax
	call	ebx
	add	esp, 4
$LN15@Data:
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	mov	DWORD PTR [esi+96], edi
	mov	eax, DWORD PTR [esi+72]
	cmp	eax, edi
	je	SHORT $LN26@Data
	push	eax
	call	ebx
	add	esp, 4
$LN26@Data:
	mov	DWORD PTR [esi+72], edi
	mov	DWORD PTR [esi+76], edi
	mov	DWORD PTR [esi+80], edi
	mov	eax, DWORD PTR [esi+56]
	cmp	eax, edi
	je	SHORT $LN37@Data
	push	eax
	call	ebx
	add	esp, 4
$LN37@Data:
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	eax, DWORD PTR [esi+40]
	cmp	eax, edi
	je	SHORT $LN48@Data
	push	eax
	call	ebx
	add	esp, 4
$LN48@Data:
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	je	SHORT $LN59@Data
	push	eax
	call	ebx
	add	esp, 4
$LN59@Data:
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+32], edi
	pop	edi
	pop	ebx
	ret	0
??1Data@CascadeClassifier@cv@@QAE@XZ ENDP		; cv::CascadeClassifier::Data::~Data
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCascadeClassifier@cv@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCascadeClassifier@cv@@UAEPAXI@Z PROC		; cv::CascadeClassifier::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar@2
	push	esi
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN4@scalar@2:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GCascadeClassifier@cv@@UAEPAXI@Z ENDP		; cv::CascadeClassifier::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
_TEXT	ENDS
;	COMDAT ??0_InputArray@cv@@QAE@ABV?$Scalar_@N@1@@Z
_TEXT	SEGMENT
??0_InputArray@cv@@QAE@ABV?$Scalar_@N@1@@Z PROC		; cv::_InputArray::_InputArray, COMDAT
; _this$ = eax
; _s$ = ecx

; 1140 :     : flags(FIXED_TYPE + FIXED_SIZE + MATX + CV_64F), obj((void*)&s), sz(1, 4) {}

	mov	DWORD PTR [eax], OFFSET ??_7_InputArray@cv@@6B@
	mov	DWORD PTR [eax+4], -1073610746		; c0020006H
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], 1
	mov	DWORD PTR [eax+16], 4
	ret	0
??0_InputArray@cv@@QAE@ABV?$Scalar_@N@1@@Z ENDP		; cv::_InputArray::_InputArray
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??AMStep@Mat@cv@@QAEAAIH@Z
_TEXT	SEGMENT
??AMStep@Mat@cv@@QAEAAIH@Z PROC				; cv::Mat::MStep::operator[], COMDAT
; _this$ = eax
; _i$ = edx

; 741  : inline size_t& Mat::MStep::operator[](int i) { return p[i]; }

	mov	ecx, DWORD PTR [eax]
	lea	eax, DWORD PTR [ecx+edx*4]
	ret	0
??AMStep@Mat@cv@@QAEAAIH@Z ENDP				; cv::Mat::MStep::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??AMStep@Mat@cv@@QBEABIH@Z
_TEXT	SEGMENT
??AMStep@Mat@cv@@QBEABIH@Z PROC				; cv::Mat::MStep::operator[], COMDAT
; _this$ = eax
; _i$ = edx

; 740  : inline const size_t& Mat::MStep::operator[](int i) const { return p[i]; }

	mov	ecx, DWORD PTR [eax]
	lea	eax, DWORD PTR [ecx+edx*4]
	ret	0
??AMStep@Mat@cv@@QBEABIH@Z ENDP				; cv::Mat::MStep::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0MStep@Mat@cv@@QAE@XZ
_TEXT	SEGMENT
??0MStep@Mat@cv@@QAE@XZ PROC				; cv::Mat::MStep::MStep, COMDAT
; _this$ = eax

; 738  : inline Mat::MStep::MStep() { p = buf; p[0] = p[1] = 0; }

	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [ecx+4], 0
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0
	ret	0
??0MStep@Mat@cv@@QAE@XZ ENDP				; cv::Mat::MStep::MStep
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0MSize@Mat@cv@@QAE@PAH@Z
_TEXT	SEGMENT
??0MSize@Mat@cv@@QAE@PAH@Z PROC				; cv::Mat::MSize::MSize, COMDAT
; _this$ = eax
; __p$ = ecx

; 709  : inline Mat::MSize::MSize(int* _p) : p(_p) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0MSize@Mat@cv@@QAE@PAH@Z ENDP				; cv::Mat::MSize::MSize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?type@Mat@cv@@QBEHXZ
_TEXT	SEGMENT
?type@Mat@cv@@QBEHXZ PROC				; cv::Mat::type, COMDAT
; _this$ = eax

; 400  : inline int Mat::type() const { return CV_MAT_TYPE(flags); }

	mov	eax, DWORD PTR [eax]
	and	eax, 4095				; 00000fffH
	ret	0
?type@Mat@cv@@QBEHXZ ENDP				; cv::Mat::type
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?release@Mat@cv@@QAEXXZ
_TEXT	SEGMENT
?release@Mat@cv@@QAEXXZ PROC				; cv::Mat::release, COMDAT
; _this$ = esi

; 366  :     if( refcount && CV_XADD(refcount, -1) == 1 )

	mov	eax, DWORD PTR [esi+20]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN4@release@4
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN4@release@4

; 367  :         deallocate();

	mov	ecx, esi
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN4@release@4:

; 368  :     data = datastart = dataend = datalimit = 0;
; 369  :     for(int i = 0; i < dims; i++)

	xor	eax, eax
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+16], edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN9@release@4
$LL3@release@4:

; 370  :         size.p[i] = 0;

	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [ecx+eax*4], edi
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL3@release@4
$LN9@release@4:

; 371  :     refcount = 0;

	mov	DWORD PTR [esi+20], edi
	pop	edi

; 372  : }

	ret	0
?release@Mat@cv@@QAEXXZ ENDP				; cv::Mat::release
_width	DD	01H DUP (?)
_height	DD	01H DUP (?)
; Function compile flags: /Ogtp
;	COMDAT ?create@Mat@cv@@QAEXHHH@Z
_TEXT	SEGMENT
_sz$ = -8						; size = 8
?create@Mat@cv@@QAEXHHH@Z PROC				; cv::Mat::create, COMDAT
; _this$ = ecx

; 348  : {

	push	ebp
	mov	ebp, esp

; 349  :     _type &= TYPE_MASK;
; 350  :     if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && data )

	mov	eax, DWORD PTR _height
	mov	edx, DWORD PTR _width
	sub	esp, 8
	cmp	DWORD PTR [ecx+4], 2
	jg	SHORT $LN1@create
	cmp	DWORD PTR [ecx+8], eax
	jne	SHORT $LN1@create
	cmp	DWORD PTR [ecx+12], edx
	jne	SHORT $LN1@create
	push	esi
	mov	esi, DWORD PTR [ecx]
	and	esi, 4095				; 00000fffH
	cmp	esi, 24					; 00000018H
	pop	esi
	jne	SHORT $LN1@create
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN2@create
$LN1@create:

; 351  :         return;
; 352  :     int sz[] = {_rows, _cols};

	mov	DWORD PTR _sz$[ebp], eax

; 353  :     create(2, sz, _type);

	push	24					; 00000018H
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	2
	mov	DWORD PTR _sz$[ebp+4], edx
	call	DWORD PTR __imp_?create@Mat@cv@@QAEXHPBHH@Z
$LN2@create:

; 354  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create@Mat@cv@@QAEXHHH@Z ENDP				; cv::Mat::create
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1Mat@cv@@QAE@XZ
_TEXT	SEGMENT
??1Mat@cv@@QAE@XZ PROC					; cv::Mat::~Mat, COMDAT
; _this$ = eax

; 275  : {

	push	esi
	mov	esi, eax

; 276  :     release();

	mov	eax, DWORD PTR [esi+20]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN7@Mat
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN7@Mat
	mov	ecx, esi
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN7@Mat:
	xor	eax, eax
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+16], edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN4@Mat
	npad	7
$LL6@Mat:
	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [ecx+eax*4], edi
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL6@Mat
$LN4@Mat:

; 277  :     if( step.p != step.buf )

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+20], edi
	add	esi, 48					; 00000030H
	pop	edi
	cmp	eax, esi
	pop	esi
	je	SHORT $LN1@Mat

; 278  :         fastFree(step.p);

	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	pop	ecx
$LN1@Mat:

; 279  : }

	ret	0
??1Mat@cv@@QAE@XZ ENDP					; cv::Mat::~Mat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0Mat@cv@@QAE@HHHPAXI@Z
_TEXT	SEGMENT
__rows$ = 8						; size = 4
??0Mat@cv@@QAE@HHHPAXI@Z PROC				; cv::Mat::Mat, COMDAT
; _this$ = eax
; __data$ = ecx

; 133  : {

	push	ebp
	mov	ebp, esp
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+24], ecx
	push	esi
	mov	esi, DWORD PTR __rows$[ebp]
	mov	DWORD PTR [eax+8], esi
	xor	esi, esi
	mov	DWORD PTR [eax+28], esi
	mov	DWORD PTR [eax+32], esi
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+36], esi
	lea	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], 1124007948		; 42ff000cH
	mov	DWORD PTR [eax+12], 1
	mov	DWORD PTR [eax+4], 2
	mov	DWORD PTR [eax+40], edx
	lea	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [ecx+4], esi
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx], esi

; 134  :     size_t esz = CV_ELEM_SIZE(_type), minstep = cols*esz;

	mov	ecx, DWORD PTR [eax+12]

; 135  :     if( _step == AUTO_STEP )
; 136  :     {
; 137  :         _step = minstep;
; 138  :         flags |= CONTINUOUS_FLAG;
; 139  :     }
; 140  :     else
; 141  :     {
; 142  :         if( rows == 1 ) _step = minstep;
; 143  :         CV_DbgAssert( _step >= minstep );
; 144  :         flags |= _step == minstep ? CONTINUOUS_FLAG : 0;
; 145  :     }
; 146  :     step[0] = _step; step[1] = esz;

	mov	esi, DWORD PTR [eax+44]
	or	DWORD PTR [eax], 16384			; 00004000H
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [esi], ecx
	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [esi+4], 8

; 147  :     datalimit = datastart + _step*rows;

	mov	edx, DWORD PTR [edx]
	imul	edx, ecx
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, edx
	mov	DWORD PTR [eax+32], ecx

; 148  :     dataend = datalimit - _step + minstep;

	mov	DWORD PTR [eax+28], ecx
	pop	esi

; 149  : }

	pop	ebp
	ret	4
??0Mat@cv@@QAE@HHHPAXI@Z ENDP				; cv::Mat::Mat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0Mat@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0Mat@cv@@QAE@ABV01@@Z PROC				; cv::Mat::Mat, COMDAT
; _this$ = esi
; _m$ = edi

; 115  : {

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], ecx
	mov	edx, DWORD PTR [edi+16]
	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], edx
	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], ecx
	mov	edx, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], edx
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], edx
	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], ecx
	mov	DWORD PTR [esi+40], eax
	lea	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [eax+4], 0
	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [edx], 0

; 116  :     if( refcount )

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN3@Mat@2

; 117  :         CV_XADD(refcount, 1);

	push	1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
$LN3@Mat@2:

; 118  :     if( m.dims <= 2 )

	cmp	DWORD PTR [edi+4], 2
	jg	SHORT $LN2@Mat@2

; 119  :     {
; 120  :         step[0] = m.step[0]; step[1] = m.step[1];

	mov	eax, DWORD PTR [edi+44]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [edi+44]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [ecx+4], edx

; 126  :     }
; 127  : }

	mov	eax, esi
	ret	0
$LN2@Mat@2:

; 121  :     }
; 122  :     else
; 123  :     {
; 124  :         dims = 0;
; 125  :         copySize(m);

	push	edi
	mov	ecx, esi
	mov	DWORD PTR [esi+4], 0
	call	DWORD PTR __imp_?copySize@Mat@cv@@QAEXABV12@@Z

; 126  :     }
; 127  : }

	mov	eax, esi
	ret	0
??0Mat@cv@@QAE@ABV01@@Z ENDP				; cv::Mat::Mat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?initEmpty@Mat@cv@@IAEXXZ
_TEXT	SEGMENT
?initEmpty@Mat@cv@@IAEXXZ PROC				; cv::Mat::initEmpty, COMDAT
; _this$ = eax

; 60   :     flags = MAGIC_VAL;
; 61   :     dims = rows = cols = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], 1124007936		; 42ff0000H
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+4], ecx

; 62   :     data = datastart = dataend = datalimit = 0;

	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+16], ecx

; 63   :     refcount = 0;

	mov	DWORD PTR [eax+20], ecx

; 64   :     allocator = 0;

	mov	DWORD PTR [eax+36], ecx

; 65   : }

	ret	0
?initEmpty@Mat@cv@@IAEXXZ ENDP				; cv::Mat::initEmpty
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 49   : 		}

	ret	0
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 563  : 		return (EOF);

	or	eax, -1

; 564  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 558  : 		return (_Meta != eof() ? _Meta : !eof());

	xor	eax, eax

; 559  : 		}

	ret	0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = eax
; __Right$ = edx

; 553  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 554  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT
; __Ch$ = eax

; 547  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [eax]

; 548  : 		}

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT
; __Meta$ = eax

; 542  : 		return ((_Elem)_Meta);

	mov	al, BYTE PTR [eax]

; 543  : 		}

	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT
; __Left$ = eax
; __Right$ = edx

; 532  : 		return (_Left == _Right);

	mov	cl, BYTE PTR [eax]
	xor	eax, eax
	cmp	cl, BYTE PTR [edx]
	sete	al

; 533  : 		}

	ret	0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT
; __Left$ = edx
; __Right$ = eax

; 527  : 		_Left = _Right;

	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 528  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT
; __First1$ = edx
; __First2$ = ecx
; __Count$ = eax

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 518  : 		}

	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT
; __First1$ = edx
; __First2$ = ecx
; __Count$ = eax

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 498  : 		}

	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = eax

; 491  : 		return (_CSTD strlen(_First));

	lea	edx, DWORD PTR [eax+1]
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 492  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Where$ = eax

; 57   : 	return (_Where);
; 58   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = -4						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = esi

; 345  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Message$[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

	mov	eax, esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@MABM@std@@YAXPAMABM@Z
_TEXT	SEGMENT
??$_Construct@MABM@std@@YAXPAMABM@Z PROC		; std::_Construct<float,float const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
$LN3@Construct:

; 49   : 	}

	ret	0
??$_Construct@MABM@std@@YAXPAMABM@Z ENDP		; std::_Construct<float,float const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$_Construct@UDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::_Construct<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN3@Construct@2:

; 49   : 	}

	ret	0
??$_Construct@UDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::_Construct<cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UDTree@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$_Construct@UDTree@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::_Construct<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@3:

; 49   : 	}

	ret	0
??$_Construct@UDTree@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUDTree@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::_Construct<cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UStage@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@ABU1234@@Z
_TEXT	SEGMENT
??$_Construct@UStage@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@ABU1234@@Z PROC ; std::_Construct<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Construct@4:

; 49   : 	}

	ret	0
??$_Construct@UStage@Data@CascadeClassifier@cv@@ABU1234@@std@@YAXPAUStage@Data@CascadeClassifier@cv@@ABU1234@@Z ENDP ; std::_Construct<cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@HABH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
??$_Construct@HABH@std@@YAXPAHABH@Z PROC		; std::_Construct<int,int const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	eax, eax
	je	SHORT $LN3@Construct@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@5:

; 49   : 	}

	ret	0
??$_Construct@HABH@std@@YAXPAHABH@Z ENDP		; std::_Construct<int,int const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@M@std@@QAEXPAMABM@Z
_TEXT	SEGMENT
?construct@?$allocator@M@std@@QAEXPAMABM@Z PROC		; std::allocator<float>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
$LN5@construct:

; 198  : 		}

	ret	0
?construct@?$allocator@M@std@@QAEXPAMABM@Z ENDP		; std::allocator<float>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@Z
_TEXT	SEGMENT
?construct@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN5@construct@2:

; 198  : 		}

	ret	0
?construct@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@ABU3456@@Z
_TEXT	SEGMENT
?construct@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@ABU3456@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@3:

; 198  : 		}

	ret	0
?construct@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEXPAUDTree@Data@CascadeClassifier@cv@@ABU3456@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@ABU3456@@Z
_TEXT	SEGMENT
?construct@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@ABU3456@@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN5@construct@4:

; 198  : 		}

	ret	0
?construct@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEXPAUStage@Data@CascadeClassifier@cv@@ABU3456@@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@5:

; 198  : 		}

	ret	0
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@M@std@@MABM@std@@YAXAAV?$allocator@M@0@PAMABM@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@M@std@@MABM@std@@YAXAAV?$allocator@M@0@PAMABM@Z PROC ; std::_Cons_val<std::allocator<float>,float,float const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
$LN9@Cons_val:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@M@std@@MABM@std@@YAXAAV?$allocator@M@0@PAMABM@Z ENDP ; std::_Cons_val<std::allocator<float>,float,float const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@ABU2345@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@ABU2345@@Z PROC ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN9@Cons_val@2:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@UDTreeNode@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@PAUDTreeNode@Data@CascadeClassifier@cv@@ABU2345@@Z ENDP ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTreeNode>,cv::CascadeClassifier::Data::DTreeNode,cv::CascadeClassifier::Data::DTreeNode const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@ABU2345@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@ABU2345@@Z PROC ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val@3
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN9@Cons_val@3:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@UDTree@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@PAUDTree@Data@CascadeClassifier@cv@@ABU2345@@Z ENDP ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::DTree>,cv::CascadeClassifier::Data::DTree,cv::CascadeClassifier::Data::DTree const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@ABU2345@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@ABU2345@@Z PROC ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN9@Cons_val@4:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@UStage@Data@CascadeClassifier@cv@@ABU3456@@std@@YAXAAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@PAUStage@Data@CascadeClassifier@cv@@ABU2345@@Z ENDP ; std::_Cons_val<std::allocator<cv::CascadeClassifier::Data::Stage>,cv::CascadeClassifier::Data::Stage,cv::CascadeClassifier::Data::Stage const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	eax, eax
	je	SHORT $LN9@Cons_val@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN9@Cons_val@5:

; 281  : 	}

	ret	0
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int const &>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	npad	3
$LL14@Uninit_cop:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
$LN32@Uninit_cop:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop
$LN4@Uninit_cop:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
	npad	2
$LL14@Uninit_cop@2:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
$LN32@Uninit_cop@2:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
	npad	2
$LL14@Uninit_cop@3:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN32@Uninit_cop@3:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
	npad	2
$LL14@Uninit_cop@4:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
$LN32@Uninit_cop@4:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >, COMDAT
; __Dest$ = eax

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@5
	push	esi
	npad	2
$LL14@Uninit_cop@5:

; 376  : 		_Cons_val(_Al, _Dest, *_First);

	test	eax, eax
	je	SHORT $LN32@Uninit_cop@5
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN32@Uninit_cop@5:

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;
; 373  : 
; 374  : 	_TRY_BEGIN
; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[ebp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@5
	pop	esi
$LN4@Uninit_cop@5:

; 377  : 	_CATCH_ALL
; 378  : 	for (; _Next != _Dest; ++_Next)
; 379  : 		_Dest_val(_Al, _Next);
; 380  : 	_RERAISE;
; 381  : 	_CATCH_END
; 382  : 	return (_Dest);
; 383  : 	}

	pop	ebp
	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@@Z
_TEXT	SEGMENT
__Cat$145477 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$145477[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
__Cat$145484 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$145484[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
__Cat$145491 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$145491[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z
_TEXT	SEGMENT
__Cat$145498 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$145498[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__Cat$145505 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$145505[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
	add	esp, 12					; 0000000cH

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
_TEXT	ENDS
;	COMDAT ??$?0V?$Vec@H$03@cv@@@_InputArray@cv@@QAE@ABV?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@@Z
_TEXT	SEGMENT
??$?0V?$Vec@H$03@cv@@@_InputArray@cv@@QAE@ABV?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@@Z PROC ; cv::_InputArray::_InputArray<cv::Vec<int,4> >, COMDAT
; _this$ = eax
; _vec$ = ecx

; 1125 :     : flags(FIXED_TYPE + STD_VECTOR + DataType<_Tp>::type), obj((void*)&vec) {}

	mov	DWORD PTR [eax+8], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7_InputArray@cv@@6B@
	mov	DWORD PTR [eax+4], -2147287012		; 8003001cH
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	ret	0
??$?0V?$Vec@H$03@cv@@@_InputArray@cv@@QAE@ABV?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@@Z ENDP ; cv::_InputArray::_InputArray<cv::Vec<int,4> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0V?$Point_@H@cv@@@_InputArray@cv@@QAE@ABV?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@@Z
_TEXT	SEGMENT
??$?0V?$Point_@H@cv@@@_InputArray@cv@@QAE@ABV?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@@Z PROC ; cv::_InputArray::_InputArray<cv::Point_<int> >, COMDAT
; _this$ = eax
; _vec$ = ecx

; 1128 :     : flags(FIXED_TYPE + STD_VECTOR_VECTOR + DataType<_Tp>::type), obj((void*)&vec) {}

	mov	DWORD PTR [eax+8], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7_InputArray@cv@@6B@
	mov	DWORD PTR [eax+4], -2147221492		; 8004000cH
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	ret	0
??$?0V?$Point_@H@cv@@@_InputArray@cv@@QAE@ABV?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@@Z ENDP ; cv::_InputArray::_InputArray<cv::Point_<int> >
_TEXT	ENDS
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT
$T145522 = -16						; size = 12
$T145530 = -4						; size = 4
??$_Allocate@M@std@@YAPAMIPAM@Z PROC			; std::_Allocate<float>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 1073741823				; 3fffffffH
	ja	SHORT $LN1@Allocate
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	ecx, DWORD PTR $T145530[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T145522[ebp]
	mov	DWORD PTR $T145530[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T145522[ebp]
	push	edx
	mov	DWORD PTR $T145522[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate:
$LN7@Allocate:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate:
??$_Allocate@M@std@@YAPAMIPAM@Z ENDP			; std::_Allocate<float>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@IPAU1234@@Z
_TEXT	SEGMENT
$T145535 = -16						; size = 12
$T145543 = -4						; size = 4
??$_Allocate@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@IPAU1234@@Z PROC ; std::_Allocate<cv::CascadeClassifier::Data::DTreeNode>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 268435455				; 0fffffffH
	ja	SHORT $LN1@Allocate@2
	shl	eax, 4
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	eax, DWORD PTR $T145543[ebp]
	push	eax
	lea	ecx, DWORD PTR $T145535[ebp]
	mov	DWORD PTR $T145543[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T145535[ebp]
	push	ecx
	mov	DWORD PTR $T145535[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@2:
$LN7@Allocate@2:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@2:
??$_Allocate@UDTreeNode@Data@CascadeClassifier@cv@@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@IPAU1234@@Z ENDP ; std::_Allocate<cv::CascadeClassifier::Data::DTreeNode>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UDTree@Data@CascadeClassifier@cv@@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@IPAU1234@@Z
_TEXT	SEGMENT
$T145548 = -16						; size = 12
$T145556 = -4						; size = 4
??$_Allocate@UDTree@Data@CascadeClassifier@cv@@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@IPAU1234@@Z PROC ; std::_Allocate<cv::CascadeClassifier::Data::DTree>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 1073741823				; 3fffffffH
	ja	SHORT $LN1@Allocate@3
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	ecx, DWORD PTR $T145556[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T145548[ebp]
	mov	DWORD PTR $T145556[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T145548[ebp]
	push	edx
	mov	DWORD PTR $T145548[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@3:
$LN7@Allocate@3:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@3:
??$_Allocate@UDTree@Data@CascadeClassifier@cv@@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@IPAU1234@@Z ENDP ; std::_Allocate<cv::CascadeClassifier::Data::DTree>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UStage@Data@CascadeClassifier@cv@@@std@@YAPAUStage@Data@CascadeClassifier@cv@@IPAU1234@@Z
_TEXT	SEGMENT
$T145561 = -16						; size = 12
$T145569 = -4						; size = 4
??$_Allocate@UStage@Data@CascadeClassifier@cv@@@std@@YAPAUStage@Data@CascadeClassifier@cv@@IPAU1234@@Z PROC ; std::_Allocate<cv::CascadeClassifier::Data::Stage>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 357913941				; 15555555H
	ja	SHORT $LN1@Allocate@4
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	ecx, DWORD PTR $T145569[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T145561[ebp]
	mov	DWORD PTR $T145569[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T145561[ebp]
	push	edx
	mov	DWORD PTR $T145561[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@4:
$LN7@Allocate@4:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@4:
??$_Allocate@UStage@Data@CascadeClassifier@cv@@@std@@YAPAUStage@Data@CascadeClassifier@cv@@IPAU1234@@Z ENDP ; std::_Allocate<cv::CascadeClassifier::Data::Stage>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T145574 = -16						; size = 12
$T145582 = -4						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, 1073741823				; 3fffffffH
	ja	SHORT $LN1@Allocate@5
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@5
$LN1@Allocate@5:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	ecx, DWORD PTR $T145582[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T145574[ebp]
	mov	DWORD PTR $T145582[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T145574[ebp]
	push	edx
	mov	DWORD PTR $T145574[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@5:
$LN7@Allocate@5:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@5:
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T145587 = -16						; size = 12
$T145595 = -4						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN1@Allocate@6
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate@6
$LN1@Allocate@6:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	eax, DWORD PTR $T145595[ebp]
	push	eax
	lea	ecx, DWORD PTR $T145587[ebp]
	mov	DWORD PTR $T145595[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T145587[ebp]
	push	ecx
	mov	DWORD PTR $T145587[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate@6:
$LN7@Allocate@6:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate@6:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IAEPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@1@0PAM@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$145611 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IAEPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@1@0PAM@Z PROC ; std::vector<float,std::allocator<float> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$145611[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IAEPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@1@0PAM@Z ENDP ; std::vector<float,std::allocator<float> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$145627 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$145627[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$145643 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$145643[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$145659 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$145659[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@1@0PAU2345@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@1@0PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$145675 = 12					; size = 1
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@1@0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > > >, COMDAT

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$145675[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
	add	esp, 12					; 0000000cH

; 1319 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@1@0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > > >
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
;	COMDAT ??$?0V?$Point_@H@cv@@@Mat@cv@@QAE@ABV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@_N@Z
_TEXT	SEGMENT
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
??$?0V?$Point_@H@cv@@@Mat@cv@@QAE@ABV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@_N@Z PROC ; cv::Mat::Mat<cv::Point_<int> >, COMDAT
; _vec$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 1124024332		; 42ff400cH
	mov	DWORD PTR [eax+4], 2
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	sub	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], 1
	sar	esi, 3
	mov	DWORD PTR [eax+8], esi
	lea	edx, DWORD PTR [eax+8]
	push	edi
	xor	edi, edi
	mov	DWORD PTR [eax+16], edi
	mov	DWORD PTR [eax+20], edi
	mov	DWORD PTR [eax+24], edi
	mov	DWORD PTR [eax+28], edi
	mov	DWORD PTR [eax+36], edi
	mov	DWORD PTR [eax+40], edx
	lea	esi, DWORD PTR [eax+48]
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [esi+4], edi
	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [esi], edi

; 179  :     if(vec.empty())

	mov	esi, DWORD PTR [ecx]
	cmp	esi, DWORD PTR [ecx+4]
	je	SHORT $LN1@Mat@3

; 180  :         return;
; 181  :     if( !copyData )
; 182  :     {
; 183  :         step[0] = step[1] = sizeof(_Tp);

	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [esi+4], 8
	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [esi], 8

; 184  :         data = datastart = (uchar*)&vec[0];

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+16], ecx

; 185  :         datalimit = dataend = datastart + rows*step[0];

	mov	ecx, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR [ecx]
	imul	ecx, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
$LN1@Mat@3:

; 186  :     }
; 187  :     else
; 188  :         Mat((int)vec.size(), 1, DataType<_Tp>::type, (uchar*)&vec[0]).copyTo(*this);
; 189  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$Point_@H@cv@@@Mat@cv@@QAE@ABV?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@_N@Z ENDP ; cv::Mat::Mat<cv::Point_<int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0V?$Vec@H$03@cv@@@_OutputArray@cv@@QAE@AAV?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@@Z
_TEXT	SEGMENT
??$?0V?$Vec@H$03@cv@@@_OutputArray@cv@@QAE@AAV?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@@Z PROC ; cv::_OutputArray::_OutputArray<cv::Vec<int,4> >, COMDAT
; _this$ = eax
; _vec$ = ecx

; 1146 :     : _InputArray(vec) {}

	mov	DWORD PTR [eax+8], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], -2147287012		; 8003001cH
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax], OFFSET ??_7_OutputArray@cv@@6B@
	ret	0
??$?0V?$Vec@H$03@cv@@@_OutputArray@cv@@QAE@AAV?$vector@V?$Vec@H$03@cv@@V?$allocator@V?$Vec@H$03@cv@@@std@@@std@@@Z ENDP ; cv::_OutputArray::_OutputArray<cv::Vec<int,4> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0V?$Point_@H@cv@@@_OutputArray@cv@@QAE@AAV?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@@Z
_TEXT	SEGMENT
??$?0V?$Point_@H@cv@@@_OutputArray@cv@@QAE@AAV?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@@Z PROC ; cv::_OutputArray::_OutputArray<cv::Point_<int> >, COMDAT
; _this$ = eax
; _vec$ = ecx

; 1148 :     : _InputArray(vec) {}

	mov	DWORD PTR [eax+8], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], -2147221492		; 8004000cH
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax], OFFSET ??_7_OutputArray@cv@@6B@
	ret	0
??$?0V?$Point_@H@cv@@@_OutputArray@cv@@QAE@AAV?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@@Z ENDP ; cv::_OutputArray::_OutputArray<cv::Point_<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
_TEXT	ENDS
;	COMDAT ?all@?$Scalar_@N@cv@@SA?AV12@N@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 8
?all@?$Scalar_@N@cv@@SA?AV12@N@Z PROC			; cv::Scalar_<double>::all, COMDAT
; ___$ReturnUdt$ = eax

; 2033 : { return Scalar_<_Tp>(v0, v0, v0, v0); }

	push	ebp
	mov	ebp, esp
	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR _v0$[ebp]
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	pop	ebp
	ret	0
?all@?$Scalar_@N@cv@@SA?AV12@N@Z ENDP			; cv::Scalar_<double>::all
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = eax
; __Ptr$ = esi

; 1973 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

	test	esi, esi
	je	SHORT $LN2@Inside
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN8@Inside
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	ecx, eax
$LN9@Inside:
	cmp	esi, ecx
	jb	SHORT $LN2@Inside
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN12@Inside
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN13@Inside
$LN12@Inside:
	mov	ecx, eax
$LN13@Inside:
	mov	eax, DWORD PTR [eax+16]
	add	eax, ecx
	cmp	eax, esi
	jbe	SHORT $LN2@Inside

; 1975 : 		else
; 1976 : 			return (true);

	mov	al, 1

; 1977 : 		}

	ret	0
$LN2@Inside:

; 1974 : 			return (false);	// don't ask

	xor	al, al

; 1977 : 		}

	ret	0
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAE@PAMPBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAE@PAMPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@QAE@PAMPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTreeNode@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTreeNode@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTreeNode@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTree@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTree@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUDTree@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUStage@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUStage@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@QAE@PAUStage@Data@CascadeClassifier@cv@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

	mov	DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT
$T145839 = -16						; size = 12
$T145837 = -4						; size = 4
?allocate@?$allocator@M@std@@QAEPAMI@Z PROC		; std::allocator<float>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate
	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN3@allocate
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate
$LN3@allocate:
	lea	ecx, DWORD PTR $T145837[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T145839[ebp]
	mov	DWORD PTR $T145837[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T145839[ebp]
	push	edx
	mov	DWORD PTR $T145839[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate:
?allocate@?$allocator@M@std@@QAEPAMI@Z ENDP		; std::allocator<float>::allocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
$T145868 = -16						; size = 12
$T145860 = -4						; size = 4
?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@2
	cmp	ecx, 268435455				; 0fffffffH
	ja	SHORT $LN3@allocate@2
	shl	ecx, 4
	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@2
$LN3@allocate@2:
	lea	eax, DWORD PTR $T145860[ebp]
	push	eax
	lea	ecx, DWORD PTR $T145868[ebp]
	mov	DWORD PTR $T145860[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T145868[ebp]
	push	ecx
	mov	DWORD PTR $T145868[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@2:
?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
$T145891 = -16						; size = 12
$T145883 = -4						; size = 4
?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@3
	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN3@allocate@3
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@3
$LN3@allocate@3:
	lea	ecx, DWORD PTR $T145883[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T145891[ebp]
	mov	DWORD PTR $T145883[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T145891[ebp]
	push	edx
	mov	DWORD PTR $T145891[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@3:
$LN1@allocate@3:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@3:
?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z
_TEXT	SEGMENT
$T145908 = -16						; size = 12
$T145906 = -4						; size = 4
?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z PROC ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@4
	cmp	ecx, 357913941				; 15555555H
	ja	SHORT $LN3@allocate@4
	lea	eax, DWORD PTR [ecx+ecx*2]
	add	eax, eax
	add	eax, eax
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@4
$LN3@allocate@4:
	lea	ecx, DWORD PTR $T145906[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T145908[ebp]
	mov	DWORD PTR $T145906[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T145908[ebp]
	push	edx
	mov	DWORD PTR $T145908[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@4:
$LN1@allocate@4:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@4:
?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z ENDP ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
$T145931 = -16						; size = 12
$T145929 = -4						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@5
	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN3@allocate@5
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@5
$LN3@allocate@5:
	lea	ecx, DWORD PTR $T145929[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T145931[ebp]
	mov	DWORD PTR $T145929[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T145931[ebp]
	push	edx
	mov	DWORD PTR $T145931[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@5:
$LN1@allocate@5:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@5:
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = eax
; __Newsize$ = ecx

; 1953 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	mov	DWORD PTR [eax+16], ecx
	jb	SHORT $LN5@Eos
	mov	eax, DWORD PTR [eax]
$LN5@Eos:
	mov	BYTE PTR [eax+ecx], 0

; 1954 : 		}

	ret	0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = esi
; __Off$ = ecx
; __Count$ = eax

; 1108 : 		{	// erase elements [_Off, _Off + _Count)

	push	edi
	mov	edi, eax

; 1109 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ecx
	jae	SHORT $LN3@erase

; 1110 : 			_Xran();	// _Off off end

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN28@erase:
$LN3@erase:

; 1111 : 		if (this->_Mysize - _Off < _Count)

	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN2@erase

; 1112 : 			_Count = this->_Mysize - _Off;	// trim _Count

	mov	edi, eax
$LN2@erase:

; 1113 : 		if (0 < _Count)

	test	edi, edi
	je	SHORT $LN25@erase

; 1114 : 			{	// move elements down
; 1115 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1116 : 				this->_Mysize - _Off - _Count);

	mov	edx, DWORD PTR [esi+20]
	push	ebx
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN11@erase
	mov	ebx, DWORD PTR [esi]
	jmp	SHORT $LN12@erase
$LN11@erase:
	mov	ebx, esi
$LN12@erase:
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN15@erase
	mov	edx, DWORD PTR [esi]
	jmp	SHORT $LN16@erase
$LN15@erase:
	mov	edx, esi
$LN16@erase:
	sub	eax, edi
	add	ebx, ecx
	push	eax
	add	ebx, edi
	add	edx, ecx
	push	ebx
	push	edx
	call	DWORD PTR __imp__memmove

; 1117 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	eax, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	sub	eax, edi

; 1118 : 			_Eos(_Newsize);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], eax
	pop	ebx
	jb	SHORT $LN23@erase
	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR [ecx+eax], 0

; 1119 : 			}
; 1120 : 		return (*this);

	mov	eax, esi
	pop	edi

; 1121 : 		}

	ret	0

; 1118 : 			_Eos(_Newsize);

$LN23@erase:
	mov	ecx, esi
	mov	BYTE PTR [ecx+eax], 0
$LN25@erase:

; 1119 : 			}
; 1120 : 		return (*this);

	mov	eax, esi
	pop	edi

; 1121 : 		}

	ret	0
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\sstream
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = esi

; 341  : 		if (_Mystate & _Allocated)

	test	BYTE PTR [esi+64], 1
	je	SHORT $LN16@Tidy@10

; 342  : 			_Al.deallocate(_Mysb::eback(),
; 343  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 344  : 					: _Mysb::egptr()) - _Mysb::eback());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN16@Tidy@10:

; 345  : 		_Mysb::setg(0, 0, 0);

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], 0

; 346  : 		_Mysb::setp(0, 0);

	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx], 0

; 347  : 		_Seekhigh = 0;
; 348  : 		_Mystate &= ~_Allocated;

	and	DWORD PTR [esi+64], -2			; fffffffeH
	mov	DWORD PTR [esi+60], 0

; 349  : 		}

	ret	0
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z PROC	; std::vector<float,std::allocator<float> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy

; 1256 : 			return (false);

	xor	al, al

; 1266 : 		}

	ret	0
$LN4@Buy:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy:
$LN2@Buy:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@M@std@@QAEPAMI@Z	; std::allocator<float>::allocate
	mov	DWORD PTR [esi], eax

; 1262 : 			this->_Mylast = this->_Myfirst;

	mov	DWORD PTR [esi+4], eax

; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1

; 1266 : 		}

	ret	0
$LN16@Buy:
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ENDP	; std::vector<float,std::allocator<float> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = eax

; 1250 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, eax

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [edi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [edi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [edi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	esi, eax
	jne	SHORT $LN4@Buy@2

; 1256 : 			return (false);

	xor	al, al
	pop	esi

; 1266 : 		}

	ret	0
$LN4@Buy@2:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	esi, 268435455				; 0fffffffH
	jbe	SHORT $LN2@Buy@2

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy@2:
$LN2@Buy@2:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, esi
	call	?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate

; 1262 : 			this->_Mylast = this->_Myfirst;
; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	shl	esi, 4
	add	esi, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], esi

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1
	pop	esi

; 1266 : 		}

	ret	0
$LN16@Buy@2:
?_Buy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@3

; 1256 : 			return (false);

	xor	al, al

; 1266 : 		}

	ret	0
$LN4@Buy@3:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@3

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy@3:
$LN2@Buy@3:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate
	mov	DWORD PTR [esi], eax

; 1262 : 			this->_Mylast = this->_Myfirst;

	mov	DWORD PTR [esi+4], eax

; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1

; 1266 : 		}

	ret	0
$LN16@Buy@3:
?_Buy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@4

; 1256 : 			return (false);

	xor	al, al

; 1266 : 		}

	ret	0
$LN4@Buy@4:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy@4

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy@4:
$LN2@Buy@4:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate

; 1262 : 			this->_Mylast = this->_Myfirst;
; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edx

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1

; 1266 : 		}

	ret	0
$LN16@Buy@4:
?_Buy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@2@XZ ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1251 : 		this->_Myfirst = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 1252 : 		this->_Mylast = 0;

	mov	DWORD PTR [esi+4], eax

; 1253 : 		this->_Myend = 0;

	mov	DWORD PTR [esi+8], eax

; 1254 : 
; 1255 : 		if (_Capacity == 0)

	cmp	edi, eax
	jne	SHORT $LN4@Buy@5

; 1256 : 			return (false);

	xor	al, al

; 1266 : 		}

	ret	0
$LN4@Buy@5:

; 1257 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@5

; 1258 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN17@Buy@5:
$LN2@Buy@5:

; 1259 : 		else
; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	DWORD PTR [esi], eax

; 1262 : 			this->_Mylast = this->_Myfirst;

	mov	DWORD PTR [esi+4], eax

; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1264 : 			}
; 1265 : 		return (true);

	mov	al, 1

; 1266 : 		}

	ret	0
$LN16@Buy@5:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 797  : 		return (const_iterator(this->_Mylast, this));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 798  : 		}

	ret	0
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 787  : 		return (const_iterator(this->_Myfirst, this));

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 788  : 		}

	ret	0
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T146299 = -16						; size = 12
$T146291 = -4						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@6
	cmp	ecx, -1
	ja	SHORT $LN3@allocate@6
	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@6
$LN3@allocate@6:
	lea	eax, DWORD PTR $T146291[ebp]
	push	eax
	lea	ecx, DWORD PTR $T146299[ebp]
	mov	DWORD PTR $T146291[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T146299[ebp]
	push	ecx
	mov	DWORD PTR $T146299[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@6:
$LN1@allocate@6:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate@6:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = esi
; __Newsize$ = edi

; 1987 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 1988 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	je	SHORT $LN9@Tidy@11

; 1989 : 			;
; 1990 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN9@Tidy@11

; 1991 : 			{	// copy any leftovers to small buffer and deallocate
; 1992 : 			_Elem *_Ptr = this->_Bx._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 1993 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN7@Tidy@11

; 1994 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@Tidy@11:

; 1995 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

	push	ebx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
	pop	ebx
$LN9@Tidy@11:

; 1996 : 			}
; 1997 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1998 : 		_Eos(_Newsize);

	mov	DWORD PTR [esi+16], edi
	mov	BYTE PTR [edi+esi], 0

; 1999 : 		}

	pop	ebp
	ret	4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\sstream
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		if (_Mysb::gptr() == 0)

	mov	edx, DWORD PTR [ecx+32]
	push	esi
	mov	esi, DWORD PTR [edx]
	test	esi, esi
	jne	SHORT $LN8@underflow

; 208  : 			return (_Traits::eof());	// no character buffer, fail

	or	eax, -1
	pop	esi

; 220  : 			}
; 221  : 		}

	ret	0
$LN8@underflow:
	push	ebx
	push	edi

; 209  : 		else if (_Mysb::gptr() < _Mysb::egptr())

	mov	edi, DWORD PTR [ecx+48]
	mov	ebx, DWORD PTR [edi]
	mov	eax, esi
	add	ebx, eax
	cmp	eax, ebx
	jae	SHORT $LN6@underflow

; 210  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

	movzx	eax, BYTE PTR [esi]
	pop	edi
	pop	ebx
	pop	esi

; 220  : 			}
; 221  : 		}

	ret	0
$LN6@underflow:

; 211  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 212  : 			|| _Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr())

	test	BYTE PTR [ecx+64], 4
	jne	SHORT $LN3@underflow
	mov	eax, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN3@underflow
	cmp	eax, esi
	ja	SHORT $LN4@underflow
	cmp	DWORD PTR [ecx+60], esi
	jbe	SHORT $LN3@underflow
$LN4@underflow:

; 214  : 		else
; 215  : 			{	// extend read buffer into written area, then return buffered
; 216  : 			if (_Seekhigh < _Mysb::pptr())

	cmp	DWORD PTR [ecx+60], eax
	jae	SHORT $LN1@underflow

; 217  : 				_Seekhigh = _Mysb::pptr();

	mov	DWORD PTR [ecx+60], eax
$LN1@underflow:

; 218  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

	mov	eax, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR [edx]
	sub	eax, edx
	mov	DWORD PTR [edi], eax

; 219  : 			return (_Traits::to_int_type(*_Mysb::gptr()));

	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [eax]
	pop	edi
	pop	ebx
	pop	esi

; 220  : 			}
; 221  : 		}

	ret	0
$LN3@underflow:
	pop	edi
	pop	ebx

; 213  : 			return (_Traits::eof());	// can't read, fail

	or	eax, -1
	pop	esi

; 220  : 			}
; 221  : 		}

	ret	0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; _this$ = ecx

; 189  : 		{	// put an element back to stream

	push	ebp
	mov	ebp, esp

; 190  : 		if (_Mysb::gptr() == 0
; 191  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 192  : 			|| !_Traits::eq_int_type(_Traits::eof(), _Meta)
; 193  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 194  : 			&& _Mystate & _Constant)

	mov	eax, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN3@pbackfail
	mov	edx, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [edx]
	jbe	SHORT $LN3@pbackfail
	mov	edx, DWORD PTR __Meta$[ebp]
	cmp	edx, -1
	je	SHORT $LN4@pbackfail
	cmp	dl, BYTE PTR [eax-1]
	je	SHORT $LN4@pbackfail
	test	BYTE PTR [ecx+64], 2
	jne	SHORT $LN3@pbackfail
$LN4@pbackfail:

; 196  : 		else
; 197  : 			{	// back up one position and store put-back character
; 198  : 			_Mysb::gbump(-1);

	mov	eax, DWORD PTR [ecx+48]
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+32]
	dec	DWORD PTR [eax]

; 199  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

	cmp	edx, -1
	je	SHORT $LN37@pbackfail

; 200  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx], dl

; 201  : 			return (_Traits::not_eof(_Meta));

	mov	eax, edx

; 202  : 			}
; 203  : 		}

	pop	ebp
	ret	4

; 201  : 			return (_Traits::not_eof(_Meta));

$LN37@pbackfail:
	xor	eax, eax

; 202  : 			}
; 203  : 		}

	pop	ebp
	ret	4
$LN3@pbackfail:

; 195  : 			return (_Traits::eof());	// can't put back, fail

	or	eax, -1

; 202  : 			}
; 203  : 		}

	pop	ebp
	ret	4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Oldptr$129829 = -8					; size = 4
__Newsize$129822 = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 121  : 		if (_Mystate & _Append
; 122  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

	test	BYTE PTR [esi+64], 8
	push	edi
	je	SHORT $LN102@overflow
	mov	edi, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [edi]
	test	edx, edx
	je	SHORT $LN102@overflow
	mov	ecx, DWORD PTR [esi+60]
	cmp	edx, ecx
	jae	SHORT $LN102@overflow

; 123  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	mov	DWORD PTR [edi], ecx
	sub	eax, ecx
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx], eax
$LN102@overflow:

; 124  : 
; 125  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	mov	ebx, DWORD PTR __Meta$[ebp]
	cmp	ebx, -1
	jne	SHORT $LN17@overflow

; 126  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 185  : 			}
; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN17@overflow:

; 127  : 		else if (_Mysb::pptr() != 0
; 128  : 			&& _Mysb::pptr() < _Mysb::epptr())

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN15@overflow
	mov	edx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edx]
	mov	eax, ecx
	add	edx, eax
	cmp	eax, edx
	jae	SHORT $LN15@overflow

; 129  : 			{	// room in buffer, store it
; 130  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	ecx, esi
	call	DWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
	pop	edi
	mov	BYTE PTR [eax], bl
	pop	esi

; 131  : 			return (_Meta);

	mov	eax, ebx
	pop	ebx

; 185  : 			}
; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN15@overflow:

; 132  : 			}
; 133  : 		else if (_Mystate & _Constant)

	test	BYTE PTR [esi+64], 2
	je	SHORT $LN13@overflow
$LN106@overflow:
	pop	edi
	pop	esi

; 134  : 			return (_Traits::eof());	// array nonmutable, fail

	or	eax, -1
	pop	ebx

; 185  : 			}
; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN13@overflow:

; 135  : 		else
; 136  : 			{	// grow buffer and store element
; 137  : 			size_t _Oldsize = _Mysb::pptr() == 0
; 138  : 				? 0 : _Mysb::epptr() - _Mysb::eback();

	test	ecx, ecx
	jne	SHORT $LN21@overflow
	xor	ebx, ebx
	jmp	SHORT $LN22@overflow
$LN21@overflow:
	mov	eax, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [eax]
	sub	ebx, DWORD PTR [edx]
	add	ebx, ecx
$LN22@overflow:

; 139  : 			size_t _Newsize = _Oldsize;
; 140  : 			size_t _Inc = _Newsize / 2 < _MINSIZE
; 141  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent

	mov	eax, ebx
	shr	eax, 1
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN23@overflow
	mov	eax, 32					; 00000020H
	jmp	SHORT $LL11@overflow
$LN23@overflow:

; 142  : 
; 143  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	test	eax, eax
	je	SHORT $LN106@overflow
	npad	7
$LL11@overflow:
	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, eax
	cmp	ecx, ebx
	jae	SHORT $LN103@overflow

; 144  : 				_Inc /= 2;	// increment causes overflow, halve it

	shr	eax, 1

; 142  : 
; 143  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	jne	SHORT $LL11@overflow
$LN103@overflow:

; 145  : 			if (_Inc == 0)

	test	eax, eax

; 146  : 				return (_Traits::eof());	// buffer can't grow, fail

	je	SHORT $LN106@overflow

; 147  : 
; 148  : 			_Newsize += _Inc;

	lea	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR __Newsize$129822[ebp], ecx

; 149  : 
; 150  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 151  : 			_Elem *_Oldptr = _Mysb::eback();

	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [edx]
	mov	edi, eax
	mov	DWORD PTR __Oldptr$129829[ebp], edx

; 152  : 
; 153  : 			if (0 < _Oldsize)

	test	ebx, ebx
	je	SHORT $LN108@overflow

; 154  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);

	push	ebx
	push	edx
	push	edi
	call	_memcpy
	mov	edx, DWORD PTR __Oldptr$129829[ebp]
	add	esp, 12					; 0000000cH

; 155  : 
; 156  : 			if (_Oldsize == 0)

	test	ebx, ebx
	jne	SHORT $LN7@overflow
$LN108@overflow:

; 157  : 				{	// first growth, set up pointers
; 158  : 				_Seekhigh = _Newptr;
; 159  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [eax], edi
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [ecx], edi
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR __Newsize$129822[ebp]
	mov	DWORD PTR [eax], ecx

; 160  : 				if (_Mystate & _Noread)

	test	BYTE PTR [esi+64], 4
	je	SHORT $LN6@overflow

; 161  : 					_Mysb::setg(_Newptr, 0, _Newptr);

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax], edi
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx], 0
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], edi

; 162  : 				else

	jmp	SHORT $LN89@overflow
$LN6@overflow:

; 163  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx], edi
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], edi
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], 1

; 164  : 				}
; 165  : 			else

	jmp	SHORT $LN89@overflow
$LN7@overflow:

; 166  : 				{	// not first growth, adjust pointers
; 167  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
; 168  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
; 169  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 170  : 					_Newptr + _Newsize);

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, edi
	sub	eax, edx
	add	DWORD PTR [esi+60], eax
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+20]
	mov	ebx, edi
	sub	eax, edx
	sub	ebx, edx
	add	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [esi+36]
	add	eax, edi
	mov	DWORD PTR [ecx], eax
	mov	ecx, edi
	sub	ecx, eax
	add	ecx, DWORD PTR __Newsize$129822[ebp]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax], ecx

; 171  : 				if (_Mystate & _Noread)

	test	BYTE PTR [esi+64], 4
	je	SHORT $LN3@overflow

; 172  : 					_Mysb::setg(_Newptr, 0, _Newptr);

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx], edi
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], edi

; 173  : 				else

	jmp	SHORT $LN89@overflow
$LN3@overflow:

; 174  : 					_Mysb::setg(_Newptr,
; 175  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 176  : 						_Mysb::pptr() + 1);

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [esi+16]
	sub	eax, edx
	add	eax, edi
	mov	DWORD PTR [ebx], edi
	mov	edi, DWORD PTR [esi+32]
	sub	ecx, eax
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [esi+48]
	inc	ecx
	mov	DWORD PTR [eax], ecx
$LN89@overflow:

; 177  : 				}
; 178  : 
; 179  : 			if (_Mystate & _Allocated)

	test	BYTE PTR [esi+64], 1
	je	SHORT $LN91@overflow

; 180  : 				_Al.deallocate(_Oldptr, _Oldsize);

	push	edx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN91@overflow:

; 181  : 			_Mystate |= _Allocated;

	or	DWORD PTR [esi+64], 1

; 182  : 
; 183  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	ecx, esi
	call	DWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
	mov	ecx, DWORD PTR __Meta$[ebp]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax], cl

; 184  : 			return (_Meta);

	mov	eax, ecx
	pop	ebx

; 185  : 			}
; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 76   : 		_Tidy();

	test	BYTE PTR [esi+64], 1
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	je	SHORT $LN19@basic_stri
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN19@basic_stri:
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx], 0
	and	DWORD PTR [esi+64], -2			; fffffffeH
	mov	DWORD PTR [esi+60], 0

; 77   : 		}

	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\istream
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\sstream
xdata$x	ENDS
;	COMDAT ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR [ecx-96]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx-96], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 705  : 		}

	lea	esi, DWORD PTR [ecx-72]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 72					; 00000048H
	jmp	DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$146820 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+4]
	sub	edi, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	sar	edi, 2
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@9
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN18@vector@9
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@9:
$LN18@vector@9:
	mov	ecx, edi
	call	?allocate@?$allocator@M@std@@QAEPAMI@Z	; std::allocator<float>::allocate

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$146820[ebp]
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@std@@PAMV?$allocator@M@2@@std@@YAPAMV?$_Vector_const_iterator@V?$_Vector_val@MV?$allocator@M@std@@@std@@@0@0PAMAAV?$allocator@M@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<float,std::allocator<float> > >,float *,std::allocator<float> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax
$LN7@vector@9:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@9:
$LN54@vector@9:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$146955 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	edi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	esi, DWORD PTR [ebx+4]
	sub	esi, DWORD PTR [ebx]
	mov	DWORD PTR [edi], eax
	sar	esi, 4
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	cmp	esi, eax
	je	SHORT $LN7@vector@10
	cmp	esi, 268435455				; 0fffffffH
	jbe	SHORT $LN18@vector@10
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@10:
$LN18@vector@10:
	mov	ecx, esi
	call	?allocate@?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@QAEPAUDTreeNode@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTreeNode>::allocate

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$146955[ebp]
	shl	esi, 4
	add	esi, eax
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], esi
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTreeNode@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> > >,cv::CascadeClassifier::Data::DTreeNode *,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+4], eax
$LN7@vector@10:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@10:
$LN54@vector@10:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$147089 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+4]
	sub	edi, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	sar	edi, 2
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@11
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN18@vector@11
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@11:
$LN18@vector@11:
	mov	ecx, edi
	call	?allocate@?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@QAEPAUDTree@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::DTree>::allocate

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$147089[ebp]
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@2@@std@@YAPAUDTree@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UDTree@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> > >,cv::CascadeClassifier::Data::DTree *,std::allocator<cv::CascadeClassifier::Data::DTree> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax
$LN7@vector@11:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@11:
$LN54@vector@11:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$147224 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	edi, edx
	mov	eax, 0
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	je	SHORT $LN7@vector@12
	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN18@vector@12
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@12:
$LN18@vector@12:
	mov	ecx, edi
	call	?allocate@?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@QAEPAUStage@Data@CascadeClassifier@cv@@I@Z ; std::allocator<cv::CascadeClassifier::Data::Stage>::allocate
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$147224[ebp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@std@@PAUStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@2@@std@@YAPAUStage@Data@CascadeClassifier@cv@@V?$_Vector_const_iterator@V?$_Vector_val@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@@0@0PAU1234@AAV?$allocator@UStage@Data@CascadeClassifier@cv@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> > >,cv::CascadeClassifier::Data::Stage *,std::allocator<cv::CascadeClassifier::Data::Stage> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax
$LN7@vector@12:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@IAEXXZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@12:
$LN54@vector@12:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$147359 = 8					; size = 1
_this$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; __Right$ = ecx

; 535  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 536  : 		if (_Buy(_Right.size()))

	mov	edi, DWORD PTR [ebx+4]
	sub	edi, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	sar	edi, 2
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@13
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN18@vector@13
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN55@vector@13:
$LN18@vector@13:
	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate

; 537  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

	mov	edx, DWORD PTR __Cat$147359[ebp]
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	edx
	push	ecx
	push	ebx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >,int *,std::allocator<int> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax
$LN7@vector@13:

; 543  : 			_CATCH_END
; 544  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 542  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN56@vector@13:
$LN54@vector@13:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = esi

; 753  : 		_Tidy(true);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN11@basic_stri@2
	mov	eax, DWORD PTR [esi]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN11@basic_stri@2:
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0

; 754  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = eax

; 551  : 		_Tidy();

	mov	DWORD PTR [eax+20], 15			; 0000000fH
	mov	DWORD PTR [eax+16], 0
	mov	BYTE PTR [eax], 0

; 552  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$3
__ehfuncinfo$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z PROC	; cv::CascadeClassifier::Data::Data, COMDAT
; ___that$ = edi
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edi]
	mov	BYTE PTR [esi], al
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	lea	eax, DWORD PTR [esi+24]
	lea	ecx, DWORD PTR [edi+24]
	push	eax
	mov	DWORD PTR [esi+20], edx
	call	??0?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
	lea	edx, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [edi+40]
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??0?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
	lea	eax, DWORD PTR [esi+56]
	lea	ecx, DWORD PTR [edi+56]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@ABV01@@Z ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
	lea	edx, DWORD PTR [esi+72]
	lea	ecx, DWORD PTR [edi+72]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@ABV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	lea	eax, DWORD PTR [esi+88]
	lea	ecx, DWORD PTR [edi+88]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$0:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 24					; 00000018H
	jmp	??1?$vector@UStage@Data@CascadeClassifier@cv@@V?$allocator@UStage@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >::~vector<cv::CascadeClassifier::Data::Stage,std::allocator<cv::CascadeClassifier::Data::Stage> >
__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$1:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 40					; 00000028H
	jmp	??1?$vector@UDTree@Data@CascadeClassifier@cv@@V?$allocator@UDTree@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >::~vector<cv::CascadeClassifier::Data::DTree,std::allocator<cv::CascadeClassifier::Data::DTree> >
__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$2:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 56					; 00000038H
	jmp	??1?$vector@UDTreeNode@Data@CascadeClassifier@cv@@V?$allocator@UDTreeNode@Data@CascadeClassifier@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >::~vector<cv::CascadeClassifier::Data::DTreeNode,std::allocator<cv::CascadeClassifier::Data::DTreeNode> >
__unwindfunclet$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z$3:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 72					; 00000048H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
__ehhandler$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z ENDP	; cv::CascadeClassifier::Data::Data
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CascadeClassifier@cv@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$2
__ehfuncinfo$??0CascadeClassifier@cv@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CascadeClassifier@cv@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0CascadeClassifier@cv@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0CascadeClassifier@cv@@QAE@ABV01@@Z PROC		; cv::CascadeClassifier::CascadeClassifier, COMDAT
; ___that$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CascadeClassifier@cv@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	esi, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [ebx+4]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7CascadeClassifier@cv@@6B@
	call	??0Data@CascadeClassifier@cv@@QAE@ABV012@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [ebx+108]
	mov	edi, DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	mov	DWORD PTR [esi+108], ecx
	mov	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [esi+112], eax
	test	eax, eax
	je	SHORT $LN9@CascadeCla
	push	1
	push	eax
	call	edi
	add	esp, 8
$LN9@CascadeCla:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR [ebx+116]
	mov	DWORD PTR [esi+116], edx
	mov	eax, DWORD PTR [ebx+120]
	mov	DWORD PTR [esi+120], eax
	test	eax, eax
	je	SHORT $LN14@CascadeCla
	push	1
	push	eax
	call	edi
	add	esp, 8
$LN14@CascadeCla:
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR [ebx+124]
	mov	DWORD PTR [esi+124], eax
	mov	ebx, DWORD PTR [ebx+128]
	mov	DWORD PTR [esi+128], ebx
	test	ebx, ebx
	je	SHORT $LN22@CascadeCla
	push	1
	push	ebx
	call	edi
	add	esp, 8
$LN22@CascadeCla:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$0:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 4
	jmp	??1Data@CascadeClassifier@cv@@QAE@XZ
__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$1:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 108				; 0000006cH
	jmp	??1?$Ptr@VFeatureEvaluator@cv@@@cv@@QAE@XZ ; cv::Ptr<cv::FeatureEvaluator>::~Ptr<cv::FeatureEvaluator>
__unwindfunclet$??0CascadeClassifier@cv@@QAE@ABV01@@Z$2:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 116				; 00000074H
	jmp	??1?$Ptr@UCvHaarClassifierCascade@@@cv@@QAE@XZ ; cv::Ptr<CvHaarClassifierCascade>::~Ptr<CvHaarClassifierCascade>
__ehhandler$??0CascadeClassifier@cv@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CascadeClassifier@cv@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CascadeClassifier@cv@@QAE@ABV01@@Z ENDP		; cv::CascadeClassifier::CascadeClassifier
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ$0
__ehfuncinfo$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T147584 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR [ecx]
	lea	esi, DWORD PTR [ecx+96]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T147584[ebp], esi
	mov	DWORD PTR [ecx+esi-96], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	lea	ecx, DWORD PTR [esi-72]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR [esi-72]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ$0:
	mov	ecx, DWORD PTR $T147584[ebp]
	sub	ecx, 72					; 00000048H
	jmp	DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	__real@7fefffffffffffff
;	COMDAT __real@7fefffffffffffff
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\imgproc\imgproc.hpp
CONST	ENDS
;	COMDAT ?morphologyDefaultBorderValue@cv@@YA?AV?$Scalar_@N@1@XZ
_TEXT	SEGMENT
?morphologyDefaultBorderValue@cv@@YA?AV?$Scalar_@N@1@XZ PROC ; cv::morphologyDefaultBorderValue, COMDAT
; ___$ReturnUdt$ = eax

; 370  : static inline Scalar morphologyDefaultBorderValue() { return Scalar::all(DBL_MAX); }

	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR __real@7fefffffffffffff
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	ret	0
?morphologyDefaultBorderValue@cv@@YA?AV?$Scalar_@N@1@XZ ENDP ; cv::morphologyDefaultBorderValue
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
_TEXT	ENDS
;	COMDAT ??0Mat@cv@@QAE@XZ
_TEXT	SEGMENT
??0Mat@cv@@QAE@XZ PROC					; cv::Mat::Mat, COMDAT
; _this$ = eax

; 68   : {

	xor	ecx, ecx
	push	esi
	lea	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+40], edx
	lea	esi, DWORD PTR [eax+48]
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [esi+4], ecx
	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [esi], ecx

; 69   :     initEmpty();

	mov	DWORD PTR [eax], 1124007936		; 42ff0000H
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+36], ecx
	pop	esi

; 70   : }

	ret	0
??0Mat@cv@@QAE@XZ ENDP					; cv::Mat::Mat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar@3
	push	esi
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@scalar@3:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
$T147765 = -36						; size = 12
__Newres$ = -24						; size = 4
$T147742 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Newsize$ = 12						; size = 4
__Oldlen$ = 16						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT

; 1918 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, DWORD PTR _this$[ebp]

; 1919 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	esi, eax
	or	esi, 15					; 0000000fH

; 1920 : 		if (max_size() < _Newres)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN9@Copy

; 1921 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	esi, eax
	jmp	SHORT $LN39@Copy
$LN9@Copy:

; 1922 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	ebx, DWORD PTR [edi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN39@Copy

; 1923 : 			;
; 1924 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, -2					; fffffffeH
	sub	eax, ecx

; 1925 : 			_Newres = this->_Myres
; 1926 : 				+ this->_Myres / 2;	// grow exponentially if possible

	lea	esi, DWORD PTR [ecx+ebx]
	cmp	ebx, eax
	jbe	SHORT $LN39@Copy

; 1927 : 		else
; 1928 : 			_Newres = max_size();	// settle for max_size()

	mov	esi, -2					; fffffffeH
$LN39@Copy:

; 1929 : 
; 1930 : 		_Elem *_Ptr;
; 1931 : 		_TRY_BEGIN

	xor	eax, eax

; 1932 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	cmp	ecx, eax
	jbe	SHORT $LN47@Copy
	cmp	ecx, -1
	ja	SHORT $LN46@Copy
	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	je	SHORT $LN46@Copy
$LN47@Copy:
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN19@Copy
$LN46@Copy:
	lea	ecx, DWORD PTR $T147742[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T147765[ebp]
	mov	DWORD PTR $T147742[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T147765[ebp]
	push	edx
	mov	DWORD PTR $T147765[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN112@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1933 : 		_CATCH_ALL
; 1934 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1935 : 			_TRY_BEGIN
; 1936 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Newres$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1940 : 			_CATCH_END
; 1941 : 		_CATCH_END

	mov	eax, $LN107@Copy
	ret	0
$LN107@Copy:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN19@Copy:

; 1942 : 
; 1943 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	je	SHORT $LN78@Copy

; 1944 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN76@Copy
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN77@Copy
$LN76@Copy:
	mov	eax, edi
$LN77@Copy:
	push	ebx
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN78@Copy:

; 1945 : 		_Tidy(true);

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN88@Copy
	mov	ecx, DWORD PTR [edi]
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN88@Copy:

; 1946 : 		this->_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edi], 0
	mov	DWORD PTR [edi], eax

; 1947 : 		this->_Myres = _Newres;

	mov	DWORD PTR [edi+20], esi

; 1948 : 		_Eos(_Oldlen);

	mov	DWORD PTR [edi+16], ebx
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN102@Copy
	mov	edi, eax
$LN102@Copy:
	mov	BYTE PTR [edi+ebx], 0

; 1949 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1937 : 			_CATCH_ALL
; 1938 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN64@Copy
	mov	edx, DWORD PTR [esi]
	push	edx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN64@Copy:

; 1939 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	push	0
	mov	BYTE PTR [esi], 0
	call	__CxxThrowException@8
$LN113@Copy:
$LN111@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = eax
; __Newsize$ = esi

; 1959 : 		if (max_size() < _Newsize)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN6@Grow

; 1960 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN49@Grow:
$LN6@Grow:

; 1961 : 		if (this->_Myres < _Newsize)

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, esi
	jae	SHORT $LN3@Grow

; 1962 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	esi
	push	eax
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	edx, edx
	cmp	edx, esi
	sbb	eax, eax
	neg	eax

; 1969 : 		}

	ret	0
$LN3@Grow:

; 1963 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 1964 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1965 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 1966 : 		else if (_Newsize == 0)

	test	esi, esi
	jne	SHORT $LN46@Grow

; 1967 : 			_Eos(0);	// new size is zero, just null terminate

	mov	DWORD PTR [eax+16], esi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN44@Grow
	mov	eax, DWORD PTR [eax]
$LN44@Grow:
	mov	BYTE PTR [eax], 0
$LN46@Grow:

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	edx, edx
	cmp	edx, esi
	sbb	eax, eax
	neg	eax

; 1969 : 		}

	ret	0
$LN48@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx
; __Roff$ = ebx
; __Count$ = eax

; 892  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 893  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	push	edi
	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, ebx
	jae	SHORT $LN5@assign

; 894  : 			_Xran();	// _Roff off end

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN83@assign:
$LN5@assign:

; 895  : 		size_type _Num = _Right.size() - _Roff;

	sub	edi, ebx

; 896  : 		if (_Count < _Num)

	cmp	eax, edi
	jae	SHORT $LN4@assign

; 897  : 			_Num = _Count;	// trim _Num to size

	mov	edi, eax
$LN4@assign:

; 898  : 
; 899  : 		if (this == &_Right)

	cmp	esi, ecx
	jne	SHORT $LN3@assign

; 900  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	lea	ecx, DWORD PTR [edi+ebx]
	or	eax, -1
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	eax, ebx
	xor	ecx, ecx
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4
$LN3@assign:

; 901  : 		else if (_Grow(_Num))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN20@assign
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN84@assign:
$LN20@assign:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN19@assign
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	edi
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Right$[ebp]
	test	edi, edi
	je	SHORT $LN78@assign
$LN82@assign:

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	eax, 16					; 00000010H
	cmp	DWORD PTR [ecx+20], eax
	jb	SHORT $LN64@assign
	mov	ecx, DWORD PTR [ecx]
$LN64@assign:
	cmp	DWORD PTR [esi+20], eax
	jb	SHORT $LN68@assign
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN69@assign

; 901  : 		else if (_Grow(_Num))

$LN19@assign:
	test	edi, edi
	jne	SHORT $LN82@assign
	mov	DWORD PTR [esi+16], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN58@assign
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax], 0
	pop	edi

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4

; 901  : 		else if (_Grow(_Num))

$LN58@assign:
	mov	eax, esi
	pop	edi
	mov	BYTE PTR [eax], 0
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$LN68@assign:
	mov	eax, esi
$LN69@assign:
	push	edi
	add	ecx, ebx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 904  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], edi
	jb	SHORT $LN76@assign
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4

; 904  : 			_Eos(_Num);

$LN76@assign:
	mov	eax, esi
	mov	BYTE PTR [eax+edi], 0
$LN78@assign:

; 905  : 			}
; 906  : 		return (*this);

	pop	edi
	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4
$LN80@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$0
__ehfuncinfo$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
$T148249 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	lea	ebx, DWORD PTR [ecx-96]
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [ebx+96]
	mov	DWORD PTR $T148249[ebp], eax
	mov	DWORD PTR [edx+eax-96], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	lea	edi, DWORD PTR [eax-72]
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR [ebx+96]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN18@scalar@5
	push	ebx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN18@scalar@5:
	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$0:
	mov	ecx, DWORD PTR $T148249[ebp]
	sub	ecx, 72					; 00000048H
	jmp	DWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	__real@c000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@409f400000000000
PUBLIC	__$ArrayPad$
PUBLIC	_trackFilteredObject
;	COMDAT __real@c000000000000000
; File c:\programs & apps\visual studio 10\vc\include\vector
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@409f400000000000
CONST	SEGMENT
__real@409f400000000000 DQ 0409f400000000000r	; 2000
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
CONST	ENDS
;	COMDAT _trackFilteredObject
_TEXT	SEGMENT
_moment$127475 = -424					; size = 192
$T148270 = -228						; size = 20
$T148269 = -228						; size = 20
$T148267 = -208						; size = 20
$T148268 = -188						; size = 20
$T148265 = -188						; size = 20
$T148271 = -168						; size = 8
_refArea$ = -168					; size = 8
_contours$ = -156					; size = 16
_hierarchy$ = -140					; size = 16
tv1017 = -124						; size = 4
_x$ = -124						; size = 4
$T148266 = -124						; size = 4
_objectFound$ = -117					; size = 1
_temp$ = -116						; size = 56
$T127485 = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_thresholded$ = 8					; size = 56
_trackFilteredObject PROC				; COMDAT

; 117  : 		double trackFilteredObject(Mat thresholded){

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 118  : 			int x, y;
; 119  : 			double axis = -2.0;
; 120  : 			Mat temp;

	xor	ebx, ebx
	push	esi

; 121  : 			thresholded.copyTo(temp);

	mov	esi, DWORD PTR __imp_??0_OutputArray@cv@@QAE@AAVMat@1@@Z
	lea	ecx, DWORD PTR _temp$[ebp+48]
	push	edi
	lea	edx, DWORD PTR _temp$[ebp]
	lea	eax, DWORD PTR _temp$[ebp+8]
	mov	DWORD PTR _temp$[ebp+44], ecx
	push	edx
	lea	ecx, DWORD PTR $T148265[ebp]
	mov	DWORD PTR _temp$[ebp+40], eax
	mov	DWORD PTR _temp$[ebp+52], ebx
	mov	DWORD PTR _temp$[ebp+48], ebx
	mov	DWORD PTR _temp$[ebp], 1124007936	; 42ff0000H
	mov	DWORD PTR _temp$[ebp+12], ebx
	mov	DWORD PTR _temp$[ebp+8], ebx
	mov	DWORD PTR _temp$[ebp+4], ebx
	mov	DWORD PTR _temp$[ebp+32], ebx
	mov	DWORD PTR _temp$[ebp+28], ebx
	mov	DWORD PTR _temp$[ebp+24], ebx
	mov	DWORD PTR _temp$[ebp+16], ebx
	mov	DWORD PTR _temp$[ebp+20], ebx
	mov	DWORD PTR _temp$[ebp+36], ebx
	call	esi
	lea	eax, DWORD PTR $T148265[ebp]
	push	eax
	lea	ecx, DWORD PTR _thresholded$[ebp]
	call	DWORD PTR __imp_?copyTo@Mat@cv@@QBEXABV_OutputArray@2@@Z

; 122  : 			//these two vectors needed for output of findContours
; 123  : 			vector< vector<Point> > contours;
; 124  : 			vector<Vec4i> hierarchy;
; 125  : 			//find contours of filtered image using openCV findContours function
; 126  : 			findContours(temp,contours,hierarchy,CV_RETR_CCOMP,CV_CHAIN_APPROX_SIMPLE );

	mov	eax, OFFSET ??_7_OutputArray@cv@@6B@
	lea	ecx, DWORD PTR _hierarchy$[ebp]
	mov	DWORD PTR $T148267[ebp], eax
	mov	DWORD PTR $T148268[ebp], eax
	lea	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR $T148267[ebp+8], ecx
	lea	edx, DWORD PTR _contours$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T148269[ebp]
	mov	DWORD PTR _contours$[ebp], ebx
	mov	DWORD PTR _contours$[ebp+4], ebx
	mov	DWORD PTR _contours$[ebp+8], ebx
	mov	DWORD PTR _hierarchy$[ebp], ebx
	mov	DWORD PTR _hierarchy$[ebp+4], ebx
	mov	DWORD PTR _hierarchy$[ebp+8], ebx
	mov	DWORD PTR $T148267[ebp+4], -2147287012	; 8003001cH
	mov	DWORD PTR $T148267[ebp+12], ebx
	mov	DWORD PTR $T148267[ebp+16], ebx
	mov	DWORD PTR $T148268[ebp+4], -2147221492	; 8004000cH
	mov	DWORD PTR $T148268[ebp+8], edx
	mov	DWORD PTR $T148268[ebp+12], ebx
	mov	DWORD PTR $T148268[ebp+16], ebx
	call	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T148266[ebp], esp
	push	2
	push	2
	lea	ecx, DWORD PTR $T148267[ebp]
	push	ecx
	lea	edx, DWORD PTR $T148268[ebp]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	push	edx
	lea	eax, DWORD PTR $T148269[ebp]
	push	eax
	call	DWORD PTR __imp_?findContours@cv@@YAXABV_OutputArray@1@00HHV?$Point_@H@1@@Z

; 127  : 			//use moments method to find our filtered object
; 128  : 			double refArea = 0;

	fldz

; 129  : 			bool objectFound = false;
; 130  : 			if (hierarchy.size() > 0) {

	mov	eax, DWORD PTR _hierarchy$[ebp+4]
	fstp	QWORD PTR _refArea$[ebp]
	mov	ecx, DWORD PTR _hierarchy$[ebp]
	sub	eax, ecx
	sar	eax, 4
	add	esp, 28					; 0000001cH
	cmp	eax, ebx
	jbe	$LN1@trackFilte

; 131  : 				int numObjects = hierarchy.size();
; 132  : 				//if number of objects greater than MAX_NUM_OBJECTS we have a noisy filter
; 133  : 				if(numObjects<MAX_NUM_OBJECTS){

	cmp	eax, 50					; 00000032H
	jge	$LN1@trackFilte

; 134  : 					objectFound = false;

	mov	BYTE PTR _objectFound$[ebp], bl

; 135  : 					for (int index = 0; index >= 0; index = hierarchy[index][0]) {

	xor	esi, esi
$LN5@trackFilte:

; 136  : 
; 137  : 						Moments moment = moments((cv::Mat)contours[index]);

	mov	ecx, DWORD PTR _contours$[ebp]
	add	esi, esi
	mov	DWORD PTR $T127485[ebp], 1124024332	; 42ff400cH
	mov	DWORD PTR $T127485[ebp+4], 2
	mov	eax, DWORD PTR [ecx+esi*8+4]
	sub	eax, DWORD PTR [ecx+esi*8]
	lea	edx, DWORD PTR $T127485[ebp+8]
	mov	DWORD PTR $T127485[ebp+40], edx
	sar	eax, 3
	lea	edx, DWORD PTR $T127485[ebp+48]
	mov	DWORD PTR $T127485[ebp+8], eax
	mov	DWORD PTR $T127485[ebp+12], 1
	mov	DWORD PTR $T127485[ebp+16], ebx
	mov	DWORD PTR $T127485[ebp+20], ebx
	mov	DWORD PTR $T127485[ebp+24], ebx
	mov	DWORD PTR $T127485[ebp+28], ebx
	mov	DWORD PTR $T127485[ebp+36], ebx
	mov	DWORD PTR $T127485[ebp+44], edx
	mov	DWORD PTR $T127485[ebp+52], ebx
	mov	DWORD PTR $T127485[ebp+48], ebx
	mov	edx, DWORD PTR [ecx+esi*8]
	cmp	edx, DWORD PTR [ecx+esi*8+4]
	je	SHORT $LN58@trackFilte
	mov	edx, 8
	mov	DWORD PTR $T127485[ebp+52], edx
	mov	DWORD PTR $T127485[ebp+48], edx
	mov	ecx, DWORD PTR [ecx+esi*8]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T127485[ebp+24], ecx
	mov	DWORD PTR $T127485[ebp+16], ecx
	mov	DWORD PTR $T127485[ebp+28], eax
	mov	DWORD PTR $T127485[ebp+32], eax
$LN58@trackFilte:
	lea	eax, DWORD PTR $T127485[ebp]
	push	eax
	lea	ecx, DWORD PTR $T148270[ebp]
	call	DWORD PTR __imp_??0_InputArray@cv@@QAE@ABVMat@1@@Z
	push	ebx
	lea	ecx, DWORD PTR $T148270[ebp]
	push	ecx
	lea	edx, DWORD PTR _moment$127475[ebp]
	push	edx
	call	DWORD PTR __imp_?moments@cv@@YA?AVMoments@1@ABV_InputArray@1@_N@Z
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR $T127485[ebp]
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat

; 138  : 						double area = moment.m00;
; 139  : 
; 140  : 						//if the area is less than 20 px by 20px then it is probably just noise
; 141  : 						//if the area is the same as the 3/2 of the image size, probably just a bad filter
; 142  : 						//we only want the object with the largest area so we safe a reference area each
; 143  : 						//iteration and compare it to the area in the next iteration.
; 144  : 						if(area>MIN_OBJECT_AREA && area<MAX_OBJECT_AREA && area>refArea){

	fld	QWORD PTR __real@409f400000000000
	fld	QWORD PTR _moment$127475[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	SHORT $LN164@trackFilte
	fild	DWORD PTR ?MAX_OBJECT_AREA@@3HA		; MAX_OBJECT_AREA
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN164@trackFilte
	fld	QWORD PTR _refArea$[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN164@trackFilte

; 145  : 							x = moment.m10/area;

	fld	QWORD PTR _moment$127475[ebp+8]
	fdiv	ST(0), ST(1)
	call	__ftol2_sse

; 146  : 							y = moment.m01/area;
; 147  : 							objectFound = true;
; 148  : 							refArea = area;

	fstp	QWORD PTR _refArea$[ebp]
	mov	DWORD PTR _x$[ebp], eax
	mov	BYTE PTR _objectFound$[ebp], 1
	jmp	SHORT $LN4@trackFilte
$LN164@trackFilte:

; 138  : 						double area = moment.m00;
; 139  : 
; 140  : 						//if the area is less than 20 px by 20px then it is probably just noise
; 141  : 						//if the area is the same as the 3/2 of the image size, probably just a bad filter
; 142  : 						//we only want the object with the largest area so we safe a reference area each
; 143  : 						//iteration and compare it to the area in the next iteration.
; 144  : 						if(area>MIN_OBJECT_AREA && area<MAX_OBJECT_AREA && area>refArea){

	fstp	ST(0)
$LN4@trackFilte:

; 135  : 					for (int index = 0; index >= 0; index = hierarchy[index][0]) {

	mov	ecx, DWORD PTR _hierarchy$[ebp]
	mov	esi, DWORD PTR [ecx+esi*8]
	cmp	esi, ebx
	jge	$LN5@trackFilte

; 149  : 						}
; 150  : 					}
; 151  : 					if(objectFound == true){

	cmp	BYTE PTR _objectFound$[ebp], 1
	jne	$LN1@trackFilte

; 152  : 						/*if( x > width/2 + 20)
; 153  : 							axis = 1; //RIGHT
; 154  : 						else if( x < width/2 - 20)
; 155  : 							axis = -1; //LEFT
; 156  : 						else axis = 0; //STRAIGHT*/
; 157  : 						axisValue = (double)((2.0*x/width)-1.0);
; 158  : 						return (double)(2*x/width)-1.0;

	mov	eax, DWORD PTR _x$[ebp]
	fild	DWORD PTR _x$[ebp]
	add	eax, eax
	cdq
	idiv	DWORD PTR _width
	fadd	ST(0), ST(0)
	fidiv	DWORD PTR _width
	fld1
	fsub	ST(1), ST(0)
	fxch	ST(1)
	mov	DWORD PTR tv1017[ebp], eax
	fstp	QWORD PTR _axisValue
	fild	DWORD PTR tv1017[ebp]
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR $T148271[ebp]
	cmp	ecx, ebx
	je	SHORT $LN90@trackFilte
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN90@trackFilte:
	mov	DWORD PTR _hierarchy$[ebp], ebx
	mov	DWORD PTR _hierarchy$[ebp+4], ebx
	mov	DWORD PTR _hierarchy$[ebp+8], ebx
	lea	ebx, DWORD PTR _contours$[ebp]
	call	?_Tidy@?$vector@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@V?$allocator@V?$vector@V?$Point_@H@cv@@V?$allocator@V?$Point_@H@cv@@@std@@@std@@@2@@std@@IAEXXZ ; std::vector<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > >,std::allocator<std::vector<cv::Point_<int>,std::allocator<cv::Point_<int> > > > >::_Tidy
	lea	eax, DWORD PTR _temp$[ebp]
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	lea	eax, DWORD PTR _thresholded$[ebp]
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	fld	QWORD PTR $T148271[ebp]

; 164  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@trackFilte:

; 159  : 
; 160  : 					}
; 161  : 				}
; 162  : 			}
; 163  : 			return axis;

	cmp	ecx, ebx
	je	SHORT $LN105@trackFilte
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN105@trackFilte:
	mov	esi, DWORD PTR _contours$[ebp]
	mov	DWORD PTR _hierarchy$[ebp], ebx
	mov	DWORD PTR _hierarchy$[ebp+4], ebx
	mov	DWORD PTR _hierarchy$[ebp+8], ebx
	cmp	esi, ebx
	je	SHORT $LN147@trackFilte
	mov	eax, DWORD PTR _contours$[ebp+4]
	mov	edi, eax
	cmp	esi, eax
	je	SHORT $LN122@trackFilte
	npad	7
$LL124@trackFilte:
	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	je	SHORT $LN143@trackFilte
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN143@trackFilte:
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	add	esi, 16					; 00000010H
	cmp	esi, edi
	jne	SHORT $LL124@trackFilte
	mov	esi, DWORD PTR _contours$[ebp]
$LN122@trackFilte:
	push	esi
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN147@trackFilte:
	lea	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _contours$[ebp], ebx
	mov	DWORD PTR _contours$[ebp+4], ebx
	mov	DWORD PTR _contours$[ebp+8], ebx
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	lea	eax, DWORD PTR _thresholded$[ebp]
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	fld	QWORD PTR __real@c000000000000000

; 164  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_trackFilteredObject ENDP
_TEXT	ENDS
PUBLIC	__real@4076800000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff199999999999a
PUBLIC	__$ArrayPad$
PUBLIC	?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z ; CVDetector::detectAndDisplay
;	COMDAT __real@4076800000000000
; File c:\programs & apps\visual studio 10\vc\include\vector
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff199999999999a
CONST	SEGMENT
__real@3ff199999999999a DQ 03ff199999999999ar	; 1.1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$5
__ehfuncinfo$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
xdata$x	ENDS
;	COMDAT ?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z
_TEXT	SEGMENT
$T148858 = -180						; size = 20
$T148855 = -180						; size = 20
_center$126373 = -160					; size = 8
$T149018 = -152						; size = 4
$T148864 = -148						; size = 4
$T148863 = -148						; size = 4
tv1236 = -144						; size = 4
_disableSigns$ = -140					; size = 16
_enableSigns$ = -124					; size = 16
$T148977 = -108						; size = 4
$T148862 = -108						; size = 4
$T148861 = -108						; size = 4
$T148860 = -108						; size = 4
$T148859 = -108						; size = 4
$T126375 = -104						; size = 32
$T148857 = -92						; size = 20
$T148856 = -92						; size = 20
_frame_gray$ = -72					; size = 56
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_enableCascade$ = 8					; size = 132
_disableCascade$ = 140					; size = 132
_frame$ = 272						; size = 56
?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z PROC ; CVDetector::detectAndDisplay, COMDAT

; 84   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp+8], ebx

; 85   : 		std::vector<Rect> enableSigns, disableSigns;

	mov	DWORD PTR _enableSigns$[ebp], ebx
	mov	DWORD PTR _enableSigns$[ebp+4], ebx
	mov	DWORD PTR _enableSigns$[ebp+8], ebx
	mov	DWORD PTR _disableSigns$[ebp], ebx
	mov	DWORD PTR _disableSigns$[ebp+4], ebx
	mov	DWORD PTR _disableSigns$[ebp+8], ebx

; 86   : 		Mat frame_gray;

	lea	eax, DWORD PTR _frame_gray$[ebp+8]
	lea	ecx, DWORD PTR _frame_gray$[ebp+48]
	mov	DWORD PTR _frame_gray$[ebp+40], eax
	mov	DWORD PTR _frame_gray$[ebp+44], ecx
	mov	DWORD PTR _frame_gray$[ebp+52], ebx
	mov	DWORD PTR _frame_gray$[ebp+48], ebx
	mov	DWORD PTR _frame_gray$[ebp], 1124007936	; 42ff0000H
	mov	DWORD PTR _frame_gray$[ebp+12], ebx
	mov	DWORD PTR _frame_gray$[ebp+8], ebx
	mov	DWORD PTR _frame_gray$[ebp+4], ebx
	mov	DWORD PTR _frame_gray$[ebp+32], ebx
	mov	DWORD PTR _frame_gray$[ebp+28], ebx
	mov	DWORD PTR _frame_gray$[ebp+24], ebx
	mov	DWORD PTR _frame_gray$[ebp+16], ebx
	mov	DWORD PTR _frame_gray$[ebp+20], ebx
	mov	DWORD PTR _frame_gray$[ebp+36], ebx

; 87   : 
; 88   : 		cvtColor( frame, frame_gray, CV_BGR2GRAY );

	lea	edx, DWORD PTR _frame_gray$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	esi, DWORD PTR __imp_??0_OutputArray@cv@@QAE@AAVMat@1@@Z
	push	edx
	lea	ecx, DWORD PTR $T148855[ebp]
	call	esi
	mov	edi, DWORD PTR __imp_??0_InputArray@cv@@QAE@ABVMat@1@@Z
	lea	eax, DWORD PTR _frame$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T148856[ebp]
	call	edi
	push	ebx
	push	6
	lea	ecx, DWORD PTR $T148855[ebp]
	push	ecx
	lea	edx, DWORD PTR $T148856[ebp]
	push	edx
	call	DWORD PTR __imp_?cvtColor@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@HH@Z
	add	esp, 16					; 00000010H

; 89   : 		equalizeHist( frame_gray, frame_gray );

	lea	eax, DWORD PTR _frame_gray$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T148857[ebp]
	call	esi
	lea	ecx, DWORD PTR _frame_gray$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T148858[ebp]
	call	edi
	lea	edx, DWORD PTR $T148857[ebp]
	push	edx
	lea	eax, DWORD PTR $T148858[ebp]
	push	eax
	call	DWORD PTR __imp_?equalizeHist@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@@Z

; 90   : 
; 91   : 		//-- Detect signs, load 'em up into appropriate arrays
; 92   : 		enableCascade.detectMultiScale( frame_gray, enableSigns, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(30, 30)  );

	fld	QWORD PTR __real@3ff199999999999a
	mov	eax, esp
	mov	DWORD PTR $T148859[ebp], esp
	sub	esp, 8
	mov	DWORD PTR $T148860[ebp], esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	eax, esp
	push	2
	push	2
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	ecx, DWORD PTR _enableSigns$[ebp]
	mov	edi, 30					; 0000001eH
	push	ecx
	lea	edx, DWORD PTR _frame_gray$[ebp]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	push	edx
	mov	esi, DWORD PTR __imp_?detectMultiScale@CascadeClassifier@cv@@UAEXABVMat@2@AAV?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@NHHV?$Size_@H@2@2@Z
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	call	esi

; 93   : 		disableCascade.detectMultiScale( frame_gray, disableSigns, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(30, 30));

	fld	QWORD PTR __real@3ff199999999999a
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T148861[ebp], esp
	sub	esp, 8
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	eax, esp
	mov	DWORD PTR $T148862[ebp], esp
	push	2
	push	2
	sub	esp, 8
	mov	DWORD PTR [eax], edi
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [eax+4], edi
	lea	eax, DWORD PTR _disableSigns$[ebp]
	push	eax
	lea	ecx, DWORD PTR _frame_gray$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	call	esi

; 94   : 		for( size_t i = 0; i < enableSigns.size(); i++ )

	mov	eax, DWORD PTR _enableSigns$[ebp+4]
	mov	ecx, DWORD PTR _enableSigns$[ebp]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 4
	xor	edi, edi
	test	edx, edx
	je	$LN3@detectAndD

; 84   : 	{

	mov	DWORD PTR tv1236[ebp], ebx
$LL172@detectAndD:
	fld	QWORD PTR __real@3fe0000000000000

; 95   : 		{
; 96   : 			Point center( enableSigns[i].x + enableSigns[i].width*0.5, enableSigns[i].y + enableSigns[i].height*0.5 );

	mov	esi, DWORD PTR tv1236[ebp]
	fld	QWORD PTR __real@406fe00000000000
	add	esi, ecx
	fldz
	fild	DWORD PTR [esi+12]
	fmul	ST(0), ST(3)
	fiadd	DWORD PTR [esi+4]
	call	__ftol2_sse
	fild	DWORD PTR [esi+8]
	mov	DWORD PTR $T148977[ebp], eax
	fmul	ST(0), ST(3)
	fiadd	DWORD PTR [esi]
	call	__ftol2_sse

; 97   : 			ellipse( frame, center, Size( enableSigns[i].width*0.5, enableSigns[i].height*0.5), 0, 0, 360, Scalar( 255, 0, 255 ), 4, 8, 0 );

	fxch	ST(1)
	mov	DWORD PTR _center$126373[ebp], eax
	xor	eax, eax
	push	ebx
	mov	DWORD PTR $T126375[ebp], eax
	mov	DWORD PTR $T126375[ebp+4], eax
	fst	QWORD PTR $T126375[ebp]
	mov	DWORD PTR $T126375[ebp+16], eax
	mov	DWORD PTR $T126375[ebp+20], eax
	fstp	QWORD PTR $T126375[ebp+16]
	push	8
	mov	DWORD PTR $T126375[ebp+8], eax
	mov	DWORD PTR $T126375[ebp+12], eax
	fst	QWORD PTR $T126375[ebp+8]
	push	4
	lea	ecx, DWORD PTR $T126375[ebp]
	mov	DWORD PTR $T126375[ebp+24], eax
	mov	DWORD PTR $T126375[ebp+28], eax
	fst	QWORD PTR $T126375[ebp+24]
	fld	QWORD PTR __real@4076800000000000
	push	ecx
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	fild	DWORD PTR [esi+12]
	fmul	ST(0), ST(1)
	call	__ftol2_sse
	fimul	DWORD PTR [esi+8]
	mov	DWORD PTR $T149018[ebp], eax
	call	__ftol2_sse
	mov	edx, DWORD PTR $T149018[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR $T148863[ebp], esp
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR _center$126373[ebp]
	mov	edx, DWORD PTR $T148977[ebp]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	lea	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR $T148864[ebp], esp
	push	eax
	call	DWORD PTR __imp_?ellipse@cv@@YAXAAVMat@1@V?$Point_@H@1@V?$Size_@H@1@NNNABV?$Scalar_@N@1@HHH@Z
	mov	eax, DWORD PTR _enableSigns$[ebp+4]
	mov	ecx, DWORD PTR _enableSigns$[ebp]
	add	DWORD PTR tv1236[ebp], 16		; 00000010H
	mov	edx, eax
	sub	edx, ecx
	inc	edi
	sar	edx, 4
	add	esp, 60					; 0000003cH
	cmp	edi, edx
	jb	$LL172@detectAndD
$LN3@detectAndD:

; 98   : 		}
; 99   : 
; 100  : 		//-- Show what you got
; 101  : 		//imshow( window_name, frame ); // -----------> comment this for release
; 102  : 
; 103  : 		if (enableSigns.size() > 0)

	sub	eax, ecx
	sar	eax, 4
	test	eax, eax
	je	$LN2@detectAndD

; 104  : 			return 1;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _frame_gray$[ebp+20]
	mov	edi, DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	cmp	eax, ebx
	je	SHORT $LN83@detectAndD
	push	-1
	push	eax
	call	edi
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN83@detectAndD
	lea	ecx, DWORD PTR _frame_gray$[ebp]
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN83@detectAndD:
	xor	eax, eax
	mov	DWORD PTR _frame_gray$[ebp+32], ebx
	mov	DWORD PTR _frame_gray$[ebp+28], ebx
	mov	DWORD PTR _frame_gray$[ebp+24], ebx
	mov	DWORD PTR _frame_gray$[ebp+16], ebx
	cmp	DWORD PTR _frame_gray$[ebp+4], ebx
	jle	SHORT $LN80@detectAndD
$LL82@detectAndD:
	mov	ecx, DWORD PTR _frame_gray$[ebp+40]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	eax
	cmp	eax, DWORD PTR _frame_gray$[ebp+4]
	jl	SHORT $LL82@detectAndD
$LN80@detectAndD:
	mov	eax, DWORD PTR _frame_gray$[ebp+44]
	lea	edx, DWORD PTR _frame_gray$[ebp+48]
	mov	DWORD PTR _frame_gray$[ebp+20], ebx
	cmp	eax, edx
	je	SHORT $LN77@detectAndD
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN77@detectAndD:
	mov	eax, DWORD PTR _disableSigns$[ebp]
	mov	esi, DWORD PTR __imp_??3@YAXPAX@Z
	cmp	eax, ebx
	je	SHORT $LN93@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN93@detectAndD:
	mov	eax, DWORD PTR _enableSigns$[ebp]
	mov	DWORD PTR _disableSigns$[ebp], ebx
	mov	DWORD PTR _disableSigns$[ebp+4], ebx
	mov	DWORD PTR _disableSigns$[ebp+8], ebx
	cmp	eax, ebx
	je	SHORT $LN104@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN104@detectAndD:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _frame$[ebp+20]
	mov	DWORD PTR _enableSigns$[ebp], ebx
	mov	DWORD PTR _enableSigns$[ebp+4], ebx
	mov	DWORD PTR _enableSigns$[ebp+8], ebx
	cmp	eax, ebx
	je	SHORT $LN114@detectAndD
	push	-1
	push	eax
	call	edi
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN114@detectAndD
	lea	ecx, DWORD PTR _frame$[ebp]
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN114@detectAndD:
	xor	eax, eax
	mov	DWORD PTR _frame$[ebp+32], ebx
	mov	DWORD PTR _frame$[ebp+28], ebx
	mov	DWORD PTR _frame$[ebp+24], ebx
	mov	DWORD PTR _frame$[ebp+16], ebx
	cmp	DWORD PTR _frame$[ebp+4], ebx
	jle	SHORT $LN111@detectAndD
$LL113@detectAndD:
	mov	ecx, DWORD PTR _frame$[ebp+40]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	eax
	cmp	eax, DWORD PTR _frame$[ebp+4]
	jl	SHORT $LL113@detectAndD
$LN111@detectAndD:
	mov	eax, DWORD PTR _frame$[ebp+44]
	lea	edx, DWORD PTR _frame$[ebp+48]
	mov	DWORD PTR _frame$[ebp+20], ebx
	cmp	eax, edx
	je	SHORT $LN108@detectAndD
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN108@detectAndD:
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	mov	esi, DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	call	esi
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	esi
	mov	eax, 1
	jmp	$LN6@detectAndD
$LN2@detectAndD:

; 105  : 		if (disableSigns.size() > 0)

	mov	eax, DWORD PTR _disableSigns$[ebp+4]
	sub	eax, DWORD PTR _disableSigns$[ebp]

; 106  : 			return 2;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	sar	eax, 4
	test	eax, eax
	lea	eax, DWORD PTR _frame_gray$[ebp]
	je	$LN1@detectAndD
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	eax, DWORD PTR _disableSigns$[ebp]
	mov	esi, DWORD PTR __imp_??3@YAXPAX@Z
	cmp	eax, ebx
	je	SHORT $LN126@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN126@detectAndD:
	mov	eax, DWORD PTR _enableSigns$[ebp]
	mov	DWORD PTR _disableSigns$[ebp], ebx
	mov	DWORD PTR _disableSigns$[ebp+4], ebx
	mov	DWORD PTR _disableSigns$[ebp+8], ebx
	cmp	eax, ebx
	je	SHORT $LN137@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN137@detectAndD:
	lea	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _enableSigns$[ebp], ebx
	mov	DWORD PTR _enableSigns$[ebp+4], ebx
	mov	DWORD PTR _enableSigns$[ebp+8], ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	mov	esi, DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	call	esi
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	esi
	mov	eax, 2
	jmp	SHORT $LN6@detectAndD
$LN1@detectAndD:

; 107  : 		// otherwise
; 108  : 		return 0;

	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	eax, DWORD PTR _disableSigns$[ebp]
	mov	esi, DWORD PTR __imp_??3@YAXPAX@Z
	cmp	eax, ebx
	je	SHORT $LN148@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN148@detectAndD:
	mov	eax, DWORD PTR _enableSigns$[ebp]
	mov	DWORD PTR _disableSigns$[ebp], ebx
	mov	DWORD PTR _disableSigns$[ebp+4], ebx
	mov	DWORD PTR _disableSigns$[ebp+8], ebx
	cmp	eax, ebx
	je	SHORT $LN159@detectAndD
	push	eax
	call	esi
	add	esp, 4
$LN159@detectAndD:
	lea	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _enableSigns$[ebp], ebx
	mov	DWORD PTR _enableSigns$[ebp+4], ebx
	mov	DWORD PTR _enableSigns$[ebp+8], ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	mov	esi, DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	call	esi
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	esi
	xor	eax, eax
$LN6@detectAndD:

; 109  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$0:
	lea	ecx, DWORD PTR _disableCascade$[ebp]
	jmp	DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$1:
	lea	ecx, DWORD PTR _enableCascade$[ebp]
	jmp	DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$2:
	lea	eax, DWORD PTR _frame$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$3:
	lea	esi, DWORD PTR _enableSigns$[ebp]
	jmp	??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$4:
	lea	esi, DWORD PTR _disableSigns$[ebp]
	jmp	??1?$vector@V?$Rect_@H@cv@@V?$allocator@V?$Rect_@H@cv@@@std@@@std@@QAE@XZ ; std::vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >::~vector<cv::Rect_<int>,std::allocator<cv::Rect_<int> > >
__unwindfunclet$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z$5:
	lea	eax, DWORD PTR _frame_gray$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__ehhandler$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z ENDP ; CVDetector::detectAndDisplay
PUBLIC	_hwnd$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z ; CVDetector::hwnd2mat
_hDesktopWnd DD	01H DUP (?)
;	COMDAT xdata$x
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
xdata$x	SEGMENT
__unwindtable$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z$0
__ehfuncinfo$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
xdata$x	ENDS
;	COMDAT ?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -104				; size = 4
_sz$149313 = -100					; size = 8
_srcheight$ = -92					; size = 4
_srcwidth$ = -88					; size = 4
_hwnd$GSCopy$ = -84					; size = 4
_hwindowDC$ = -80					; size = 4
$T149285 = -76						; size = 4
_hbwindow$ = -76					; size = 4
_windowsize$ = -72					; size = 16
_bi$ = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z PROC	; CVDetector::hwnd2mat, COMDAT
; ___$ReturnUdt$ = esi

; 30   : 	Mat hwnd2mat(HWND hwnd){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 31   : 
; 32   : 		HDC hwindowDC,hwindowCompatibleDC;
; 33   : 
; 34   : 		int srcheight,srcwidth;
; 35   : 		HBITMAP hbwindow;
; 36   : 		Mat src;
; 37   : 		BITMAPINFOHEADER  bi;
; 38   : 
; 39   : 
; 40   : 
; 41   : 		hwindowDC=GetDC(hwnd);
; 42   : 		hwindowCompatibleDC=CreateCompatibleDC(hwindowDC);
; 43   : 		SetStretchBltMode(hwindowCompatibleDC,COLORONCOLOR);  
; 44   : 
; 45   : 		RECT windowsize;    // get the height and width of the screen
; 46   : 		GetClientRect(hwnd, &windowsize);
; 47   : 
; 48   : 		srcheight = windowsize.bottom;
; 49   : 		srcwidth = windowsize.right;
; 50   : 		height = windowsize.bottom;  //change this to whatever size you want to resize to
; 51   : 		width = windowsize.right;
; 52   : 
; 53   : 		src.create(height,width,CV_8UC4);

	xor	edi, edi
	mov	DWORD PTR $T149285[ebp], edi
	mov	edx, DWORD PTR _hDesktopWnd
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+40], ecx
	lea	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [eax+4], edi
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
	mov	DWORD PTR _hwnd$GSCopy$[ebp], edx
	mov	DWORD PTR [esi], 1124007936		; 42ff0000H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+36], edi

; 79   : 
; 80   : 		return src;

	mov	DWORD PTR __$EHRec$[ebp+8], edi
	push	edx
	mov	DWORD PTR $T149285[ebp], 1
	call	DWORD PTR __imp__GetDC@4
	push	eax
	mov	DWORD PTR _hwindowDC$[ebp], eax
	call	DWORD PTR __imp__CreateCompatibleDC@4
	mov	ebx, eax
	push	3
	push	ebx
	call	DWORD PTR __imp__SetStretchBltMode@8
	mov	edx, DWORD PTR _hwnd$GSCopy$[ebp]
	lea	ecx, DWORD PTR _windowsize$[ebp]
	push	ecx
	push	edx
	call	DWORD PTR __imp__GetClientRect@8
	cmp	DWORD PTR [esi+4], 2
	mov	eax, DWORD PTR _windowsize$[ebp+12]
	mov	ecx, DWORD PTR _windowsize$[ebp+8]
	mov	DWORD PTR _srcheight$[ebp], eax
	mov	DWORD PTR _srcwidth$[ebp], ecx
	mov	DWORD PTR _height, eax
	mov	DWORD PTR _width, ecx
	jg	SHORT $LN13@hwnd2mat

; 31   : 
; 32   : 		HDC hwindowDC,hwindowCompatibleDC;
; 33   : 
; 34   : 		int srcheight,srcwidth;
; 35   : 		HBITMAP hbwindow;
; 36   : 		Mat src;
; 37   : 		BITMAPINFOHEADER  bi;
; 38   : 
; 39   : 
; 40   : 
; 41   : 		hwindowDC=GetDC(hwnd);
; 42   : 		hwindowCompatibleDC=CreateCompatibleDC(hwindowDC);
; 43   : 		SetStretchBltMode(hwindowCompatibleDC,COLORONCOLOR);  
; 44   : 
; 45   : 		RECT windowsize;    // get the height and width of the screen
; 46   : 		GetClientRect(hwnd, &windowsize);
; 47   : 
; 48   : 		srcheight = windowsize.bottom;
; 49   : 		srcwidth = windowsize.right;
; 50   : 		height = windowsize.bottom;  //change this to whatever size you want to resize to
; 51   : 		width = windowsize.right;
; 52   : 
; 53   : 		src.create(height,width,CV_8UC4);

	cmp	DWORD PTR [esi+8], eax
	jne	SHORT $LN13@hwnd2mat
	cmp	DWORD PTR [esi+12], ecx
	jne	SHORT $LN13@hwnd2mat
	mov	edx, DWORD PTR [esi]
	and	edx, 4095				; 00000fffH
	cmp	edx, 24					; 00000018H
	jne	SHORT $LN13@hwnd2mat
	cmp	DWORD PTR [esi+16], edi
	jne	SHORT $LN14@hwnd2mat
$LN13@hwnd2mat:
	mov	DWORD PTR _sz$149313[ebp], eax
	push	24					; 00000018H
	lea	eax, DWORD PTR _sz$149313[ebp]
	push	eax
	mov	DWORD PTR _sz$149313[ebp+4], ecx
	push	2
	mov	ecx, esi
	call	DWORD PTR __imp_?create@Mat@cv@@QAEXHPBHH@Z
$LN14@hwnd2mat:

; 54   : 
; 55   : 		MAX_OBJECT_AREA = height/2*width/7;

	mov	eax, DWORD PTR _height
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	imul	ecx, DWORD PTR _width
	mov	eax, -1840700269			; 92492493H
	imul	ecx

; 56   : 
; 57   : 		// create a bitmap
; 58   : 		hbwindow = CreateCompatibleBitmap( hwindowDC, width, height);

	mov	eax, DWORD PTR _width
	add	edx, ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	edx, DWORD PTR _height
	push	edx
	mov	DWORD PTR ?MAX_OBJECT_AREA@@3HA, ecx	; MAX_OBJECT_AREA
	mov	ecx, DWORD PTR _hwindowDC$[ebp]
	push	eax
	push	ecx
	call	DWORD PTR __imp__CreateCompatibleBitmap@12

; 59   : 		bi.biSize = sizeof(BITMAPINFOHEADER);  
; 60   : 		bi.biWidth = width;    
; 61   : 		bi.biHeight = -height;  //this is the line that makes it draw upside down or not

	mov	ecx, DWORD PTR _height
	mov	edx, DWORD PTR _width

; 62   : 		bi.biPlanes = 1;    
; 63   : 		bi.biBitCount = 32;    
; 64   : 		bi.biCompression = BI_RGB;    
; 65   : 		bi.biSizeImage = 0;  
; 66   : 		bi.biXPelsPerMeter = 0;    
; 67   : 		bi.biYPelsPerMeter = 0;    
; 68   : 		bi.biClrUsed = 0;    
; 69   : 		bi.biClrImportant = 0;
; 70   : 
; 71   : 		// use the previously created device context with the bitmap
; 72   : 		SelectObject(hwindowCompatibleDC, hbwindow);

	push	eax
	neg	ecx
	push	ebx
	mov	DWORD PTR _hbwindow$[ebp], eax
	mov	DWORD PTR _bi$[ebp], 40			; 00000028H
	mov	DWORD PTR _bi$[ebp+4], edx
	mov	DWORD PTR _bi$[ebp+8], ecx
	mov	DWORD PTR _bi$[ebp+12], 2097153		; 00200001H
	mov	DWORD PTR _bi$[ebp+16], edi
	mov	DWORD PTR _bi$[ebp+20], edi
	mov	DWORD PTR _bi$[ebp+24], edi
	mov	DWORD PTR _bi$[ebp+28], edi
	mov	DWORD PTR _bi$[ebp+32], edi
	mov	DWORD PTR _bi$[ebp+36], edi
	call	DWORD PTR __imp__SelectObject@8

; 73   : 		// copy from the window device context to the bitmap device context
; 74   : 		StretchBlt( hwindowCompatibleDC, 0,0, width, height, hwindowDC, 0, 0,srcwidth,srcheight, SRCCOPY); //change SRCCOPY to NOTSRCCOPY for wacky colors !

	mov	edx, DWORD PTR _srcheight$[ebp]
	mov	eax, DWORD PTR _srcwidth$[ebp]
	mov	ecx, DWORD PTR _hwindowDC$[ebp]
	push	13369376				; 00cc0020H
	push	edx
	mov	edx, DWORD PTR _height
	push	eax
	mov	eax, DWORD PTR _width
	push	edi
	push	edi
	push	ecx
	push	edx
	push	eax
	push	edi
	push	edi
	push	ebx
	call	DWORD PTR __imp__StretchBlt@44

; 75   : 		GetDIBits(hwindowCompatibleDC,hbwindow,0,height,src.data,(BITMAPINFO *)&bi,DIB_RGB_COLORS);  //copy from hwindowCompatibleDC to hbwindow

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR _height
	push	edi
	lea	ecx, DWORD PTR _bi$[ebp]
	push	ecx
	push	edx
	push	eax
	push	edi
	mov	edi, DWORD PTR _hbwindow$[ebp]
	push	edi
	push	ebx
	call	DWORD PTR __imp__GetDIBits@28

; 76   : 
; 77   : 		// avoid memory leak
; 78   : 		DeleteObject (hbwindow); DeleteDC(hwindowCompatibleDC); ReleaseDC(hwnd, hwindowDC);

	push	edi
	call	DWORD PTR __imp__DeleteObject@4
	push	ebx
	call	DWORD PTR __imp__DeleteDC@4
	mov	ecx, DWORD PTR _hwindowDC$[ebp]
	mov	edx, DWORD PTR _hwnd$GSCopy$[ebp]
	push	ecx
	push	edx
	call	DWORD PTR __imp__ReleaseDC@8

; 79   : 
; 80   : 		return src;

	mov	eax, esi

; 81   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z$0:
	mov	eax, DWORD PTR $T149285[ebp]
	and	eax, 1
	je	$LN4@hwnd2mat
	and	DWORD PTR $T149285[ebp], -2		; fffffffeH
	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
$LN4@hwnd2mat:
	ret	0
__ehhandler$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z ENDP	; CVDetector::hwnd2mat
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = esi
; __Ptr$ = eax
; __Count$ = edi

; 910  : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebx
	mov	ebx, eax

; 911  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 912  : 		if (_Count != 0)
; 913  : 			_DEBUG_POINTER(_Ptr);
; 914  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 915  : 
; 916  : 		if (_Inside(_Ptr))

	test	ebx, ebx
	je	SHORT $LN85@assign@2
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@assign@2
$LN12@assign@2:
	mov	eax, esi
$LN13@assign@2:
	cmp	ebx, eax
	jb	SHORT $LN85@assign@2
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN16@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN17@assign@2
$LN16@assign@2:
	mov	eax, esi
$LN17@assign@2:
	mov	edx, DWORD PTR [esi+16]
	add	edx, eax
	cmp	edx, ebx
	jbe	SHORT $LN85@assign@2

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign@2
	mov	eax, DWORD PTR [esi]
	sub	ebx, eax
	push	esi
	mov	eax, edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	ebx

; 925  : 		}

	ret	0

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

$LN20@assign@2:
	mov	eax, esi
	sub	ebx, eax
	push	esi
	mov	eax, edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	ebx

; 925  : 		}

	ret	0
$LN85@assign@2:

; 918  : 
; 919  : 		if (_Grow(_Count))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@assign@2
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN90@assign@2:
$LN27@assign@2:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN26@assign@2
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	edi
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
	je	SHORT $LN82@assign@2
$LN89@assign@2:

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN72@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN73@assign@2

; 918  : 
; 919  : 		if (_Grow(_Count))

$LN26@assign@2:
	test	edi, edi
	jne	SHORT $LN89@assign@2
	mov	DWORD PTR [esi+16], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN65@assign@2
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax], 0

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 925  : 		}

	ret	0

; 918  : 
; 919  : 		if (_Grow(_Count))

$LN65@assign@2:
	mov	eax, esi
	mov	BYTE PTR [eax], 0
	pop	ebx

; 925  : 		}

	ret	0

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

$LN72@assign@2:
	mov	eax, esi
$LN73@assign@2:
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 922  : 			_Eos(_Count);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], edi
	jb	SHORT $LN80@assign@2
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi], 0

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 925  : 		}

	ret	0

; 922  : 			_Eos(_Count);

$LN80@assign@2:
	mov	eax, esi
	mov	BYTE PTR [eax+edi], 0
$LN82@assign@2:

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 925  : 		}

	ret	0
$LN87@assign@2:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; __Ptr$ = eax

; 928  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi

; 929  : 		_DEBUG_POINTER(_Ptr);
; 930  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, eax
	push	edi
	lea	esi, DWORD PTR [ecx+1]
	npad	6
$LL5@assign@3:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL5@assign@3
	sub	ecx, esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, ecx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 931  : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; __Ptr$ = eax

; 767  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi

; 768  : 		return (assign(_Ptr));

	mov	ecx, eax
	push	edi
	lea	esi, DWORD PTR [ecx+1]
	npad	6
$LL7@operator:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL7@operator
	sub	ecx, esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, ecx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 769  : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	__real@4063800000000000
PUBLIC	__real@4070000000000000
PUBLIC	__real@4035000000000000
PUBLIC	__$ArrayPad$
PUBLIC	?doTracking@RoadTracker@CVDetector@@SAXXZ	; CVDetector::RoadTracker::doTracking
;	COMDAT __real@4063800000000000
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
CONST	SEGMENT
__real@4063800000000000 DQ 04063800000000000r	; 156
CONST	ENDS
;	COMDAT __real@4070000000000000
CONST	SEGMENT
__real@4070000000000000 DQ 04070000000000000r	; 256
CONST	ENDS
;	COMDAT __real@4035000000000000
CONST	SEGMENT
__real@4035000000000000 DQ 04035000000000000r	; 21
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?doTracking@RoadTracker@CVDetector@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?doTracking@RoadTracker@CVDetector@@SAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?doTracking@RoadTracker@CVDetector@@SAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?doTracking@RoadTracker@CVDetector@@SAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?doTracking@RoadTracker@CVDetector@@SAXXZ$3
__ehfuncinfo$?doTracking@RoadTracker@CVDetector@@SAXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?doTracking@RoadTracker@CVDetector@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
xdata$x	ENDS
;	COMDAT ?doTracking@RoadTracker@CVDetector@@SAXXZ
_TEXT	SEGMENT
$T149610 = -444						; size = 4
$T149606 = -444						; size = 4
$T149601 = -444						; size = 4
$T149596 = -444						; size = 4
$T149591 = -444						; size = 4
$T149589 = -444						; size = 4
$T149588 = -444						; size = 4
$T149587 = -444						; size = 4
$T149586 = -444						; size = 4
$T149609 = -440						; size = 20
$T149604 = -440						; size = 20
$T149599 = -440						; size = 20
$T149594 = -440						; size = 20
$T149584 = -440						; size = 20
$T149580 = -440						; size = 20
$T149608 = -420						; size = 20
$T149603 = -420						; size = 20
$T149598 = -420						; size = 20
$T149593 = -420						; size = 20
$T149582 = -420						; size = 20
$T149607 = -400						; size = 20
$T149602 = -400						; size = 20
$T149597 = -400						; size = 20
$T149592 = -400						; size = 20
$T149585 = -400						; size = 20
$T149583 = -380						; size = 20
$T149581 = -380						; size = 20
$T149605 = -360						; size = 32
$T149600 = -360						; size = 32
$T149595 = -360						; size = 32
$T149590 = -360						; size = 32
$T127558 = -360						; size = 32
_dst$ = -328						; size = 56
$T127559 = -272						; size = 32
_erodeElement$ = -236					; size = 56
_dilateElement$ = -180					; size = 56
_frame$ = -124						; size = 56
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
?doTracking@RoadTracker@CVDetector@@SAXXZ PROC		; CVDetector::RoadTracker::doTracking, COMDAT

; 203  : 		{			

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?doTracking@RoadTracker@CVDetector@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 488				; 000001e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+500], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+516]
	mov	DWORD PTR fs:0, eax

; 204  : 			Mat frame = hwnd2mat(hDesktopWnd);

	lea	esi, DWORD PTR _frame$[esp+516]
	call	?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z ; CVDetector::hwnd2mat
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+524], ebx

; 205  : 			Mat dst;

	lea	eax, DWORD PTR _dst$[esp+524]
	lea	ecx, DWORD PTR _dst$[esp+564]
	mov	DWORD PTR _dst$[esp+556], eax
	mov	DWORD PTR _dst$[esp+560], ecx
	mov	DWORD PTR _dst$[esp+568], ebx
	mov	DWORD PTR _dst$[esp+564], ebx
	mov	DWORD PTR _dst$[esp+516], 1124007936	; 42ff0000H
	mov	DWORD PTR _dst$[esp+528], ebx
	mov	DWORD PTR _dst$[esp+524], ebx
	mov	DWORD PTR _dst$[esp+520], ebx
	mov	DWORD PTR _dst$[esp+548], ebx
	mov	DWORD PTR _dst$[esp+544], ebx
	mov	DWORD PTR _dst$[esp+540], ebx
	mov	DWORD PTR _dst$[esp+532], ebx
	mov	DWORD PTR _dst$[esp+536], ebx
	mov	DWORD PTR _dst$[esp+552], ebx

; 206  : 			//Convert to HSV
; 207  : 			cvtColor(frame,dst,COLOR_BGR2HSV);

	lea	edx, DWORD PTR _dst$[esp+516]
	mov	BYTE PTR __$EHRec$[esp+524], 1
	mov	edi, DWORD PTR __imp_??0_OutputArray@cv@@QAE@AAVMat@1@@Z
	push	edx
	lea	ecx, DWORD PTR $T149580[esp+520]
	call	edi
	mov	eax, esi
	mov	esi, DWORD PTR __imp_??0_InputArray@cv@@QAE@ABVMat@1@@Z
	push	eax
	lea	ecx, DWORD PTR $T149581[esp+520]
	call	esi
	push	ebx
	push	40					; 00000028H
	lea	ecx, DWORD PTR $T149580[esp+524]
	push	ecx
	lea	edx, DWORD PTR $T149581[esp+528]
	push	edx
	call	DWORD PTR __imp_?cvtColor@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@HH@Z
	add	esp, 16					; 00000010H

; 208  : 			// Apply threshold to eliminate noise and emphasize filtered objects
; 209  : 			// These HSV values work best for Red color
; 210  : 			inRange(dst,Scalar(0,156,0),Scalar(21,256,256),dst);

	lea	eax, DWORD PTR _dst$[esp+516]
	push	eax
	lea	ecx, DWORD PTR $T149582[esp+520]
	call	edi
	fld	QWORD PTR __real@4035000000000000
	fstp	QWORD PTR $T127559[esp+516]
	lea	ecx, DWORD PTR $T127559[esp+516]
	fld	QWORD PTR __real@4070000000000000
	mov	eax, 1
	fst	QWORD PTR $T127559[esp+524]
	mov	edx, -1073610746			; c0020006H
	fstp	QWORD PTR $T127559[esp+532]
	mov	DWORD PTR $T149583[esp+524], ecx
	fldz
	mov	ecx, 4
	fst	QWORD PTR $T127559[esp+540]
	mov	DWORD PTR $T149583[esp+528], eax
	fst	QWORD PTR $T127558[esp+516]
	mov	DWORD PTR $T149584[esp+528], eax
	fld	QWORD PTR __real@4063800000000000
	mov	DWORD PTR $T149583[esp+520], edx
	fstp	QWORD PTR $T127558[esp+524]
	mov	DWORD PTR $T149584[esp+520], edx
	lea	eax, DWORD PTR _dst$[esp+516]
	mov	DWORD PTR $T149583[esp+532], ecx
	lea	edx, DWORD PTR $T127558[esp+516]
	fst	QWORD PTR $T127558[esp+532]
	mov	DWORD PTR $T149584[esp+532], ecx
	fstp	QWORD PTR $T127558[esp+540]
	push	eax
	lea	ecx, DWORD PTR $T149585[esp+520]
	mov	DWORD PTR $T149583[esp+520], OFFSET ??_7_InputArray@cv@@6B@
	mov	DWORD PTR $T149584[esp+520], OFFSET ??_7_InputArray@cv@@6B@
	mov	DWORD PTR $T149584[esp+528], edx
	call	esi
	lea	ecx, DWORD PTR $T149582[esp+516]
	push	ecx
	lea	edx, DWORD PTR $T149583[esp+520]
	push	edx
	lea	eax, DWORD PTR $T149584[esp+524]
	push	eax
	lea	ecx, DWORD PTR $T149585[esp+528]
	push	ecx
	call	DWORD PTR __imp_?inRange@cv@@YAXABV_InputArray@1@00ABV_OutputArray@1@@Z

; 211  : 			//erode and dilate with larger element so make sure object is nicely visible
; 212  : 			Mat erodeElement = getStructuringElement( MORPH_RECT,Size(2,2));

	add	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T149586[esp+524], esp
	sub	esp, 8
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	eax, esp
	mov	DWORD PTR $T149587[esp+532], esp
	lea	edx, DWORD PTR _erodeElement$[esp+532]
	push	ebx
	push	edx
	mov	DWORD PTR [eax], 2
	mov	DWORD PTR [eax+4], 2
	call	DWORD PTR __imp_?getStructuringElement@cv@@YA?AVMat@1@HV?$Size_@H@1@V?$Point_@H@1@@Z

; 213  : 			Mat dilateElement = getStructuringElement( MORPH_RECT,Size(4,4));

	add	esp, 16					; 00000010H
	mov	eax, esp
	mov	BYTE PTR __$EHRec$[esp+532], 2
	mov	DWORD PTR $T149588[esp+524], esp
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T149589[esp+532], esp
	mov	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 4
	lea	eax, DWORD PTR _dilateElement$[esp+532]
	push	ebx
	push	eax
	call	DWORD PTR __imp_?getStructuringElement@cv@@YA?AVMat@1@HV?$Size_@H@1@V?$Point_@H@1@@Z
	add	esp, 24					; 00000018H

; 214  : 			erode(dst,dst,erodeElement);

	lea	ecx, DWORD PTR _erodeElement$[esp+516]
	push	ecx
	lea	ecx, DWORD PTR $T149592[esp+520]
	mov	BYTE PTR __$EHRec$[esp+528], 3
	call	esi
	lea	edx, DWORD PTR _dst$[esp+516]
	push	edx
	lea	ecx, DWORD PTR $T149593[esp+520]
	call	edi
	lea	eax, DWORD PTR _dst$[esp+516]
	push	eax
	lea	ecx, DWORD PTR $T149594[esp+520]
	call	esi
	fld	QWORD PTR __real@7fefffffffffffff
	lea	ecx, DWORD PTR $T149590[esp+516]
	fst	QWORD PTR $T149590[esp+516]
	push	ecx
	fst	QWORD PTR $T149590[esp+528]
	push	ebx
	fst	QWORD PTR $T149590[esp+540]
	push	1
	fstp	QWORD PTR $T149590[esp+552]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T149591[esp+536], esp
	lea	edx, DWORD PTR $T149592[esp+536]
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	push	edx
	lea	eax, DWORD PTR $T149593[esp+540]
	push	eax
	lea	ecx, DWORD PTR $T149594[esp+544]
	push	ecx
	call	DWORD PTR __imp_?erode@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z
	add	esp, 32					; 00000020H

; 215  : 			erode(dst,dst,erodeElement);

	lea	edx, DWORD PTR _erodeElement$[esp+516]
	push	edx
	lea	ecx, DWORD PTR $T149597[esp+520]
	call	esi
	lea	eax, DWORD PTR _dst$[esp+516]
	push	eax
	lea	ecx, DWORD PTR $T149598[esp+520]
	call	edi
	lea	ecx, DWORD PTR _dst$[esp+516]
	push	ecx
	lea	ecx, DWORD PTR $T149599[esp+520]
	call	esi
	fld	QWORD PTR __real@7fefffffffffffff
	lea	edx, DWORD PTR $T149595[esp+516]
	fst	QWORD PTR $T149595[esp+516]
	push	edx
	fst	QWORD PTR $T149595[esp+528]
	push	ebx
	fst	QWORD PTR $T149595[esp+540]
	push	1
	fstp	QWORD PTR $T149595[esp+552]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR $T149596[esp+536], esp
	lea	eax, DWORD PTR $T149597[esp+536]
	push	eax
	lea	ecx, DWORD PTR $T149598[esp+540]
	push	ecx
	lea	edx, DWORD PTR $T149599[esp+544]
	push	edx
	call	DWORD PTR __imp_?erode@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z
	add	esp, 32					; 00000020H

; 216  : 			dilate(dst,dst,dilateElement);

	lea	eax, DWORD PTR _dilateElement$[esp+516]
	push	eax
	lea	ecx, DWORD PTR $T149602[esp+520]
	call	esi
	lea	ecx, DWORD PTR _dst$[esp+516]
	push	ecx
	lea	ecx, DWORD PTR $T149603[esp+520]
	call	edi
	lea	edx, DWORD PTR _dst$[esp+516]
	push	edx
	lea	ecx, DWORD PTR $T149604[esp+520]
	call	esi
	fld	QWORD PTR __real@7fefffffffffffff
	lea	eax, DWORD PTR $T149600[esp+516]
	fst	QWORD PTR $T149600[esp+516]
	push	eax
	fst	QWORD PTR $T149600[esp+528]
	push	ebx
	fst	QWORD PTR $T149600[esp+540]
	push	1
	fstp	QWORD PTR $T149600[esp+552]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T149601[esp+536], esp
	lea	ecx, DWORD PTR $T149602[esp+536]
	push	ecx
	lea	edx, DWORD PTR $T149603[esp+540]
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	push	edx
	lea	eax, DWORD PTR $T149604[esp+544]
	push	eax
	call	DWORD PTR __imp_?dilate@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z
	add	esp, 32					; 00000020H

; 217  : 			dilate(dst,dst,dilateElement);

	lea	ecx, DWORD PTR _dilateElement$[esp+516]
	push	ecx
	lea	ecx, DWORD PTR $T149607[esp+520]
	call	esi
	lea	edx, DWORD PTR _dst$[esp+516]
	push	edx
	lea	ecx, DWORD PTR $T149608[esp+520]
	call	edi
	lea	eax, DWORD PTR _dst$[esp+516]
	push	eax
	lea	ecx, DWORD PTR $T149609[esp+520]
	call	esi
	fld	QWORD PTR __real@7fefffffffffffff
	lea	ecx, DWORD PTR $T149605[esp+516]
	fst	QWORD PTR $T149605[esp+516]
	push	ecx
	fst	QWORD PTR $T149605[esp+528]
	push	ebx
	fst	QWORD PTR $T149605[esp+540]
	push	1
	fstp	QWORD PTR $T149605[esp+552]
	sub	esp, 8
	mov	DWORD PTR $T149606[esp+536], esp
	mov	eax, esp
	lea	edx, DWORD PTR $T149607[esp+536]
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	push	edx
	lea	eax, DWORD PTR $T149608[esp+540]
	push	eax
	lea	ecx, DWORD PTR $T149609[esp+544]
	push	ecx
	call	DWORD PTR __imp_?dilate@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z

; 218  : 			trackFilteredObject(dst);

	sub	esp, 24					; 00000018H
	lea	edi, DWORD PTR _dst$[esp+572]
	mov	esi, esp
	mov	DWORD PTR $T149610[esp+572], esp
	call	??0Mat@cv@@QAE@ABV01@@Z			; cv::Mat::Mat
	call	_trackFilteredObject
	fstp	ST(0)

; 219  : 			printf("Axis value = %d\n",axisValue);

	fld	QWORD PTR _axisValue
	add	esp, 48					; 00000030H
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BB@HGDFHEIC@Axis?5value?5?$DN?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH

; 220  : 			// Show the processed image
; 221  : 			//imshow("Example3-out", dst);
; 222  : 			//imshow("Example3-in", dst);
; 223  : 			//waitKey(30); //this must be here or image will not be displayed :/
; 224  : 			//... uncomment for debug mode
; 225  : 			
; 226  : 		}

	lea	eax, DWORD PTR _dilateElement$[esp+516]
	mov	BYTE PTR __$EHRec$[esp+524], 2
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	lea	eax, DWORD PTR _erodeElement$[esp+516]
	mov	BYTE PTR __$EHRec$[esp+524], 1
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	eax, edi
	mov	BYTE PTR __$EHRec$[esp+524], bl
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	lea	eax, DWORD PTR _frame$[esp+516]
	mov	DWORD PTR __$EHRec$[esp+524], -1
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	ecx, DWORD PTR __$EHRec$[esp+516]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+500]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?doTracking@RoadTracker@CVDetector@@SAXXZ$0:
	lea	eax, DWORD PTR _frame$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?doTracking@RoadTracker@CVDetector@@SAXXZ$1:
	lea	eax, DWORD PTR _dst$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?doTracking@RoadTracker@CVDetector@@SAXXZ$2:
	lea	eax, DWORD PTR _erodeElement$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?doTracking@RoadTracker@CVDetector@@SAXXZ$3:
	lea	eax, DWORD PTR _dilateElement$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__ehhandler$?doTracking@RoadTracker@CVDetector@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-500]
	mov	ecx, DWORD PTR [edx-504]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?doTracking@RoadTracker@CVDetector@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?doTracking@RoadTracker@CVDetector@@SAXXZ ENDP		; CVDetector::RoadTracker::doTracking
PUBLIC	__$ArrayPad$
PUBLIC	?detectSigns@SignDetector@CVDetector@@SAXXZ	; CVDetector::SignDetector::detectSigns
_enable_cascade DD 01H DUP (?)
_disable_cascade DD 01H DUP (?)
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?detectSigns@SignDetector@CVDetector@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$2
__ehfuncinfo$?detectSigns@SignDetector@CVDetector@@SAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?detectSigns@SignDetector@CVDetector@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?detectSigns@SignDetector@CVDetector@@SAXXZ
_TEXT	SEGMENT
tv146 = -88						; size = 4
$T150019 = -88						; size = 4
$T150017 = -84						; size = 4
$T150018 = -80						; size = 4
_frame$ = -76						; size = 56
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?detectSigns@SignDetector@CVDetector@@SAXXZ PROC	; CVDetector::SignDetector::detectSigns, COMDAT

; 196  : 		{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?detectSigns@SignDetector@CVDetector@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+88], eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, eax

; 197  : 			Mat frame = hwnd2mat(hDesktopWnd);

	lea	esi, DWORD PTR _frame$[esp+100]
	call	?hwnd2mat@CVDetector@@YA?AVMat@cv@@PAUHWND__@@@Z ; CVDetector::hwnd2mat

; 198  : 			signID = detectAndDisplay(frame, *enable_cascade, *disable_cascade);

	sub	esp, 56					; 00000038H
	mov	edi, esi
	mov	DWORD PTR __$EHRec$[esp+164], 0
	mov	esi, esp
	mov	DWORD PTR $T150019[esp+156], esp
	call	??0Mat@cv@@QAE@ABV01@@Z			; cv::Mat::Mat
	sub	esp, 132				; 00000084H
	mov	BYTE PTR __$EHRec$[esp+296], 1
	mov	ecx, DWORD PTR _disable_cascade
	mov	eax, esp
	mov	DWORD PTR $T150017[esp+288], esp
	push	eax
	call	??0CascadeClassifier@cv@@QAE@ABV01@@Z
	sub	esp, 132				; 00000084H
	mov	ecx, esp
	mov	DWORD PTR $T150018[esp+420], esp
	mov	BYTE PTR __$EHRec$[esp+428], 2
	push	ecx
	mov	ecx, DWORD PTR _enable_cascade
	call	??0CascadeClassifier@cv@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[esp+428], 0
	call	?detectAndDisplay@CVDetector@@YAHVMat@cv@@VCascadeClassifier@3@1@Z ; CVDetector::detectAndDisplay
	mov	DWORD PTR tv146[esp+420], eax
	fild	DWORD PTR tv146[esp+420]

; 199  : 			waitKey(30); // -------------->uncomment this for debug mode

	push	30					; 0000001eH
	fstp	QWORD PTR _signID
	call	DWORD PTR __imp_?waitKey@cv@@YAHH@Z
	add	esp, 324				; 00000144H

; 200  : 		}

	mov	eax, edi
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+88]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$0:
	lea	eax, DWORD PTR _frame$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$1:
	mov	eax, DWORD PTR $T150019[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?detectSigns@SignDetector@CVDetector@@SAXXZ$2:
	mov	ecx, DWORD PTR $T150017[ebp]
	jmp	DWORD PTR __imp_??1CascadeClassifier@cv@@UAE@XZ
__ehhandler$?detectSigns@SignDetector@CVDetector@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-84]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 8
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?detectSigns@SignDetector@CVDetector@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?detectSigns@SignDetector@CVDetector@@SAXXZ ENDP	; CVDetector::SignDetector::detectSigns
PUBLIC	?initialiseDetector@SignDetector@CVDetector@@SAHXZ ; CVDetector::SignDetector::initialiseDetector
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?initialiseDetector@SignDetector@CVDetector@@SAHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initialiseDetector@SignDetector@CVDetector@@SAHXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialiseDetector@SignDetector@CVDetector@@SAHXZ$1
__ehfuncinfo$?initialiseDetector@SignDetector@CVDetector@@SAHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?initialiseDetector@SignDetector@CVDetector@@SAHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll\cvdetectordll.cpp
xdata$x	ENDS
;	COMDAT ?initialiseDetector@SignDetector@CVDetector@@SAHXZ
_TEXT	SEGMENT
$T150037 = -20						; size = 4
$T150033 = -20						; size = 4
_hDesktopDC$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?initialiseDetector@SignDetector@CVDetector@@SAHXZ PROC	; CVDetector::SignDetector::initialiseDetector, COMDAT

; 167  : 		{			

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?initialiseDetector@SignDetector@CVDetector@@SAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 168  : 			HDC hDesktopDC;
; 169  : 			hDesktopWnd=GetDesktopWindow();

	call	DWORD PTR __imp__GetDesktopWindow@0

; 170  : 			hDesktopDC=GetDC(hDesktopWnd);

	push	eax
	mov	DWORD PTR _hDesktopWnd, eax
	call	DWORD PTR __imp__GetDC@4

; 171  : 			disable_cascade = new CascadeClassifier;

	mov	esi, DWORD PTR __imp_??2@YAPAXI@Z
	push	132					; 00000084H
	mov	DWORD PTR _hDesktopDC$[ebp], eax
	call	esi
	add	esp, 4
	mov	DWORD PTR $T150033[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edi, DWORD PTR __imp_??0CascadeClassifier@cv@@QAE@XZ
	test	eax, eax
	je	SHORT $LN5@initialise
	mov	ecx, eax
	call	edi
	jmp	SHORT $LN6@initialise
$LN5@initialise:
	xor	eax, eax
$LN6@initialise:
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 172  : 			enable_cascade = new CascadeClassifier;

	push	132					; 00000084H
	mov	DWORD PTR _disable_cascade, eax
	call	esi
	add	esp, 4
	mov	DWORD PTR $T150037[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN7@initialise
	mov	ecx, eax
	call	edi
	jmp	SHORT $LN8@initialise
$LN7@initialise:
	xor	eax, eax
$LN8@initialise:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR _enable_cascade, eax

; 173  : 			
; 174  : 			window_name  = "Detecting ...";

	mov	edi, 13					; 0000000dH
	mov	eax, OFFSET ??_C@_0O@ENPJBMMB@Detecting?5?4?4?4?$AA@
	mov	esi, OFFSET ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; window_name
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 175  : 			cascade_enable = "classifier_enable.xml";

	mov	edi, 21					; 00000015H
	mov	eax, OFFSET ??_C@_0BG@GANHPLLF@classifier_enable?4xml?$AA@
	mov	esi, OFFSET ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_enable
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 176  : 			cascade_disable = "classifier_disable.xml";

	mov	edi, 22					; 00000016H
	mov	eax, OFFSET ??_C@_0BH@OOLANKBA@classifier_disable?4xml?$AA@
	mov	esi, OFFSET ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_disable
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 177  : 			if( !(*enable_cascade).load( cascade_enable ) ){ return -1; };

	mov	ecx, DWORD PTR _enable_cascade
	mov	esi, DWORD PTR __imp_?load@CascadeClassifier@cv@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	push	OFFSET ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_enable
	call	esi
	test	al, al
	jne	SHORT $LN2@initialise
$LN30@initialise:
	or	eax, -1

; 193  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@initialise:

; 178  : 			if( !(*disable_cascade).load( cascade_disable ) ){ return -1; };

	mov	ecx, DWORD PTR _disable_cascade
	push	OFFSET ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_disable
	call	esi
	test	al, al
	je	SHORT $LN30@initialise

; 179  : 
; 180  : 			// get the height and width of the screen
; 181  : 			int height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

	mov	esi, DWORD PTR __imp__GetSystemMetrics@4
	push	79					; 0000004fH
	call	esi

; 182  : 			int width = GetSystemMetrics(SM_CXVIRTUALSCREEN);

	push	78					; 0000004eH
	mov	edi, eax
	call	esi

; 183  : 
; 184  : 			// create a bitmap
; 185  : 			HBITMAP hbDesktop = CreateCompatibleBitmap( hDesktopDC, width, height);

	push	edi
	push	eax
	mov	eax, DWORD PTR _hDesktopDC$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateCompatibleBitmap@12

; 186  : 
; 187  : 			/*while(1){ //----------->comment this for release mode
; 188  : 				//detectSigns();
; 189  : 				RoadTracker::doTracking();
; 190  : 			}*/
; 191  : 			
; 192  : 			return 0;

	xor	eax, eax

; 193  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?initialiseDetector@SignDetector@CVDetector@@SAHXZ$0:
	mov	eax, DWORD PTR $T150033[ebp]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx
	ret	0
__unwindfunclet$?initialiseDetector@SignDetector@CVDetector@@SAHXZ$1:
	mov	eax, DWORD PTR $T150037[ebp]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx
	ret	0
__ehhandler$?initialiseDetector@SignDetector@CVDetector@@SAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?initialiseDetector@SignDetector@CVDetector@@SAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?initialiseDetector@SignDetector@CVDetector@@SAHXZ ENDP	; CVDetector::SignDetector::initialiseDetector
PUBLIC	?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; window_name
?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; window_name
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
; Function compile flags: /Ogtp
;	COMDAT ??__Ewindow_name@@YAXXZ
text$yc	SEGMENT
??__Ewindow_name@@YAXXZ PROC				; `dynamic initializer for 'window_name'', COMDAT

; 12   : string window_name;

	push	OFFSET ??__Fwindow_name@@YAXXZ		; `dynamic atexit destructor for 'window_name''
	call	_atexit
	pop	ecx
	ret	0
??__Ewindow_name@@YAXXZ ENDP				; `dynamic initializer for 'window_name''
text$yc	ENDS
PUBLIC	?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_enable
	ORG $+4
?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; cascade_enable
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
; Function compile flags: /Ogtp
;	COMDAT ??__Ecascade_enable@@YAXXZ
text$yc	SEGMENT
??__Ecascade_enable@@YAXXZ PROC				; `dynamic initializer for 'cascade_enable'', COMDAT

; 13   : String cascade_enable, cascade_disable;

	push	OFFSET ??__Fcascade_enable@@YAXXZ	; `dynamic atexit destructor for 'cascade_enable''
	call	_atexit
	pop	ecx
	ret	0
??__Ecascade_enable@@YAXXZ ENDP				; `dynamic initializer for 'cascade_enable''
text$yc	ENDS
PUBLIC	?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; cascade_disable
	ORG $+4
?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; cascade_disable
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
; Function compile flags: /Ogtp
;	COMDAT ??__Ecascade_disable@@YAXXZ
text$yc	SEGMENT
??__Ecascade_disable@@YAXXZ PROC			; `dynamic initializer for 'cascade_disable'', COMDAT

; 13   : String cascade_enable, cascade_disable;

	push	OFFSET ??__Fcascade_disable@@YAXXZ	; `dynamic atexit destructor for 'cascade_disable''
	call	_atexit
	pop	ecx
	ret	0
??__Ecascade_disable@@YAXXZ ENDP			; `dynamic initializer for 'cascade_disable''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fcascade_enable@@YAXXZ
text$yd	SEGMENT
??__Fcascade_enable@@YAXXZ PROC				; `dynamic atexit destructor for 'cascade_enable'', COMDAT
	cmp	DWORD PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
	jb	SHORT $LN13@dynamic
	mov	eax, DWORD PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN13@dynamic:
	xor	eax, eax
	mov	DWORD PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH
	mov	DWORD PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax
	mov	BYTE PTR ?cascade_enable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, al
	ret	0
??__Fcascade_enable@@YAXXZ ENDP				; `dynamic atexit destructor for 'cascade_enable''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fcascade_disable@@YAXXZ
text$yd	SEGMENT
??__Fcascade_disable@@YAXXZ PROC			; `dynamic atexit destructor for 'cascade_disable'', COMDAT
	cmp	DWORD PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
	jb	SHORT $LN13@dynamic@2
	mov	eax, DWORD PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN13@dynamic@2:
	xor	eax, eax
	mov	DWORD PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH
	mov	DWORD PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax
	mov	BYTE PTR ?cascade_disable@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, al
	ret	0
??__Fcascade_disable@@YAXXZ ENDP			; `dynamic atexit destructor for 'cascade_disable''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fwindow_name@@YAXXZ
text$yd	SEGMENT
??__Fwindow_name@@YAXXZ PROC				; `dynamic atexit destructor for 'window_name'', COMDAT
	cmp	DWORD PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
	jb	SHORT $LN13@dynamic@3
	mov	eax, DWORD PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN13@dynamic@3:
	xor	eax, eax
	mov	DWORD PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH
	mov	DWORD PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax
	mov	BYTE PTR ?window_name@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, al
	ret	0
??__Fwindow_name@@YAXXZ ENDP				; `dynamic atexit destructor for 'window_name''
text$yd	ENDS
CRT$XCU	SEGMENT
_window_name$initializer$ DD FLAT:??__Ewindow_name@@YAXXZ
_cascade_enable$initializer$ DD FLAT:??__Ecascade_enable@@YAXXZ
_cascade_disable$initializer$ DD FLAT:??__Ecascade_disable@@YAXXZ
CRT$XCU	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\OJ\Documents\Visual Studio 2010\Projects\CVDetectorDLL - Copy\CVDetectorDLL.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4_InputArray@cv@@6B@			; cv::_InputArray::`RTTI Complete Object Locator'
PUBLIC	??_R3_InputArray@cv@@8				; cv::_InputArray::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_InputArray@cv@@8				; cv::_InputArray::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_InputArray@cv@@8			; cv::_InputArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_InputArray@cv@@@8			; cv::_InputArray `RTTI Type Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_InputArray@cv@@QAE@ABV?$Scalar_@N@1@@Z	; cv::_InputArray::_InputArray
PUBLIC	??0?$Size_@H@cv@@QAE@HH@Z			; cv::Size_<int>::Size_<int>
PUBLIC	??0MSize@Mat@cv@@QAE@PAH@Z			; cv::Mat::MSize::MSize
PUBLIC	??0MStep@Mat@cv@@QAE@XZ				; cv::Mat::MStep::MStep
PUBLIC	?initEmpty@Mat@cv@@IAEXXZ			; cv::Mat::initEmpty
PUBLIC	??0Mat@cv@@QAE@XZ				; cv::Mat::Mat
PUBLIC	?release@Mat@cv@@QAEXXZ				; cv::Mat::release
PUBLIC	??1Mat@cv@@QAE@XZ				; cv::Mat::~Mat
PUBLIC	??0?$Point_@H@cv@@QAE@HH@Z			; cv::Point_<int>::Point_<int>
PUBLIC	??0?$Matx@N$03$00@cv@@QAE@XZ			; cv::Matx<double,4,1>::Matx<double,4,1>
PUBLIC	??0?$Vec@N$03@cv@@QAE@XZ			; cv::Vec<double,4>::Vec<double,4>
PUBLIC	??0?$Scalar_@N@cv@@QAE@NNNN@Z			; cv::Scalar_<double>::Scalar_<double>
PUBLIC	?all@?$Scalar_@N@cv@@SA?AV12@N@Z		; cv::Scalar_<double>::all
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?H_MIN@@3HA					; H_MIN
PUBLIC	?H_MAX@@3HA					; H_MAX
PUBLIC	?S_MIN@@3HA					; S_MIN
PUBLIC	?S_MAX@@3HA					; S_MAX
PUBLIC	?V_MIN@@3HA					; V_MIN
PUBLIC	?V_MAX@@3HA					; V_MAX
PUBLIC	??_C@_0CD@LGEPKHAB@In?5C?5this?5would?5be?5?$CFlf?5?$CL?5?$CFd?5?$DN?5?$CFl@ ; `string'
PUBLIC	??_C@_0BO@GAFFBBJF@Make?5the?5symbols?5appear?5white?$AA@ ; `string'
PUBLIC	??_C@_05GPLKNKGD@H_MIN?$AA@			; `string'
PUBLIC	??_C@_05HNDBDOAM@H_MAX?$AA@			; `string'
PUBLIC	??_C@_05GKLCIDL@S_MIN?$AA@			; `string'
PUBLIC	??_C@_05BECAMMFE@S_MAX?$AA@			; `string'
PUBLIC	??_C@_05FGGGLJII@V_MIN?$AA@			; `string'
PUBLIC	??_C@_05EEONFNOH@V_MAX?$AA@			; `string'
PUBLIC	??_C@_0M@ELNMGJKA@Example3?9in?$AA@		; `string'
PUBLIC	??_C@_0N@KINGNADO@Example3?9out?$AA@		; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7_InputArray@cv@@6B@				; cv::_InputArray::`vftable'
EXTRN	?empty@_InputArray@cv@@UBE_NXZ:PROC		; cv::_InputArray::empty
EXTRN	?channels@_InputArray@cv@@UBEHH@Z:PROC		; cv::_InputArray::channels
EXTRN	?depth@_InputArray@cv@@UBEHH@Z:PROC		; cv::_InputArray::depth
EXTRN	?type@_InputArray@cv@@UBEHH@Z:PROC		; cv::_InputArray::type
EXTRN	?total@_InputArray@cv@@UBEIH@Z:PROC		; cv::_InputArray::total
EXTRN	?size@_InputArray@cv@@UBE?AV?$Size_@H@2@H@Z:PROC ; cv::_InputArray::size
EXTRN	?kind@_InputArray@cv@@UBEHXZ:PROC		; cv::_InputArray::kind
EXTRN	?getGpuMat@_InputArray@cv@@UBE?AVGpuMat@gpu@2@XZ:PROC ; cv::_InputArray::getGpuMat
EXTRN	?getGlTexture@_InputArray@cv@@UBE?AVGlTexture@2@XZ:PROC ; cv::_InputArray::getGlTexture
EXTRN	?getGlBuffer@_InputArray@cv@@UBE?AVGlBuffer@2@XZ:PROC ; cv::_InputArray::getGlBuffer
EXTRN	?getMatVector@_InputArray@cv@@UBEXAAV?$vector@VMat@cv@@V?$allocator@VMat@cv@@@std@@@std@@@Z:PROC ; cv::_InputArray::getMatVector
EXTRN	?getMat@_InputArray@cv@@UBE?AVMat@2@H@Z:PROC	; cv::_InputArray::getMat
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp__printf:PROC
EXTRN	__imp__sprintf:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_??2@YAPAXI@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?what@exception@std@@UBEPBDXZ:PROC
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_??3@YAXPAX@Z:PROC
EXTRN	__imp_??0_InputArray@cv@@QAE@ABVMat@1@@Z:PROC
EXTRN	__imp_?getMat@_InputArray@cv@@UBE?AVMat@2@H@Z:PROC
EXTRN	__imp_?getMatVector@_InputArray@cv@@UBEXAAV?$vector@VMat@cv@@V?$allocator@VMat@cv@@@std@@@std@@@Z:PROC
EXTRN	__imp_?getGlBuffer@_InputArray@cv@@UBE?AVGlBuffer@2@XZ:PROC
EXTRN	__imp_?getGlTexture@_InputArray@cv@@UBE?AVGlTexture@2@XZ:PROC
EXTRN	__imp_?getGpuMat@_InputArray@cv@@UBE?AVGpuMat@gpu@2@XZ:PROC
EXTRN	__imp_?kind@_InputArray@cv@@UBEHXZ:PROC
EXTRN	__imp_?size@_InputArray@cv@@UBE?AV?$Size_@H@2@H@Z:PROC
EXTRN	__imp_?total@_InputArray@cv@@UBEIH@Z:PROC
EXTRN	__imp_?type@_InputArray@cv@@UBEHH@Z:PROC
EXTRN	__imp_?depth@_InputArray@cv@@UBEHH@Z:PROC
EXTRN	__imp_?channels@_InputArray@cv@@UBEHH@Z:PROC
EXTRN	__imp_?empty@_InputArray@cv@@UBE_NXZ:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_??0_OutputArray@cv@@QAE@AAVMat@1@@Z:PROC
EXTRN	__imp_?fastFree@cv@@YAXPAX@Z:PROC
EXTRN	__imp_?deallocate@Mat@cv@@QAEXXZ:PROC
EXTRN	__imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z:PROC
EXTRN	__imp_?inRange@cv@@YAXABV_InputArray@1@00ABV_OutputArray@1@@Z:PROC
EXTRN	__imp_?getStructuringElement@cv@@YA?AVMat@1@HV?$Size_@H@1@V?$Point_@H@1@@Z:PROC
EXTRN	__imp_?GaussianBlur@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@V?$Size_@H@1@NNH@Z:PROC
EXTRN	__imp_?Canny@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@NNH_N@Z:PROC
EXTRN	__imp_?erode@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z:PROC
EXTRN	__imp_?dilate@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z:PROC
EXTRN	__imp_?cvtColor@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@HH@Z:PROC
EXTRN	__imp__cvWaitKey:PROC
EXTRN	__imp_?namedWindow@cv@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:PROC
EXTRN	__imp_?waitKey@cv@@YAHH@Z:PROC
EXTRN	__imp_?imshow@cv@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV_InputArray@1@@Z:PROC
EXTRN	__imp_?createTrackbar@cv@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PAHHP6AXHPAX@Z2@Z:PROC
EXTRN	__imp_??0VideoCapture@cv@@QAE@XZ:PROC
EXTRN	__imp_??1VideoCapture@cv@@UAE@XZ:PROC
EXTRN	__imp_?open@VideoCapture@cv@@UAE_NH@Z:PROC
EXTRN	__imp_?read@VideoCapture@cv@@UAE_NAAVMat@2@@Z:PROC
EXTRN	__imp_?set@VideoCapture@cv@@UAE_NHN@Z:PROC
?H_MIN@@3HA DD	01H DUP (?)				; H_MIN
?S_MIN@@3HA DD	01H DUP (?)				; S_MIN
?V_MIN@@3HA DD	01H DUP (?)				; V_MIN
;	COMDAT ??_7_InputArray@cv@@6B@
CONST	SEGMENT
??_7_InputArray@cv@@6B@ DD FLAT:??_R4_InputArray@cv@@6B@ ; cv::_InputArray::`vftable'
	DD	FLAT:?getMat@_InputArray@cv@@UBE?AVMat@2@H@Z
	DD	FLAT:?getMatVector@_InputArray@cv@@UBEXAAV?$vector@VMat@cv@@V?$allocator@VMat@cv@@@std@@@std@@@Z
	DD	FLAT:?getGlBuffer@_InputArray@cv@@UBE?AVGlBuffer@2@XZ
	DD	FLAT:?getGlTexture@_InputArray@cv@@UBE?AVGlTexture@2@XZ
	DD	FLAT:?getGpuMat@_InputArray@cv@@UBE?AVGpuMat@gpu@2@XZ
	DD	FLAT:?kind@_InputArray@cv@@UBEHXZ
	DD	FLAT:?size@_InputArray@cv@@UBE?AV?$Size_@H@2@H@Z
	DD	FLAT:?total@_InputArray@cv@@UBEIH@Z
	DD	FLAT:?type@_InputArray@cv@@UBEHH@Z
	DD	FLAT:?depth@_InputArray@cv@@UBEHH@Z
	DD	FLAT:?channels@_InputArray@cv@@UBEHH@Z
	DD	FLAT:?empty@_InputArray@cv@@UBE_NXZ
CONST	ENDS
;	COMDAT ??_R4_InputArray@cv@@6B@
rdata$r	SEGMENT
??_R4_InputArray@cv@@6B@ DD 00H				; cv::_InputArray::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_InputArray@cv@@@8
	DD	FLAT:??_R3_InputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R3_InputArray@cv@@8
rdata$r	SEGMENT
??_R3_InputArray@cv@@8 DD 00H				; cv::_InputArray::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_InputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R2_InputArray@cv@@8
rdata$r	SEGMENT
??_R2_InputArray@cv@@8 DD FLAT:??_R1A@?0A@EA@_InputArray@cv@@8 ; cv::_InputArray::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_InputArray@cv@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_InputArray@cv@@8 DD FLAT:??_R0?AV_InputArray@cv@@@8 ; cv::_InputArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_InputArray@cv@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_InputArray@cv@@@8
_DATA	SEGMENT
??_R0?AV_InputArray@cv@@@8 DD FLAT:??_7type_info@@6B@	; cv::_InputArray `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_InputArray@cv@@', 00H
_DATA	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KINGNADO@Example3?9out?$AA@
CONST	SEGMENT
??_C@_0N@KINGNADO@Example3?9out?$AA@ DB 'Example3-out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ELNMGJKA@Example3?9in?$AA@
CONST	SEGMENT
??_C@_0M@ELNMGJKA@Example3?9in?$AA@ DB 'Example3-in', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EEONFNOH@V_MAX?$AA@
CONST	SEGMENT
??_C@_05EEONFNOH@V_MAX?$AA@ DB 'V_MAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FGGGLJII@V_MIN?$AA@
CONST	SEGMENT
??_C@_05FGGGLJII@V_MIN?$AA@ DB 'V_MIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BECAMMFE@S_MAX?$AA@
CONST	SEGMENT
??_C@_05BECAMMFE@S_MAX?$AA@ DB 'S_MAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GKLCIDL@S_MIN?$AA@
CONST	SEGMENT
??_C@_05GKLCIDL@S_MIN?$AA@ DB 'S_MIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNDBDOAM@H_MAX?$AA@
CONST	SEGMENT
??_C@_05HNDBDOAM@H_MAX?$AA@ DB 'H_MAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GPLKNKGD@H_MIN?$AA@
CONST	SEGMENT
??_C@_05GPLKNKGD@H_MIN?$AA@ DB 'H_MIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GAFFBBJF@Make?5the?5symbols?5appear?5white?$AA@
CONST	SEGMENT
??_C@_0BO@GAFFBBJF@Make?5the?5symbols?5appear?5white?$AA@ DB 'Make the sy'
	DB	'mbols appear white', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LGEPKHAB@In?5C?5this?5would?5be?5?$CFlf?5?$CL?5?$CFd?5?$DN?5?$CFl@
CONST	SEGMENT
??_C@_0CD@LGEPKHAB@In?5C?5this?5would?5be?5?$CFlf?5?$CL?5?$CFd?5?$DN?5?$CFl@ DB 'I'
	DB	'n C this would be %lf + %d = %lf', 0aH, 00H	; `string'
?H_MAX@@3HA DD	0100H					; H_MAX
?S_MAX@@3HA DD	0100H					; S_MAX
?V_MAX@@3HA DD	0100H					; V_MAX
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
PUBLIC	__real@0000000000000000
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0?$Matx@N$03$00@cv@@QAE@XZ
_TEXT	SEGMENT
??0?$Matx@N$03$00@cv@@QAE@XZ PROC			; cv::Matx<double,4,1>::Matx<double,4,1>, COMDAT
; _this$ = eax

; 208  :     for(int i = 0; i < channels; i++) val[i] = _Tp(0);

	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]

; 209  : }

	ret	0
??0?$Matx@N$03$00@cv@@QAE@XZ ENDP			; cv::Matx<double,4,1>::Matx<double,4,1>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Vec@N$03@cv@@QAE@XZ
_TEXT	SEGMENT
??0?$Vec@N$03@cv@@QAE@XZ PROC				; cv::Vec<double,4>::Vec<double,4>, COMDAT
; _this$ = eax

; 1138 : {}

	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	ret	0
??0?$Vec@N$03@cv@@QAE@XZ ENDP				; cv::Vec<double,4>::Vec<double,4>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Point_@H@cv@@QAE@HH@Z
_TEXT	SEGMENT
??0?$Point_@H@cv@@QAE@HH@Z PROC				; cv::Point_<int>::Point_<int>, COMDAT
; _this$ = eax

; 1621 : template<typename _Tp> inline Point_<_Tp>::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) {}

	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	ret	0
??0?$Point_@H@cv@@QAE@HH@Z ENDP				; cv::Point_<int>::Point_<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Scalar_@N@cv@@QAE@NNNN@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 8
_v1$ = 16						; size = 8
_v2$ = 24						; size = 8
_v3$ = 32						; size = 8
??0?$Scalar_@N@cv@@QAE@NNNN@Z PROC			; cv::Scalar_<double>::Scalar_<double>, COMDAT
; _this$ = eax

; 2019 : { this->val[0] = v0; this->val[1] = v1; this->val[2] = v2; this->val[3] = v3; }

	push	ebp
	mov	ebp, esp
	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR _v0$[ebp]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _v1$[ebp]
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR _v2$[ebp]
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR _v3$[ebp]
	fstp	QWORD PTR [eax+24]
	pop	ebp
	ret	32					; 00000020H
??0?$Scalar_@N@cv@@QAE@NNNN@Z ENDP			; cv::Scalar_<double>::Scalar_<double>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$Size_@H@cv@@QAE@HH@Z
_TEXT	SEGMENT
??0?$Size_@H@cv@@QAE@HH@Z PROC				; cv::Size_<int>::Size_<int>, COMDAT
; _this$ = eax
; __width$ = ecx
; __height$ = edx

; 1860 :     : width(_width), height(_height) {}

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	0
??0?$Size_@H@cv@@QAE@HH@Z ENDP				; cv::Size_<int>::Size_<int>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 220  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 2015 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 1516 : 		size_type _Num = this->_Alval.max_size();
; 1517 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1518 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	pop	ecx

; 183  : 		}

	ret	0
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT

; 2020 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = eax

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN4@Myptr
	mov	eax, DWORD PTR [eax]
$LN4@Myptr:

; 2005 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	ret	0
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT

; 459  : 		}

	ret	0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = eax

; 455  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = eax

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN4@Myptr@2
	mov	eax, DWORD PTR [eax]
$LN4@Myptr@2:

; 2011 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = eax

; 1511 : 		return (this->_Mysize);

	mov	eax, DWORD PTR [eax+16]

; 1512 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	?Divide@MyMathFuncs@MathFuncs@@SANNN@Z		; MathFuncs::MyMathFuncs::Divide
;	COMDAT __real@bff0000000000000
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll - copy\cvdetectordll.cpp
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Divide@MyMathFuncs@MathFuncs@@SANNN@Z
_TEXT	SEGMENT
_a$ = 8							; size = 8
_b$ = 16						; size = 8
?Divide@MyMathFuncs@MathFuncs@@SANNN@Z PROC		; MathFuncs::MyMathFuncs::Divide, COMDAT

; 109  :     {

	push	ebp
	mov	ebp, esp

; 110  :         if (b == 0)

	fld	QWORD PTR _b$[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@Divide
	fstp	ST(0)

; 111  :         {
; 112  :             return -1;

	fld	QWORD PTR __real@bff0000000000000

; 116  :     }

	pop	ebp
	ret	0
$LN1@Divide:

; 113  :         }
; 114  : 
; 115  :         return a / b;

	fdivr	QWORD PTR _a$[ebp]

; 116  :     }

	pop	ebp
	ret	0
?Divide@MyMathFuncs@MathFuncs@@SANNN@Z ENDP		; MathFuncs::MyMathFuncs::Divide
_TEXT	ENDS
PUBLIC	?Multiply@MyMathFuncs@MathFuncs@@SANNN@Z	; MathFuncs::MyMathFuncs::Multiply
; Function compile flags: /Ogtp
;	COMDAT ?Multiply@MyMathFuncs@MathFuncs@@SANNN@Z
_TEXT	SEGMENT
_a$ = 8							; size = 8
_b$ = 16						; size = 8
?Multiply@MyMathFuncs@MathFuncs@@SANNN@Z PROC		; MathFuncs::MyMathFuncs::Multiply, COMDAT

; 104  :     {

	push	ebp
	mov	ebp, esp

; 105  :         return a * b;

	fld	QWORD PTR _a$[ebp]
	fmul	QWORD PTR _b$[ebp]

; 106  :     }

	pop	ebp
	ret	0
?Multiply@MyMathFuncs@MathFuncs@@SANNN@Z ENDP		; MathFuncs::MyMathFuncs::Multiply
_TEXT	ENDS
PUBLIC	?Add@MyMathFuncs@MathFuncs@@SANNN@Z		; MathFuncs::MyMathFuncs::Add
; Function compile flags: /Ogtp
;	COMDAT ?Add@MyMathFuncs@MathFuncs@@SANNN@Z
_TEXT	SEGMENT
tv128 = -8						; size = 8
_a$ = 8							; size = 8
_b$ = 16						; size = 8
?Add@MyMathFuncs@MathFuncs@@SANNN@Z PROC		; MathFuncs::MyMathFuncs::Add, COMDAT

; 28   :     {	

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 64					; 00000040H

; 29   : 		printf("In C this would be %lf + %d = %lf\n",a,b,a+b);

	fld	QWORD PTR _a$[ebp]
	sub	esp, 24					; 00000018H
	fld	ST(0)
	fld	QWORD PTR _b$[ebp]
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv128[esp+88]
	fstp	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CD@LGEPKHAB@In?5C?5this?5would?5be?5?$CFlf?5?$CL?5?$CFd?5?$DN?5?$CFl@
	call	DWORD PTR __imp__printf

; 30   :         return a + b;

	fld	QWORD PTR tv128[esp+92]
	add	esp, 28					; 0000001cH

; 31   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Add@MyMathFuncs@MathFuncs@@SANNN@Z ENDP		; MathFuncs::MyMathFuncs::Add
_TEXT	ENDS
PUBLIC	?onTrackbarMove@MathFuncs@@YAXHPAX@Z		; MathFuncs::onTrackbarMove
; Function compile flags: /Ogtp
;	COMDAT ?onTrackbarMove@MathFuncs@@YAXHPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?onTrackbarMove@MathFuncs@@YAXHPAX@Z PROC		; MathFuncs::onTrackbarMove, COMDAT

; 23   : 		//no action
; 24   : 	}

	ret	0
?onTrackbarMove@MathFuncs@@YAXHPAX@Z ENDP		; MathFuncs::onTrackbarMove
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
_TEXT	ENDS
;	COMDAT ??0_InputArray@cv@@QAE@ABV?$Scalar_@N@1@@Z
_TEXT	SEGMENT
??0_InputArray@cv@@QAE@ABV?$Scalar_@N@1@@Z PROC		; cv::_InputArray::_InputArray, COMDAT
; _this$ = eax
; _s$ = ecx

; 1140 :     : flags(FIXED_TYPE + FIXED_SIZE + MATX + CV_64F), obj((void*)&s), sz(1, 4) {}

	mov	DWORD PTR [eax], OFFSET ??_7_InputArray@cv@@6B@
	mov	DWORD PTR [eax+4], -1073610746		; c0020006H
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], 1
	mov	DWORD PTR [eax+16], 4
	ret	0
??0_InputArray@cv@@QAE@ABV?$Scalar_@N@1@@Z ENDP		; cv::_InputArray::_InputArray
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0MStep@Mat@cv@@QAE@XZ
_TEXT	SEGMENT
??0MStep@Mat@cv@@QAE@XZ PROC				; cv::Mat::MStep::MStep, COMDAT
; _this$ = eax

; 738  : inline Mat::MStep::MStep() { p = buf; p[0] = p[1] = 0; }

	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [ecx+4], 0
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0
	ret	0
??0MStep@Mat@cv@@QAE@XZ ENDP				; cv::Mat::MStep::MStep
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0MSize@Mat@cv@@QAE@PAH@Z
_TEXT	SEGMENT
??0MSize@Mat@cv@@QAE@PAH@Z PROC				; cv::Mat::MSize::MSize, COMDAT
; _this$ = eax
; __p$ = ecx

; 709  : inline Mat::MSize::MSize(int* _p) : p(_p) {}

	mov	DWORD PTR [eax], ecx
	ret	0
??0MSize@Mat@cv@@QAE@PAH@Z ENDP				; cv::Mat::MSize::MSize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?release@Mat@cv@@QAEXXZ
_TEXT	SEGMENT
?release@Mat@cv@@QAEXXZ PROC				; cv::Mat::release, COMDAT
; _this$ = esi

; 366  :     if( refcount && CV_XADD(refcount, -1) == 1 )

	mov	eax, DWORD PTR [esi+20]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN4@release
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN4@release

; 367  :         deallocate();

	mov	ecx, esi
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN4@release:

; 368  :     data = datastart = dataend = datalimit = 0;
; 369  :     for(int i = 0; i < dims; i++)

	xor	eax, eax
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+16], edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN9@release
$LL3@release:

; 370  :         size.p[i] = 0;

	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [ecx+eax*4], edi
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL3@release
$LN9@release:

; 371  :     refcount = 0;

	mov	DWORD PTR [esi+20], edi
	pop	edi

; 372  : }

	ret	0
?release@Mat@cv@@QAEXXZ ENDP				; cv::Mat::release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1Mat@cv@@QAE@XZ
_TEXT	SEGMENT
??1Mat@cv@@QAE@XZ PROC					; cv::Mat::~Mat, COMDAT
; _this$ = eax

; 275  : {

	push	esi
	mov	esi, eax

; 276  :     release();

	mov	eax, DWORD PTR [esi+20]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN7@Mat
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN7@Mat
	mov	ecx, esi
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN7@Mat:
	xor	eax, eax
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+16], edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN4@Mat
	npad	7
$LL6@Mat:
	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [ecx+eax*4], edi
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL6@Mat
$LN4@Mat:

; 277  :     if( step.p != step.buf )

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+20], edi
	add	esi, 48					; 00000030H
	pop	edi
	cmp	eax, esi
	pop	esi
	je	SHORT $LN1@Mat

; 278  :         fastFree(step.p);

	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	pop	ecx
$LN1@Mat:

; 279  : }

	ret	0
??1Mat@cv@@QAE@XZ ENDP					; cv::Mat::~Mat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?initEmpty@Mat@cv@@IAEXXZ
_TEXT	SEGMENT
?initEmpty@Mat@cv@@IAEXXZ PROC				; cv::Mat::initEmpty, COMDAT
; _this$ = eax

; 60   :     flags = MAGIC_VAL;
; 61   :     dims = rows = cols = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], 1124007936		; 42ff0000H
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+4], ecx

; 62   :     data = datastart = dataend = datalimit = 0;

	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+16], ecx

; 63   :     refcount = 0;

	mov	DWORD PTR [eax+20], ecx

; 64   :     allocator = 0;

	mov	DWORD PTR [eax+36], ecx

; 65   : }

	ret	0
?initEmpty@Mat@cv@@IAEXXZ ENDP				; cv::Mat::initEmpty
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT
; __Left$ = edx
; __Right$ = eax

; 527  : 		_Left = _Right;

	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 528  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT
; __First1$ = edx
; __First2$ = ecx
; __Count$ = eax

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 518  : 		}

	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT
; __First1$ = edx
; __First2$ = ecx
; __Count$ = eax

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 498  : 		}

	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = eax

; 491  : 		return (_CSTD strlen(_First));

	lea	edx, DWORD PTR [eax+1]
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 492  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = -4						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = esi

; 345  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Message$[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

	mov	eax, esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T67458 = -16						; size = 12
$T67466 = -4						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN1@Allocate
	push	eax
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	jne	SHORT $LN7@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	lea	eax, DWORD PTR $T67466[ebp]
	push	eax
	lea	ecx, DWORD PTR $T67458[ebp]
	mov	DWORD PTR $T67466[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T67458[ebp]
	push	ecx
	mov	DWORD PTR $T67458[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN14@Allocate:
$LN7@Allocate:

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@Allocate:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
_TEXT	ENDS
;	COMDAT ?all@?$Scalar_@N@cv@@SA?AV12@N@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 8
?all@?$Scalar_@N@cv@@SA?AV12@N@Z PROC			; cv::Scalar_<double>::all, COMDAT
; ___$ReturnUdt$ = eax

; 2033 : { return Scalar_<_Tp>(v0, v0, v0, v0); }

	push	ebp
	mov	ebp, esp
	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR _v0$[ebp]
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	pop	ebp
	ret	0
?all@?$Scalar_@N@cv@@SA?AV12@N@Z ENDP			; cv::Scalar_<double>::all
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T67520 = -16						; size = 12
$T67512 = -4						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate
	cmp	ecx, -1
	ja	SHORT $LN3@allocate
	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate
$LN3@allocate:
	lea	eax, DWORD PTR $T67512[ebp]
	push	eax
	lea	ecx, DWORD PTR $T67520[ebp]
	mov	DWORD PTR $T67512[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T67520[ebp]
	push	ecx
	mov	DWORD PTR $T67520[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@allocate:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = eax
; __Ptr$ = esi

; 1973 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

	test	esi, esi
	je	SHORT $LN2@Inside
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN8@Inside
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	ecx, eax
$LN9@Inside:
	cmp	esi, ecx
	jb	SHORT $LN2@Inside
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN12@Inside
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN13@Inside
$LN12@Inside:
	mov	ecx, eax
$LN13@Inside:
	mov	eax, DWORD PTR [eax+16]
	add	eax, ecx
	cmp	eax, esi
	jbe	SHORT $LN2@Inside

; 1975 : 		else
; 1976 : 			return (true);

	mov	al, 1

; 1977 : 		}

	ret	0
$LN2@Inside:

; 1974 : 			return (false);	// don't ask

	xor	al, al

; 1977 : 		}

	ret	0
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = eax
; __Newsize$ = ecx

; 1953 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	mov	DWORD PTR [eax+16], ecx
	jb	SHORT $LN5@Eos
	mov	eax, DWORD PTR [eax]
$LN5@Eos:
	mov	BYTE PTR [eax+ecx], 0

; 1954 : 		}

	ret	0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = esi
; __Off$ = ecx
; __Count$ = eax

; 1108 : 		{	// erase elements [_Off, _Off + _Count)

	push	edi
	mov	edi, eax

; 1109 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ecx
	jae	SHORT $LN3@erase

; 1110 : 			_Xran();	// _Off off end

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN28@erase:
$LN3@erase:

; 1111 : 		if (this->_Mysize - _Off < _Count)

	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN2@erase

; 1112 : 			_Count = this->_Mysize - _Off;	// trim _Count

	mov	edi, eax
$LN2@erase:

; 1113 : 		if (0 < _Count)

	test	edi, edi
	je	SHORT $LN25@erase

; 1114 : 			{	// move elements down
; 1115 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1116 : 				this->_Mysize - _Off - _Count);

	mov	edx, DWORD PTR [esi+20]
	push	ebx
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN11@erase
	mov	ebx, DWORD PTR [esi]
	jmp	SHORT $LN12@erase
$LN11@erase:
	mov	ebx, esi
$LN12@erase:
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN15@erase
	mov	edx, DWORD PTR [esi]
	jmp	SHORT $LN16@erase
$LN15@erase:
	mov	edx, esi
$LN16@erase:
	sub	eax, edi
	add	ebx, ecx
	push	eax
	add	ebx, edi
	add	edx, ecx
	push	ebx
	push	edx
	call	DWORD PTR __imp__memmove

; 1117 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	eax, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	sub	eax, edi

; 1118 : 			_Eos(_Newsize);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], eax
	pop	ebx
	jb	SHORT $LN23@erase
	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR [ecx+eax], 0

; 1119 : 			}
; 1120 : 		return (*this);

	mov	eax, esi
	pop	edi

; 1121 : 		}

	ret	0

; 1118 : 			_Eos(_Newsize);

$LN23@erase:
	mov	ecx, esi
	mov	BYTE PTR [ecx+eax], 0
$LN25@erase:

; 1119 : 			}
; 1120 : 		return (*this);

	mov	eax, esi
	pop	edi

; 1121 : 		}

	ret	0
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = esi
; __Newsize$ = edi

; 1987 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 1988 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	je	SHORT $LN9@Tidy

; 1989 : 			;
; 1990 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN9@Tidy

; 1991 : 			{	// copy any leftovers to small buffer and deallocate
; 1992 : 			_Elem *_Ptr = this->_Bx._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 1993 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN7@Tidy

; 1994 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@Tidy:

; 1995 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

	push	ebx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
	pop	ebx
$LN9@Tidy:

; 1996 : 			}
; 1997 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1998 : 		_Eos(_Newsize);

	mov	DWORD PTR [esi+16], edi
	mov	BYTE PTR [edi+esi], 0

; 1999 : 		}

	pop	ebp
	ret	4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = esi

; 753  : 		_Tidy(true);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN11@basic_stri
	mov	eax, DWORD PTR [esi]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN11@basic_stri:
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0

; 754  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	__real@7fefffffffffffff
;	COMDAT __real@7fefffffffffffff
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\operations.hpp
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\imgproc\imgproc.hpp
CONST	ENDS
;	COMDAT ?morphologyDefaultBorderValue@cv@@YA?AV?$Scalar_@N@1@XZ
_TEXT	SEGMENT
?morphologyDefaultBorderValue@cv@@YA?AV?$Scalar_@N@1@XZ PROC ; cv::morphologyDefaultBorderValue, COMDAT
; ___$ReturnUdt$ = eax

; 370  : static inline Scalar morphologyDefaultBorderValue() { return Scalar::all(DBL_MAX); }

	fldz
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR __real@7fefffffffffffff
	fst	QWORD PTR [eax]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+24]
	ret	0
?morphologyDefaultBorderValue@cv@@YA?AV?$Scalar_@N@1@XZ ENDP ; cv::morphologyDefaultBorderValue
; Function compile flags: /Ogtp
; File c:\programs & apps\opencv\opencv\build\include\opencv2\core\mat.hpp
_TEXT	ENDS
;	COMDAT ??0Mat@cv@@QAE@XZ
_TEXT	SEGMENT
??0Mat@cv@@QAE@XZ PROC					; cv::Mat::Mat, COMDAT
; _this$ = eax

; 68   : {

	xor	ecx, ecx
	push	esi
	lea	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+40], edx
	lea	esi, DWORD PTR [eax+48]
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [esi+4], ecx
	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [esi], ecx

; 69   :     initEmpty();

	mov	DWORD PTR [eax], 1124007936		; 42ff0000H
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+36], ecx
	pop	esi

; 70   : }

	ret	0
??0Mat@cv@@QAE@XZ ENDP					; cv::Mat::Mat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\programs & apps\visual studio 10\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\programs & apps\visual studio 10\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
$T67865 = -36						; size = 12
__Newres$ = -24						; size = 4
$T67843 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Newsize$ = 12						; size = 4
__Oldlen$ = 16						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT

; 1918 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, DWORD PTR _this$[ebp]

; 1919 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	esi, eax
	or	esi, 15					; 0000000fH

; 1920 : 		if (max_size() < _Newres)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN9@Copy

; 1921 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	esi, eax
	jmp	SHORT $LN39@Copy
$LN9@Copy:

; 1922 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	ebx, DWORD PTR [edi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN39@Copy

; 1923 : 			;
; 1924 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, -2					; fffffffeH
	sub	eax, ecx

; 1925 : 			_Newres = this->_Myres
; 1926 : 				+ this->_Myres / 2;	// grow exponentially if possible

	lea	esi, DWORD PTR [ecx+ebx]
	cmp	ebx, eax
	jbe	SHORT $LN39@Copy

; 1927 : 		else
; 1928 : 			_Newres = max_size();	// settle for max_size()

	mov	esi, -2					; fffffffeH
$LN39@Copy:

; 1929 : 
; 1930 : 		_Elem *_Ptr;
; 1931 : 		_TRY_BEGIN

	xor	eax, eax

; 1932 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	cmp	ecx, eax
	jbe	SHORT $LN47@Copy
	cmp	ecx, -1
	ja	SHORT $LN46@Copy
	push	ecx
	call	DWORD PTR __imp_??2@YAPAXI@Z
	add	esp, 4
	test	eax, eax
	je	SHORT $LN46@Copy
$LN47@Copy:
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN19@Copy
$LN46@Copy:
	lea	ecx, DWORD PTR $T67843[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T67865[ebp]
	mov	DWORD PTR $T67843[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T67865[ebp]
	push	edx
	mov	DWORD PTR $T67865[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN112@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1933 : 		_CATCH_ALL
; 1934 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1935 : 			_TRY_BEGIN
; 1936 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Newres$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1940 : 			_CATCH_END
; 1941 : 		_CATCH_END

	mov	eax, $LN107@Copy
	ret	0
$LN107@Copy:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN19@Copy:

; 1942 : 
; 1943 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	je	SHORT $LN78@Copy

; 1944 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN76@Copy
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN77@Copy
$LN76@Copy:
	mov	eax, edi
$LN77@Copy:
	push	ebx
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN78@Copy:

; 1945 : 		_Tidy(true);

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN88@Copy
	mov	ecx, DWORD PTR [edi]
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN88@Copy:

; 1946 : 		this->_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edi], 0
	mov	DWORD PTR [edi], eax

; 1947 : 		this->_Myres = _Newres;

	mov	DWORD PTR [edi+20], esi

; 1948 : 		_Eos(_Oldlen);

	mov	DWORD PTR [edi+16], ebx
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN102@Copy
	mov	edi, eax
$LN102@Copy:
	mov	BYTE PTR [edi+ebx], 0

; 1949 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1937 : 			_CATCH_ALL
; 1938 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN64@Copy
	mov	edx, DWORD PTR [esi]
	push	edx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN64@Copy:

; 1939 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	push	0
	mov	BYTE PTR [esi], 0
	call	__CxxThrowException@8
$LN113@Copy:
$LN111@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = eax
; __Newsize$ = esi

; 1959 : 		if (max_size() < _Newsize)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN6@Grow

; 1960 : 			_Xlen();	// result too long

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN49@Grow:
$LN6@Grow:

; 1961 : 		if (this->_Myres < _Newsize)

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, esi
	jae	SHORT $LN3@Grow

; 1962 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	esi
	push	eax
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	edx, edx
	cmp	edx, esi
	sbb	eax, eax
	neg	eax

; 1969 : 		}

	ret	0
$LN3@Grow:

; 1963 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 1964 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1965 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 1966 : 		else if (_Newsize == 0)

	test	esi, esi
	jne	SHORT $LN46@Grow

; 1967 : 			_Eos(0);	// new size is zero, just null terminate

	mov	DWORD PTR [eax+16], esi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN44@Grow
	mov	eax, DWORD PTR [eax]
$LN44@Grow:
	mov	BYTE PTR [eax], 0
$LN46@Grow:

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	edx, edx
	cmp	edx, esi
	sbb	eax, eax
	neg	eax

; 1969 : 		}

	ret	0
$LN48@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx
; __Roff$ = ebx
; __Count$ = eax

; 892  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 893  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	push	edi
	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, ebx
	jae	SHORT $LN5@assign

; 894  : 			_Xran();	// _Roff off end

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN83@assign:
$LN5@assign:

; 895  : 		size_type _Num = _Right.size() - _Roff;

	sub	edi, ebx

; 896  : 		if (_Count < _Num)

	cmp	eax, edi
	jae	SHORT $LN4@assign

; 897  : 			_Num = _Count;	// trim _Num to size

	mov	edi, eax
$LN4@assign:

; 898  : 
; 899  : 		if (this == &_Right)

	cmp	esi, ecx
	jne	SHORT $LN3@assign

; 900  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	lea	ecx, DWORD PTR [edi+ebx]
	or	eax, -1
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	eax, ebx
	xor	ecx, ecx
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4
$LN3@assign:

; 901  : 		else if (_Grow(_Num))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN20@assign
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN84@assign:
$LN20@assign:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN19@assign
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	edi
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Right$[ebp]
	test	edi, edi
	je	SHORT $LN78@assign
$LN82@assign:

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	eax, 16					; 00000010H
	cmp	DWORD PTR [ecx+20], eax
	jb	SHORT $LN64@assign
	mov	ecx, DWORD PTR [ecx]
$LN64@assign:
	cmp	DWORD PTR [esi+20], eax
	jb	SHORT $LN68@assign
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN69@assign

; 901  : 		else if (_Grow(_Num))

$LN19@assign:
	test	edi, edi
	jne	SHORT $LN82@assign
	mov	DWORD PTR [esi+16], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN58@assign
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax], 0
	pop	edi

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4

; 901  : 		else if (_Grow(_Num))

$LN58@assign:
	mov	eax, esi
	pop	edi
	mov	BYTE PTR [eax], 0
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$LN68@assign:
	mov	eax, esi
$LN69@assign:
	push	edi
	add	ecx, ebx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 904  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], edi
	jb	SHORT $LN76@assign
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4

; 904  : 			_Eos(_Num);

$LN76@assign:
	mov	eax, esi
	mov	BYTE PTR [eax+edi], 0
$LN78@assign:

; 905  : 			}
; 906  : 		return (*this);

	pop	edi
	mov	eax, esi
	pop	esi

; 907  : 		}

	pop	ebp
	ret	4
$LN80@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = esi
; __Ptr$ = eax
; __Count$ = edi

; 910  : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebx
	mov	ebx, eax

; 911  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 912  : 		if (_Count != 0)
; 913  : 			_DEBUG_POINTER(_Ptr);
; 914  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 915  : 
; 916  : 		if (_Inside(_Ptr))

	test	ebx, ebx
	je	SHORT $LN85@assign@2
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@assign@2
$LN12@assign@2:
	mov	eax, esi
$LN13@assign@2:
	cmp	ebx, eax
	jb	SHORT $LN85@assign@2
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN16@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN17@assign@2
$LN16@assign@2:
	mov	eax, esi
$LN17@assign@2:
	mov	edx, DWORD PTR [esi+16]
	add	edx, eax
	cmp	edx, ebx
	jbe	SHORT $LN85@assign@2

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign@2
	mov	eax, DWORD PTR [esi]
	sub	ebx, eax
	push	esi
	mov	eax, edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	ebx

; 925  : 		}

	ret	0

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

$LN20@assign@2:
	mov	eax, esi
	sub	ebx, eax
	push	esi
	mov	eax, edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	ebx

; 925  : 		}

	ret	0
$LN85@assign@2:

; 918  : 
; 919  : 		if (_Grow(_Count))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@assign@2
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN90@assign@2:
$LN27@assign@2:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN26@assign@2
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	edi
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
	je	SHORT $LN82@assign@2
$LN89@assign@2:

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN72@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN73@assign@2

; 918  : 
; 919  : 		if (_Grow(_Count))

$LN26@assign@2:
	test	edi, edi
	jne	SHORT $LN89@assign@2
	mov	DWORD PTR [esi+16], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN65@assign@2
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax], 0

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 925  : 		}

	ret	0

; 918  : 
; 919  : 		if (_Grow(_Count))

$LN65@assign@2:
	mov	eax, esi
	mov	BYTE PTR [eax], 0
	pop	ebx

; 925  : 		}

	ret	0

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

$LN72@assign@2:
	mov	eax, esi
$LN73@assign@2:
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 922  : 			_Eos(_Count);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], edi
	jb	SHORT $LN80@assign@2
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi], 0

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 925  : 		}

	ret	0

; 922  : 			_Eos(_Count);

$LN80@assign@2:
	mov	eax, esi
	mov	BYTE PTR [eax+edi], 0
$LN82@assign@2:

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 925  : 		}

	ret	0
$LN87@assign@2:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; __Ptr$ = eax

; 928  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi

; 929  : 		_DEBUG_POINTER(_Ptr);
; 930  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, eax
	push	edi
	lea	esi, DWORD PTR [ecx+1]
	npad	6
$LL5@assign@3:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL5@assign@3
	sub	ecx, esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, ecx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 931  : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx
; __Ptr$ = eax

; 592  : 		{	// construct from [_Ptr, <null>)

	push	esi
	mov	esi, ecx

; 593  : 		_Tidy();
; 594  : 		assign(_Ptr);

	mov	ecx, eax
	push	edi
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0
	lea	edi, DWORD PTR [ecx+1]
	npad	6
$LL31@basic_stri@2:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL31@basic_stri@2
	sub	ecx, edi
	mov	edi, ecx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 595  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@407e000000000000
PUBLIC	__real@4084000000000000
PUBLIC	__$ArrayPad$
PUBLIC	?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z	; MathFuncs::MyMathFuncs::Subtract
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@407e000000000000
CONST	SEGMENT
__real@407e000000000000 DQ 0407e000000000000r	; 480
CONST	ENDS
;	COMDAT __real@4084000000000000
CONST	SEGMENT
__real@4084000000000000 DQ 04084000000000000r	; 640
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$8
	DD	03H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$9
	DD	03H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$10
	DD	03H
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$13
__ehfuncinfo$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\oj\documents\visual studio 2010\projects\cvdetectordll - copy\cvdetectordll.cpp
xdata$x	ENDS
;	COMDAT ?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z
_TEXT	SEGMENT
$T68674 = -556						; size = 4
$T68669 = -556						; size = 4
$T68664 = -556						; size = 4
$T68659 = -556						; size = 4
$T68657 = -556						; size = 4
$T68656 = -556						; size = 4
$T68655 = -556						; size = 4
$T68654 = -556						; size = 4
$T68645 = -556						; size = 4
$T68677 = -552						; size = 20
$T68672 = -552						; size = 20
$T68667 = -552						; size = 20
$T68662 = -552						; size = 20
$T68652 = -552						; size = 20
$T68648 = -552						; size = 20
$T68646 = -552						; size = 20
$T68644 = -552						; size = 20
$T68651 = -532						; size = 20
$T68649 = -532						; size = 20
$T68647 = -532						; size = 20
_vcap$ = -512						; size = 12
$T68680 = -500						; size = 20
$T68678 = -500						; size = 20
$T68675 = -500						; size = 20
$T68670 = -500						; size = 20
$T68665 = -500						; size = 20
$T68660 = -500						; size = 20
$T68653 = -500						; size = 20
$T58577 = -500						; size = 28
$T58572 = -500						; size = 28
$T58571 = -500						; size = 28
$T58570 = -500						; size = 28
$T58569 = -500						; size = 28
$T58568 = -500						; size = 28
$T58567 = -500						; size = 28
$T68673 = -472						; size = 32
$T68668 = -472						; size = 32
$T68663 = -472						; size = 32
$T68658 = -472						; size = 32
$T58585 = -472						; size = 32
$T58624 = -436						; size = 28
$T68679 = -436						; size = 20
$T68676 = -436						; size = 20
$T68671 = -436						; size = 20
$T68666 = -436						; size = 20
$T68661 = -436						; size = 20
$T68650 = -436						; size = 20
_dst$ = -408						; size = 56
$T58586 = -352						; size = 32
_trackbarWindowName$ = -316				; size = 28
_cameraFeed$ = -288					; size = 56
_dilateElement$58596 = -232				; size = 56
_erodeElement$58591 = -176				; size = 56
_TrackbarName$ = -120					; size = 50
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
_a$ = 8							; size = 8
_b$ = 16						; size = 8
?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z PROC		; MathFuncs::MyMathFuncs::Subtract, COMDAT

; 34   :     {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	push	-1
	push	__ehhandler$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+564], eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+580]
	mov	DWORD PTR fs:0, eax

; 35   : 		Mat cameraFeed;

	xor	ebx, ebx
	lea	eax, DWORD PTR _cameraFeed$[esp+588]
	mov	DWORD PTR _cameraFeed$[esp+620], eax
	lea	ecx, DWORD PTR _cameraFeed$[esp+628]
	mov	eax, 1124007936				; 42ff0000H
	mov	DWORD PTR _cameraFeed$[esp+624], ecx
	mov	DWORD PTR _cameraFeed$[esp+632], ebx
	mov	DWORD PTR _cameraFeed$[esp+628], ebx
	mov	DWORD PTR _cameraFeed$[esp+580], eax
	mov	DWORD PTR _cameraFeed$[esp+592], ebx
	mov	DWORD PTR _cameraFeed$[esp+588], ebx
	mov	DWORD PTR _cameraFeed$[esp+584], ebx
	mov	DWORD PTR _cameraFeed$[esp+612], ebx
	mov	DWORD PTR _cameraFeed$[esp+608], ebx
	mov	DWORD PTR _cameraFeed$[esp+604], ebx
	mov	DWORD PTR _cameraFeed$[esp+596], ebx
	mov	DWORD PTR _cameraFeed$[esp+600], ebx
	mov	DWORD PTR _cameraFeed$[esp+616], ebx
	mov	DWORD PTR __$EHRec$[esp+588], ebx

; 36   : 		Mat dst;

	lea	edx, DWORD PTR _dst$[esp+588]
	lea	ecx, DWORD PTR _dst$[esp+628]
	mov	DWORD PTR _dst$[esp+620], edx
	mov	DWORD PTR _dst$[esp+624], ecx
	mov	DWORD PTR _dst$[esp+632], ebx
	mov	DWORD PTR _dst$[esp+628], ebx
	mov	DWORD PTR _dst$[esp+580], eax
	mov	DWORD PTR _dst$[esp+592], ebx
	mov	DWORD PTR _dst$[esp+588], ebx
	mov	DWORD PTR _dst$[esp+584], ebx
	mov	DWORD PTR _dst$[esp+612], ebx
	mov	DWORD PTR _dst$[esp+608], ebx
	mov	DWORD PTR _dst$[esp+604], ebx
	mov	DWORD PTR _dst$[esp+596], ebx
	mov	DWORD PTR _dst$[esp+600], ebx
	mov	DWORD PTR _dst$[esp+616], ebx

; 37   : 		VideoCapture vcap;

	lea	ecx, DWORD PTR _vcap$[esp+580]
	mov	BYTE PTR __$EHRec$[esp+588], 1
	call	DWORD PTR __imp_??0VideoCapture@cv@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+588], 2

; 38   : 
; 39   : 		//create window for trackbars
; 40   : 		string trackbarWindowName = "Make the symbols appear white";

	lea	edi, DWORD PTR [ebx+29]
	mov	eax, OFFSET ??_C@_0BO@GAFFBBJF@Make?5the?5symbols?5appear?5white?$AA@
	lea	esi, DWORD PTR _trackbarWindowName$[esp+580]
	mov	DWORD PTR _trackbarWindowName$[esp+600], 15 ; 0000000fH
	mov	DWORD PTR _trackbarWindowName$[esp+596], ebx
	mov	BYTE PTR _trackbarWindowName$[esp+580], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 41   : 
; 42   : 		namedWindow(trackbarWindowName,0);

	mov	edx, esi
	push	ebx
	push	edx
	mov	BYTE PTR __$EHRec$[esp+596], 3
	call	DWORD PTR __imp_?namedWindow@cv@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z

; 43   : 		//create memory to store trackbar name on window
; 44   : 		char TrackbarName[50];
; 45   : 		sprintf( TrackbarName, "H_MIN", H_MIN);

	mov	eax, DWORD PTR ?H_MIN@@3HA		; H_MIN
	mov	esi, DWORD PTR __imp__sprintf
	push	eax
	lea	ecx, DWORD PTR _TrackbarName$[esp+592]
	push	OFFSET ??_C@_05GPLKNKGD@H_MIN?$AA@
	push	ecx
	call	esi

; 46   : 		sprintf( TrackbarName, "H_MAX", H_MAX);

	mov	edx, DWORD PTR ?H_MAX@@3HA		; H_MAX
	add	esp, 20					; 00000014H
	push	edx
	lea	eax, DWORD PTR _TrackbarName$[esp+584]
	push	OFFSET ??_C@_05HNDBDOAM@H_MAX?$AA@
	push	eax
	call	esi

; 47   : 		sprintf( TrackbarName, "S_MIN", S_MIN);

	mov	ecx, DWORD PTR ?S_MIN@@3HA		; S_MIN
	add	esp, 12					; 0000000cH
	push	ecx
	lea	edx, DWORD PTR _TrackbarName$[esp+584]
	push	OFFSET ??_C@_05GKLCIDL@S_MIN?$AA@
	push	edx
	call	esi

; 48   : 		sprintf( TrackbarName, "S_MAX", S_MAX);

	mov	eax, DWORD PTR ?S_MAX@@3HA		; S_MAX
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_05BECAMMFE@S_MAX?$AA@
	lea	ecx, DWORD PTR _TrackbarName$[esp+588]
	push	ecx
	call	esi

; 49   : 		sprintf( TrackbarName, "V_MIN", V_MIN);

	mov	edx, DWORD PTR ?V_MIN@@3HA		; V_MIN
	add	esp, 12					; 0000000cH
	push	edx
	lea	eax, DWORD PTR _TrackbarName$[esp+584]
	push	OFFSET ??_C@_05FGGGLJII@V_MIN?$AA@
	push	eax
	call	esi

; 50   : 		sprintf( TrackbarName, "V_MAX", V_MAX);

	mov	ecx, DWORD PTR ?V_MAX@@3HA		; V_MAX
	add	esp, 12					; 0000000cH
	push	ecx
	lea	edx, DWORD PTR _TrackbarName$[esp+584]
	push	OFFSET ??_C@_05EEONFNOH@V_MAX?$AA@
	push	edx
	call	esi
	add	esp, 12					; 0000000cH

; 51   : 		//create trackbars and insert them into window
; 52   : 		//3 parameters are: the address of the variable that is changing when the trackbar is moved(eg.H_LOW),
; 53   : 		//the max value the trackbar can move (eg. H_HIGH), 
; 54   : 		//and the function that is called whenever the trackbar is moved(eg. on_trackbar)
; 55   : 		//                                  ---->    ---->     ---->      
; 56   : 		createTrackbar( "H_MIN", trackbarWindowName, &H_MIN, H_MAX, onTrackbarMove );

	lea	edi, DWORD PTR [ebx+5]
	mov	eax, OFFSET ??_C@_05GPLKNKGD@H_MIN?$AA@
	lea	esi, DWORD PTR $T58567[esp+580]
	mov	DWORD PTR $T58567[esp+600], 15		; 0000000fH
	mov	DWORD PTR $T58567[esp+596], ebx
	mov	BYTE PTR $T58567[esp+580], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	push	OFFSET ?onTrackbarMove@MathFuncs@@YAXHPAX@Z ; MathFuncs::onTrackbarMove
	mov	BYTE PTR __$EHRec$[esp+596], 4
	mov	eax, DWORD PTR ?H_MAX@@3HA		; H_MAX
	push	eax
	push	OFFSET ?H_MIN@@3HA			; H_MIN
	lea	ecx, DWORD PTR _trackbarWindowName$[esp+596]
	push	ecx
	mov	edx, esi
	push	edx
	call	DWORD PTR __imp_?createTrackbar@cv@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PAHHP6AXHPAX@Z2@Z
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+588], 3
	cmp	DWORD PTR $T58567[esp+600], 16		; 00000010H
	jb	SHORT $LN105@Subtract
	mov	eax, DWORD PTR $T58567[esp+580]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN105@Subtract:

; 57   : 		createTrackbar( "H_MAX", trackbarWindowName, &H_MAX, H_MAX, onTrackbarMove );

	mov	edi, 5
	mov	eax, OFFSET ??_C@_05HNDBDOAM@H_MAX?$AA@
	lea	esi, DWORD PTR $T58568[esp+580]
	mov	DWORD PTR $T58568[esp+600], 15		; 0000000fH
	mov	DWORD PTR $T58568[esp+596], ebx
	mov	BYTE PTR $T58568[esp+580], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	push	OFFSET ?onTrackbarMove@MathFuncs@@YAXHPAX@Z ; MathFuncs::onTrackbarMove
	mov	BYTE PTR __$EHRec$[esp+596], 5
	mov	ecx, DWORD PTR ?H_MAX@@3HA		; H_MAX
	push	ecx
	push	OFFSET ?H_MAX@@3HA			; H_MAX
	lea	edx, DWORD PTR _trackbarWindowName$[esp+596]
	push	edx
	mov	eax, esi
	push	eax
	call	DWORD PTR __imp_?createTrackbar@cv@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PAHHP6AXHPAX@Z2@Z
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+588], 3
	cmp	DWORD PTR $T58568[esp+600], 16		; 00000010H
	jb	SHORT $LN157@Subtract
	mov	ecx, DWORD PTR $T58568[esp+580]
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN157@Subtract:

; 58   : 		createTrackbar( "S_MIN", trackbarWindowName, &S_MIN, S_MAX, onTrackbarMove );

	mov	edi, 5
	mov	eax, OFFSET ??_C@_05GKLCIDL@S_MIN?$AA@
	lea	esi, DWORD PTR $T58569[esp+580]
	mov	DWORD PTR $T58569[esp+600], 15		; 0000000fH
	mov	DWORD PTR $T58569[esp+596], ebx
	mov	BYTE PTR $T58569[esp+580], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	push	OFFSET ?onTrackbarMove@MathFuncs@@YAXHPAX@Z ; MathFuncs::onTrackbarMove
	mov	BYTE PTR __$EHRec$[esp+596], 6
	mov	edx, DWORD PTR ?S_MAX@@3HA		; S_MAX
	push	edx
	push	OFFSET ?S_MIN@@3HA			; S_MIN
	lea	eax, DWORD PTR _trackbarWindowName$[esp+596]
	push	eax
	mov	ecx, esi
	push	ecx
	call	DWORD PTR __imp_?createTrackbar@cv@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PAHHP6AXHPAX@Z2@Z
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+588], 3
	cmp	DWORD PTR $T58569[esp+600], 16		; 00000010H
	jb	SHORT $LN209@Subtract
	mov	edx, DWORD PTR $T58569[esp+580]
	push	edx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN209@Subtract:

; 59   : 		createTrackbar( "S_MAX", trackbarWindowName, &S_MAX, S_MAX, onTrackbarMove );

	mov	edi, 5
	mov	eax, OFFSET ??_C@_05BECAMMFE@S_MAX?$AA@
	lea	esi, DWORD PTR $T58570[esp+580]
	mov	DWORD PTR $T58570[esp+600], 15		; 0000000fH
	mov	DWORD PTR $T58570[esp+596], ebx
	mov	BYTE PTR $T58570[esp+580], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	push	OFFSET ?onTrackbarMove@MathFuncs@@YAXHPAX@Z ; MathFuncs::onTrackbarMove
	mov	BYTE PTR __$EHRec$[esp+596], 7
	mov	eax, DWORD PTR ?S_MAX@@3HA		; S_MAX
	push	eax
	push	OFFSET ?S_MAX@@3HA			; S_MAX
	lea	ecx, DWORD PTR _trackbarWindowName$[esp+596]
	push	ecx
	mov	edx, esi
	push	edx
	call	DWORD PTR __imp_?createTrackbar@cv@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PAHHP6AXHPAX@Z2@Z
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+588], 3
	cmp	DWORD PTR $T58570[esp+600], 16		; 00000010H
	jb	SHORT $LN261@Subtract
	mov	eax, DWORD PTR $T58570[esp+580]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN261@Subtract:

; 60   : 		createTrackbar( "V_MIN", trackbarWindowName, &V_MIN, V_MAX, onTrackbarMove );

	mov	edi, 5
	mov	eax, OFFSET ??_C@_05FGGGLJII@V_MIN?$AA@
	lea	esi, DWORD PTR $T58571[esp+580]
	mov	DWORD PTR $T58571[esp+600], 15		; 0000000fH
	mov	DWORD PTR $T58571[esp+596], ebx
	mov	BYTE PTR $T58571[esp+580], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	push	OFFSET ?onTrackbarMove@MathFuncs@@YAXHPAX@Z ; MathFuncs::onTrackbarMove
	mov	BYTE PTR __$EHRec$[esp+596], 8
	mov	ecx, DWORD PTR ?V_MAX@@3HA		; V_MAX
	push	ecx
	push	OFFSET ?V_MIN@@3HA			; V_MIN
	lea	edx, DWORD PTR _trackbarWindowName$[esp+596]
	push	edx
	mov	eax, esi
	push	eax
	call	DWORD PTR __imp_?createTrackbar@cv@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PAHHP6AXHPAX@Z2@Z
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+588], 3
	cmp	DWORD PTR $T58571[esp+600], 16		; 00000010H
	jb	SHORT $LN313@Subtract
	mov	ecx, DWORD PTR $T58571[esp+580]
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN313@Subtract:

; 61   : 		createTrackbar( "V_MAX", trackbarWindowName, &V_MAX, V_MAX, onTrackbarMove );

	mov	edi, 5
	mov	eax, OFFSET ??_C@_05EEONFNOH@V_MAX?$AA@
	lea	esi, DWORD PTR $T58572[esp+580]
	mov	DWORD PTR $T58572[esp+600], 15		; 0000000fH
	mov	DWORD PTR $T58572[esp+596], ebx
	mov	BYTE PTR $T58572[esp+580], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	push	OFFSET ?onTrackbarMove@MathFuncs@@YAXHPAX@Z ; MathFuncs::onTrackbarMove
	mov	BYTE PTR __$EHRec$[esp+596], 9
	mov	edx, DWORD PTR ?V_MAX@@3HA		; V_MAX
	push	edx
	push	OFFSET ?V_MAX@@3HA			; V_MAX
	lea	eax, DWORD PTR _trackbarWindowName$[esp+596]
	push	eax
	mov	ecx, esi
	push	ecx
	call	DWORD PTR __imp_?createTrackbar@cv@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PAHHP6AXHPAX@Z2@Z
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[esp+588], 3
	cmp	DWORD PTR $T58572[esp+600], 16		; 00000010H
	jb	SHORT $LN365@Subtract
	mov	edx, DWORD PTR $T58572[esp+580]
	push	edx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN365@Subtract:

; 62   : 		//Run the webcam (=0)
; 63   : 		vcap.open(0);

	push	ebx
	lea	ecx, DWORD PTR _vcap$[esp+584]
	call	DWORD PTR __imp_?open@VideoCapture@cv@@UAE_NH@Z

; 64   : 		//set height and width of capture frame
; 65   : 		vcap.set(CV_CAP_PROP_FRAME_WIDTH,FRAME_WIDTH);

	fld	QWORD PTR __real@4084000000000000
	mov	esi, DWORD PTR __imp_?set@VideoCapture@cv@@UAE_NHN@Z
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	3
	lea	ecx, DWORD PTR _vcap$[esp+592]
	call	esi

; 66   : 		vcap.set(CV_CAP_PROP_FRAME_HEIGHT,FRAME_HEIGHT);

	fld	QWORD PTR __real@407e000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	4
	lea	ecx, DWORD PTR _vcap$[esp+592]
	call	esi
	mov	ebx, DWORD PTR __imp_??0_InputArray@cv@@QAE@ABVMat@1@@Z
	npad	11
$LL2@Subtract:

; 67   : 
; 68   : 		while(1){
; 69   : 			// Read stream from webcam
; 70   : 			vcap.read(cameraFeed);

	lea	eax, DWORD PTR _cameraFeed$[esp+580]
	push	eax
	lea	ecx, DWORD PTR _vcap$[esp+584]
	call	DWORD PTR __imp_?read@VideoCapture@cv@@UAE_NAAVMat@2@@Z

; 71   : 			// Show the original image
; 72   : 			imshow("Example3-in", cameraFeed);

	lea	ecx, DWORD PTR _cameraFeed$[esp+580]
	push	ecx
	lea	ecx, DWORD PTR $T68644[esp+584]
	call	ebx
	mov	edi, 11					; 0000000bH
	mov	eax, OFFSET ??_C@_0M@ELNMGJKA@Example3?9in?$AA@
	lea	esi, DWORD PTR $T58577[esp+580]
	mov	DWORD PTR $T58577[esp+600], 15		; 0000000fH
	mov	DWORD PTR $T58577[esp+596], 0
	mov	BYTE PTR $T58577[esp+580], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	edx, DWORD PTR $T68644[esp+580]
	push	edx
	mov	eax, esi
	push	eax
	mov	BYTE PTR __$EHRec$[esp+596], 10		; 0000000aH
	call	DWORD PTR __imp_?imshow@cv@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV_InputArray@1@@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+588], 3
	cmp	DWORD PTR $T58577[esp+600], 16		; 00000010H
	jb	SHORT $LN417@Subtract
	mov	ecx, DWORD PTR $T58577[esp+580]
	push	ecx
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN417@Subtract:

; 73   : 
; 74   : 			// Perform a Gaussian blur
; 75   : 			GaussianBlur(cameraFeed, dst, Size( 15, 15), 0, 0);

	mov	esi, DWORD PTR __imp_??0_OutputArray@cv@@QAE@AAVMat@1@@Z
	lea	edx, DWORD PTR _dst$[esp+580]
	push	edx
	lea	ecx, DWORD PTR $T68646[esp+584]
	call	esi
	lea	eax, DWORD PTR _cameraFeed$[esp+580]
	push	eax
	lea	ecx, DWORD PTR $T68647[esp+584]
	call	ebx
	fldz
	mov	edi, 4
	push	edi
	sub	esp, 24					; 00000018H
	mov	eax, esp
	fst	QWORD PTR [esp+16]
	lea	ecx, DWORD PTR $T68646[esp+608]
	fstp	QWORD PTR [esp+8]
	mov	DWORD PTR $T68645[esp+608], esp
	push	ecx
	lea	edx, DWORD PTR $T68647[esp+612]
	push	edx
	mov	DWORD PTR [eax], 15			; 0000000fH
	mov	DWORD PTR [eax+4], 15			; 0000000fH
	call	DWORD PTR __imp_?GaussianBlur@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@V?$Size_@H@1@NNH@Z
	add	esp, 36					; 00000024H

; 76   : 			//Convert to HSV
; 77   : 			cvtColor(dst,dst,COLOR_BGR2HSV);

	lea	eax, DWORD PTR _dst$[esp+580]
	push	eax
	lea	ecx, DWORD PTR $T68648[esp+584]
	call	esi
	lea	ecx, DWORD PTR _dst$[esp+580]
	push	ecx
	lea	ecx, DWORD PTR $T68649[esp+584]
	call	ebx
	push	0
	push	40					; 00000028H
	lea	edx, DWORD PTR $T68648[esp+588]
	push	edx
	lea	eax, DWORD PTR $T68649[esp+592]
	push	eax
	call	DWORD PTR __imp_?cvtColor@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@HH@Z
	add	esp, 16					; 00000010H

; 78   : 			// Apply threshold to eliminate noise and emphasize filtered objects
; 79   : 			inRange(dst,Scalar(H_MIN,S_MIN,V_MIN),Scalar(H_MAX,S_MAX,V_MAX),dst);

	lea	ecx, DWORD PTR _dst$[esp+580]
	push	ecx
	lea	ecx, DWORD PTR $T68650[esp+584]
	call	esi
	fild	DWORD PTR ?V_MAX@@3HA			; V_MAX
	fild	DWORD PTR ?S_MAX@@3HA			; S_MAX
	xor	eax, eax
	fild	DWORD PTR ?H_MAX@@3HA			; H_MAX
	mov	DWORD PTR $T58586[esp+580], eax
	mov	DWORD PTR $T58586[esp+584], eax
	mov	DWORD PTR $T58586[esp+588], eax
	fstp	QWORD PTR $T58586[esp+580]
	mov	DWORD PTR $T58586[esp+592], eax
	mov	DWORD PTR $T58586[esp+596], eax
	fstp	QWORD PTR $T58586[esp+588]
	mov	DWORD PTR $T58586[esp+600], eax
	mov	DWORD PTR $T58586[esp+604], eax
	fstp	QWORD PTR $T58586[esp+596]
	mov	DWORD PTR $T58586[esp+608], eax
	fldz
	lea	eax, DWORD PTR $T58586[esp+580]
	fst	QWORD PTR $T58586[esp+604]
	mov	DWORD PTR $T68651[esp+588], eax
	fild	DWORD PTR ?V_MIN@@3HA			; V_MIN
	xor	eax, eax
	fild	DWORD PTR ?S_MIN@@3HA			; S_MIN
	mov	edx, -1073610746			; c0020006H
	fild	DWORD PTR ?H_MIN@@3HA			; H_MIN
	mov	ecx, 1
	mov	DWORD PTR $T68651[esp+580], OFFSET ??_7_InputArray@cv@@6B@
	mov	DWORD PTR $T68651[esp+584], edx
	mov	DWORD PTR $T68651[esp+592], ecx
	mov	DWORD PTR $T68651[esp+596], edi
	mov	DWORD PTR $T58585[esp+580], eax
	mov	DWORD PTR $T58585[esp+584], eax
	mov	DWORD PTR $T58585[esp+588], eax
	mov	DWORD PTR $T58585[esp+592], eax
	mov	DWORD PTR $T58585[esp+596], eax
	mov	DWORD PTR $T58585[esp+600], eax
	mov	DWORD PTR $T58585[esp+604], eax
	fstp	QWORD PTR $T58585[esp+580]
	mov	DWORD PTR $T58585[esp+608], eax
	mov	DWORD PTR $T68652[esp+584], edx
	fstp	QWORD PTR $T58585[esp+588]
	lea	eax, DWORD PTR _dst$[esp+580]
	lea	edx, DWORD PTR $T58585[esp+580]
	fstp	QWORD PTR $T58585[esp+596]
	mov	DWORD PTR $T68652[esp+592], ecx
	push	eax
	lea	ecx, DWORD PTR $T68653[esp+584]
	fstp	QWORD PTR $T58585[esp+608]
	mov	DWORD PTR $T68652[esp+584], OFFSET ??_7_InputArray@cv@@6B@
	mov	DWORD PTR $T68652[esp+592], edx
	mov	DWORD PTR $T68652[esp+600], edi
	call	ebx
	lea	ecx, DWORD PTR $T68650[esp+580]
	push	ecx
	lea	edx, DWORD PTR $T68651[esp+584]
	push	edx
	lea	eax, DWORD PTR $T68652[esp+588]
	push	eax
	lea	ecx, DWORD PTR $T68653[esp+592]
	push	ecx
	call	DWORD PTR __imp_?inRange@cv@@YAXABV_InputArray@1@00ABV_OutputArray@1@@Z

; 80   : 			//erode and dilate with larger element so make sure object is nicely visible
; 81   : 			Mat erodeElement = getStructuringElement( MORPH_RECT,Size(2,2));

	add	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T68654[esp+588], esp
	sub	esp, 8
	or	edi, -1
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	eax, esp
	mov	DWORD PTR $T68655[esp+596], esp
	lea	edx, DWORD PTR _erodeElement$58591[esp+596]
	push	0
	push	edx
	mov	DWORD PTR [eax], 2
	mov	DWORD PTR [eax+4], 2
	call	DWORD PTR __imp_?getStructuringElement@cv@@YA?AVMat@1@HV?$Size_@H@1@V?$Point_@H@1@@Z

; 82   : 			Mat dilateElement = getStructuringElement( MORPH_RECT,Size(4,4));

	add	esp, 16					; 00000010H
	mov	eax, esp
	mov	BYTE PTR __$EHRec$[esp+596], 11		; 0000000bH
	mov	DWORD PTR $T68656[esp+588], esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T68657[esp+596], esp
	mov	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 4
	lea	eax, DWORD PTR _dilateElement$58596[esp+596]
	push	0
	push	eax
	call	DWORD PTR __imp_?getStructuringElement@cv@@YA?AVMat@1@HV?$Size_@H@1@V?$Point_@H@1@@Z
	add	esp, 24					; 00000018H

; 83   : 			erode(dst,dst,erodeElement);

	lea	ecx, DWORD PTR _erodeElement$58591[esp+580]
	push	ecx
	lea	ecx, DWORD PTR $T68660[esp+584]
	mov	BYTE PTR __$EHRec$[esp+592], 12		; 0000000cH
	call	ebx
	lea	edx, DWORD PTR _dst$[esp+580]
	push	edx
	lea	ecx, DWORD PTR $T68661[esp+584]
	call	esi
	lea	eax, DWORD PTR _dst$[esp+580]
	push	eax
	lea	ecx, DWORD PTR $T68662[esp+584]
	call	ebx
	fld	QWORD PTR __real@7fefffffffffffff
	xor	eax, eax
	mov	DWORD PTR $T68658[esp+580], eax
	mov	DWORD PTR $T68658[esp+584], eax
	fst	QWORD PTR $T68658[esp+580]
	mov	DWORD PTR $T68658[esp+588], eax
	mov	DWORD PTR $T68658[esp+592], eax
	mov	DWORD PTR $T68658[esp+596], eax
	mov	DWORD PTR $T68658[esp+600], eax
	mov	DWORD PTR $T68658[esp+604], eax
	mov	DWORD PTR $T68658[esp+608], eax
	lea	ecx, DWORD PTR $T68658[esp+580]
	fst	QWORD PTR $T68658[esp+588]
	push	ecx
	fst	QWORD PTR $T68658[esp+600]
	push	eax
	fstp	QWORD PTR $T68658[esp+612]
	push	1
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T68659[esp+600], esp
	lea	edx, DWORD PTR $T68660[esp+600]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	push	edx
	lea	eax, DWORD PTR $T68661[esp+604]
	push	eax
	lea	ecx, DWORD PTR $T68662[esp+608]
	push	ecx
	call	DWORD PTR __imp_?erode@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z
	add	esp, 32					; 00000020H

; 84   : 			erode(dst,dst,erodeElement);

	lea	edx, DWORD PTR _erodeElement$58591[esp+580]
	push	edx
	lea	ecx, DWORD PTR $T68665[esp+584]
	call	ebx
	lea	eax, DWORD PTR _dst$[esp+580]
	push	eax
	lea	ecx, DWORD PTR $T68666[esp+584]
	call	esi
	lea	ecx, DWORD PTR _dst$[esp+580]
	push	ecx
	lea	ecx, DWORD PTR $T68667[esp+584]
	call	ebx
	fld	QWORD PTR __real@7fefffffffffffff
	xor	eax, eax
	lea	edx, DWORD PTR $T68663[esp+580]
	push	edx
	push	eax
	mov	DWORD PTR $T68663[esp+588], eax
	mov	DWORD PTR $T68663[esp+592], eax
	fst	QWORD PTR $T68663[esp+588]
	mov	DWORD PTR $T68663[esp+596], eax
	mov	DWORD PTR $T68663[esp+600], eax
	fst	QWORD PTR $T68663[esp+596]
	push	1
	mov	DWORD PTR $T68663[esp+608], eax
	mov	DWORD PTR $T68663[esp+612], eax
	fst	QWORD PTR $T68663[esp+608]
	mov	DWORD PTR $T68663[esp+616], eax
	mov	DWORD PTR $T68663[esp+620], eax
	fstp	QWORD PTR $T68663[esp+616]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR $T68664[esp+600], esp
	lea	eax, DWORD PTR $T68665[esp+600]
	push	eax
	lea	ecx, DWORD PTR $T68666[esp+604]
	push	ecx
	lea	edx, DWORD PTR $T68667[esp+608]
	push	edx
	call	DWORD PTR __imp_?erode@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z
	add	esp, 32					; 00000020H

; 85   : 			dilate(dst,dst,dilateElement);

	lea	eax, DWORD PTR _dilateElement$58596[esp+580]
	push	eax
	lea	ecx, DWORD PTR $T68670[esp+584]
	call	ebx
	lea	ecx, DWORD PTR _dst$[esp+580]
	push	ecx
	lea	ecx, DWORD PTR $T68671[esp+584]
	call	esi
	lea	edx, DWORD PTR _dst$[esp+580]
	push	edx
	lea	ecx, DWORD PTR $T68672[esp+584]
	call	ebx
	xor	eax, eax
	mov	DWORD PTR $T68668[esp+580], eax
	mov	DWORD PTR $T68668[esp+584], eax
	mov	DWORD PTR $T68668[esp+588], eax
	mov	DWORD PTR $T68668[esp+592], eax
	mov	DWORD PTR $T68668[esp+596], eax
	fld	QWORD PTR __real@7fefffffffffffff
	mov	DWORD PTR $T68668[esp+600], eax
	mov	DWORD PTR $T68668[esp+604], eax
	fst	QWORD PTR $T68668[esp+580]
	mov	DWORD PTR $T68668[esp+608], eax
	fst	QWORD PTR $T68668[esp+588]
	lea	eax, DWORD PTR $T68668[esp+580]
	fst	QWORD PTR $T68668[esp+596]
	push	eax
	fstp	QWORD PTR $T68668[esp+608]
	push	0
	push	1
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T68669[esp+600], esp
	lea	ecx, DWORD PTR $T68670[esp+600]
	push	ecx
	lea	edx, DWORD PTR $T68671[esp+604]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	push	edx
	lea	eax, DWORD PTR $T68672[esp+608]
	push	eax
	call	DWORD PTR __imp_?dilate@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z
	add	esp, 32					; 00000020H

; 86   : 			dilate(dst,dst,dilateElement);

	lea	ecx, DWORD PTR _dilateElement$58596[esp+580]
	push	ecx
	lea	ecx, DWORD PTR $T68675[esp+584]
	call	ebx
	lea	edx, DWORD PTR _dst$[esp+580]
	push	edx
	lea	ecx, DWORD PTR $T68676[esp+584]
	call	esi
	lea	eax, DWORD PTR _dst$[esp+580]
	push	eax
	lea	ecx, DWORD PTR $T68677[esp+584]
	call	ebx
	fld	QWORD PTR __real@7fefffffffffffff
	xor	eax, eax
	lea	ecx, DWORD PTR $T68673[esp+580]
	push	ecx
	push	eax
	mov	DWORD PTR $T68673[esp+588], eax
	mov	DWORD PTR $T68673[esp+592], eax
	fst	QWORD PTR $T68673[esp+588]
	mov	DWORD PTR $T68673[esp+596], eax
	mov	DWORD PTR $T68673[esp+600], eax
	fst	QWORD PTR $T68673[esp+596]
	push	1
	mov	DWORD PTR $T68673[esp+608], eax
	mov	DWORD PTR $T68673[esp+612], eax
	fst	QWORD PTR $T68673[esp+608]
	mov	DWORD PTR $T68673[esp+616], eax
	mov	DWORD PTR $T68673[esp+620], eax
	fstp	QWORD PTR $T68673[esp+616]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T68674[esp+600], esp
	lea	edx, DWORD PTR $T68675[esp+600]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	push	edx
	lea	eax, DWORD PTR $T68676[esp+604]
	push	eax
	lea	ecx, DWORD PTR $T68677[esp+608]
	push	ecx
	call	DWORD PTR __imp_?dilate@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@0V?$Point_@H@1@HHABV?$Scalar_@N@1@@Z
	add	esp, 32					; 00000020H

; 87   : 
; 88   : 			// Perform Canny edge detection
; 89   : 			//findContours(dst, dst, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);
; 90   : 			Canny(dst, dst, 1, 3);

	lea	edx, DWORD PTR _dst$[esp+580]
	push	edx
	lea	ecx, DWORD PTR $T68678[esp+584]
	call	esi
	lea	eax, DWORD PTR _dst$[esp+580]
	push	eax
	lea	ecx, DWORD PTR $T68679[esp+584]
	call	ebx
	fld	QWORD PTR __real@4008000000000000
	push	0
	push	3
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld1
	lea	ecx, DWORD PTR $T68678[esp+604]
	fstp	QWORD PTR [esp]
	lea	edx, DWORD PTR $T68679[esp+604]
	push	ecx
	push	edx
	call	DWORD PTR __imp_?Canny@cv@@YAXABV_InputArray@1@ABV_OutputArray@1@NNH_N@Z
	add	esp, 32					; 00000020H

; 91   : 
; 92   : 			// Show the processed image
; 93   : 			imshow("Example3-out", dst);

	lea	eax, DWORD PTR _dst$[esp+580]
	push	eax
	lea	ecx, DWORD PTR $T68680[esp+584]
	call	ebx
	mov	edi, 12					; 0000000cH
	mov	eax, OFFSET ??_C@_0N@KINGNADO@Example3?9out?$AA@
	lea	esi, DWORD PTR $T58624[esp+580]
	mov	DWORD PTR $T58624[esp+600], 15		; 0000000fH
	mov	DWORD PTR $T58624[esp+596], 0
	mov	BYTE PTR $T58624[esp+580], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T68680[esp+580]
	push	ecx
	mov	edx, esi
	push	edx
	mov	BYTE PTR __$EHRec$[esp+596], 13		; 0000000dH
	call	DWORD PTR __imp_?imshow@cv@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV_InputArray@1@@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+588], 12		; 0000000cH
	cmp	DWORD PTR $T58624[esp+600], 16		; 00000010H
	jb	SHORT $LN565@Subtract
	mov	eax, DWORD PTR $T58624[esp+580]
	push	eax
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN565@Subtract:

; 94   : 			waitKey(30); //this must be here or image will not be displayed :/

	push	30					; 0000001eH
	call	DWORD PTR __imp_?waitKey@cv@@YAHH@Z

; 95   : 
; 96   : 		}

	mov	BYTE PTR __$EHRec$[esp+592], 11		; 0000000bH
	mov	eax, DWORD PTR _dilateElement$58596[esp+604]
	xor	esi, esi
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN583@Subtract
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN583@Subtract
	lea	ecx, DWORD PTR _dilateElement$58596[esp+580]
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN583@Subtract:
	xor	eax, eax
	mov	DWORD PTR _dilateElement$58596[esp+612], esi
	mov	DWORD PTR _dilateElement$58596[esp+608], esi
	mov	DWORD PTR _dilateElement$58596[esp+604], esi
	mov	DWORD PTR _dilateElement$58596[esp+596], esi
	cmp	DWORD PTR _dilateElement$58596[esp+584], esi
	jle	SHORT $LN580@Subtract
$LL582@Subtract:
	mov	ecx, DWORD PTR _dilateElement$58596[esp+620]
	mov	DWORD PTR [ecx+eax*4], esi
	inc	eax
	cmp	eax, DWORD PTR _dilateElement$58596[esp+584]
	jl	SHORT $LL582@Subtract
$LN580@Subtract:
	mov	eax, DWORD PTR _dilateElement$58596[esp+624]
	lea	edx, DWORD PTR _dilateElement$58596[esp+628]
	mov	DWORD PTR _dilateElement$58596[esp+600], esi
	cmp	eax, edx
	je	SHORT $LN577@Subtract
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
$LN577@Subtract:
	mov	BYTE PTR __$EHRec$[esp+588], 3
	mov	eax, DWORD PTR _erodeElement$58591[esp+600]
	cmp	eax, esi
	je	SHORT $LN592@Subtract
	push	-1
	push	eax
	call	DWORD PTR __imp_?_interlockedExchangeAdd@cv@@YAHPAHH@Z
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN592@Subtract
	lea	ecx, DWORD PTR _erodeElement$58591[esp+580]
	call	DWORD PTR __imp_?deallocate@Mat@cv@@QAEXXZ
$LN592@Subtract:
	xor	eax, eax
	mov	DWORD PTR _erodeElement$58591[esp+612], esi
	mov	DWORD PTR _erodeElement$58591[esp+608], esi
	mov	DWORD PTR _erodeElement$58591[esp+604], esi
	mov	DWORD PTR _erodeElement$58591[esp+596], esi
	cmp	DWORD PTR _erodeElement$58591[esp+584], esi
	jle	SHORT $LN589@Subtract
$LL591@Subtract:
	mov	ecx, DWORD PTR _erodeElement$58591[esp+620]
	mov	DWORD PTR [ecx+eax*4], esi
	inc	eax
	cmp	eax, DWORD PTR _erodeElement$58591[esp+584]
	jl	SHORT $LL591@Subtract
$LN589@Subtract:
	mov	eax, DWORD PTR _erodeElement$58591[esp+624]
	lea	edx, DWORD PTR _erodeElement$58591[esp+628]
	mov	DWORD PTR _erodeElement$58591[esp+600], esi
	cmp	eax, edx
	je	$LL2@Subtract
	push	eax
	call	DWORD PTR __imp_?fastFree@cv@@YAXPAX@Z
	add	esp, 4
	jmp	$LL2@Subtract
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$0:
	lea	eax, DWORD PTR _cameraFeed$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$1:
	lea	eax, DWORD PTR _dst$[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$2:
	lea	ecx, DWORD PTR _vcap$[ebp]
	jmp	DWORD PTR __imp_??1VideoCapture@cv@@UAE@XZ
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$3:
	lea	esi, DWORD PTR _trackbarWindowName$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$4:
	lea	esi, DWORD PTR $T58567[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$5:
	lea	esi, DWORD PTR $T58568[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$6:
	lea	esi, DWORD PTR $T58569[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$7:
	lea	esi, DWORD PTR $T58570[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$8:
	lea	esi, DWORD PTR $T58571[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$9:
	lea	esi, DWORD PTR $T58572[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$10:
	lea	esi, DWORD PTR $T58577[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$11:
	lea	eax, DWORD PTR _erodeElement$58591[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$12:
	lea	eax, DWORD PTR _dilateElement$58596[ebp]
	jmp	??1Mat@cv@@QAE@XZ			; cv::Mat::~Mat
__unwindfunclet$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z$13:
	lea	esi, DWORD PTR $T58624[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-564]
	mov	ecx, DWORD PTR [edx-568]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Subtract@MyMathFuncs@MathFuncs@@SANNN@Z ENDP		; MathFuncs::MyMathFuncs::Subtract
END
